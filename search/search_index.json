{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement CompartirIgual 2.5 Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"Acc\u00e9s a Dades - Componentes"},{"location":"Anotaciones/","text":"Anotaciones \u00b6 Las anotaciones son etiquetas especiales que se colocan encima de clases, funciones o atributos para decirle a Spring c\u00f3mo debe comportarse con ese c\u00f3digo. Las anotaciones son, por tanto, la forma en la que Spring entiende tu aplicaci\u00f3n. Spring tiene much\u00edsimas anotaciones, porque es un framework muy grande y sirve para muchos tipos de proyectos (web MVC, microservicios, seguridad, batch, mensajer\u00eda, etc.). En nuestro caso, como vamos a trabajar \u00fanicamente con Spring Boot, API REST, vistas HTML y JPA, no es necesario aprender todas las anotaciones que ofrece Spring. Basta con conocer un conjunto reducido de anotaciones b\u00e1sicas, suficientes para desarrollar un backend completo y funcional. En la siguiente tabla se recogen las anotaciones m\u00e1s importantes que utilizaremos a lo largo del tema. A medida que avancemos, ir\u00e1n apareciendo otras anotaciones adicionales que se introducir\u00e1n solo cuando sean necesarias para la aplicaci\u00f3n. Tabla de anotaciones b\u00e1sicas en Spring (para API REST/vistas HTML + JPA) Categor\u00eda Anotaci\u00f3n D\u00f3nde se usa Para qu\u00e9 sirve \ud83d\ude80 Arranque de la app @SpringBootApplication Clase principal Marca la clase de arranque de la aplicaci\u00f3n Spring Boot y activa la auto-configuraci\u00f3n y el escaneo de componentes. \ud83c\udf10 API REST @RestController Clase Indica que la clase es un controlador REST y que los m\u00e9todos devuelven directamente datos (normalmente JSON). @RequestMapping Clase o m\u00e9todo Define la ruta base o una ruta concreta para acceder a un recurso. @GetMapping M\u00e9todo Atiende peticiones HTTP GET (lectura de datos). @PostMapping M\u00e9todo Atiende peticiones HTTP POST (creaci\u00f3n de datos). @PutMapping M\u00e9todo Atiende peticiones HTTP PUT (actualizaci\u00f3n de datos). @DeleteMapping M\u00e9todo Atiende peticiones HTTP DELETE (eliminaci\u00f3n de datos). @RequestBody Par\u00e1metro Permite recibir datos enviados en el cuerpo de la petici\u00f3n (JSON). @PathVariable Par\u00e1metro Permite recoger valores de la URL (por ejemplo, un identificador). \ud83d\udda5\ufe0f MVC (vistas) @Controller Clase Marca una clase como controlador MVC tradicional, devolviendo vistas (HTML con Thymeleaf). \ud83e\udde0 L\u00f3gica de negocio @Service Clase Marca una clase como servicio, donde se implementa la l\u00f3gica de negocio. @Autowired Atributo o constructor Inyecta autom\u00e1ticamente una dependencia gestionada por Spring. \ud83d\uddc4\ufe0f JPA / Base de datos @Entity Clase Indica que la clase representa una tabla de la base de datos. @Table Clase Define el nombre de la tabla asociada a la entidad. @Id Atributo Marca el atributo como clave primaria. @GeneratedValue Atributo Indica que el valor de la clave primaria se genera autom\u00e1ticamente. @Column Atributo Configura una columna de la tabla (nombre, restricciones, unicidad, etc.). @OneToMany Atributo Define una relaci\u00f3n uno-a-muchos entre entidades. @ManyToOne Atributo Define una relaci\u00f3n muchos-a-uno entre entidades. @JoinColumn Atributo Especifica la columna usada como clave for\u00e1nea en una relaci\u00f3n. \ud83d\uddc3\ufe0f Acceso a datos @Repository Clase o interfaz Indica que la clase o interfaz se encarga del acceso a datos y de la gesti\u00f3n de excepciones de base de datos.","title":"\ud83d\udd39 Anotaciones"},{"location":"Anotaciones/#anotaciones","text":"Las anotaciones son etiquetas especiales que se colocan encima de clases, funciones o atributos para decirle a Spring c\u00f3mo debe comportarse con ese c\u00f3digo. Las anotaciones son, por tanto, la forma en la que Spring entiende tu aplicaci\u00f3n. Spring tiene much\u00edsimas anotaciones, porque es un framework muy grande y sirve para muchos tipos de proyectos (web MVC, microservicios, seguridad, batch, mensajer\u00eda, etc.). En nuestro caso, como vamos a trabajar \u00fanicamente con Spring Boot, API REST, vistas HTML y JPA, no es necesario aprender todas las anotaciones que ofrece Spring. Basta con conocer un conjunto reducido de anotaciones b\u00e1sicas, suficientes para desarrollar un backend completo y funcional. En la siguiente tabla se recogen las anotaciones m\u00e1s importantes que utilizaremos a lo largo del tema. A medida que avancemos, ir\u00e1n apareciendo otras anotaciones adicionales que se introducir\u00e1n solo cuando sean necesarias para la aplicaci\u00f3n. Tabla de anotaciones b\u00e1sicas en Spring (para API REST/vistas HTML + JPA) Categor\u00eda Anotaci\u00f3n D\u00f3nde se usa Para qu\u00e9 sirve \ud83d\ude80 Arranque de la app @SpringBootApplication Clase principal Marca la clase de arranque de la aplicaci\u00f3n Spring Boot y activa la auto-configuraci\u00f3n y el escaneo de componentes. \ud83c\udf10 API REST @RestController Clase Indica que la clase es un controlador REST y que los m\u00e9todos devuelven directamente datos (normalmente JSON). @RequestMapping Clase o m\u00e9todo Define la ruta base o una ruta concreta para acceder a un recurso. @GetMapping M\u00e9todo Atiende peticiones HTTP GET (lectura de datos). @PostMapping M\u00e9todo Atiende peticiones HTTP POST (creaci\u00f3n de datos). @PutMapping M\u00e9todo Atiende peticiones HTTP PUT (actualizaci\u00f3n de datos). @DeleteMapping M\u00e9todo Atiende peticiones HTTP DELETE (eliminaci\u00f3n de datos). @RequestBody Par\u00e1metro Permite recibir datos enviados en el cuerpo de la petici\u00f3n (JSON). @PathVariable Par\u00e1metro Permite recoger valores de la URL (por ejemplo, un identificador). \ud83d\udda5\ufe0f MVC (vistas) @Controller Clase Marca una clase como controlador MVC tradicional, devolviendo vistas (HTML con Thymeleaf). \ud83e\udde0 L\u00f3gica de negocio @Service Clase Marca una clase como servicio, donde se implementa la l\u00f3gica de negocio. @Autowired Atributo o constructor Inyecta autom\u00e1ticamente una dependencia gestionada por Spring. \ud83d\uddc4\ufe0f JPA / Base de datos @Entity Clase Indica que la clase representa una tabla de la base de datos. @Table Clase Define el nombre de la tabla asociada a la entidad. @Id Atributo Marca el atributo como clave primaria. @GeneratedValue Atributo Indica que el valor de la clave primaria se genera autom\u00e1ticamente. @Column Atributo Configura una columna de la tabla (nombre, restricciones, unicidad, etc.). @OneToMany Atributo Define una relaci\u00f3n uno-a-muchos entre entidades. @ManyToOne Atributo Define una relaci\u00f3n muchos-a-uno entre entidades. @JoinColumn Atributo Especifica la columna usada como clave for\u00e1nea en una relaci\u00f3n. \ud83d\uddc3\ufe0f Acceso a datos @Repository Clase o interfaz Indica que la clase o interfaz se encarga del acceso a datos y de la gesti\u00f3n de excepciones de base de datos.","title":"Anotaciones"},{"location":"Docker/","text":"Docker \u00b6 Docker es una herramienta que utiliza la tecnolog\u00eda de contenedores para empaquetar aplicaciones y sus dependencias en unidades port\u00e1tiles y ligeras. Esto garantiza que una aplicaci\u00f3n se ejecute de la misma manera en cualquier entorno, ya sea en una computadora local, un servidor de desarrollo, o en la nube. Conceptos clave de Docker Contenedores : Son entornos aislados que contienen todo lo necesario para ejecutar una aplicaci\u00f3n: c\u00f3digo, bibliotecas, dependencias, y configuraciones. A diferencia de las m\u00e1quinas virtuales, los contenedores comparten el mismo n\u00facleo del sistema operativo, lo que los hace m\u00e1s ligeros y eficientes. Im\u00e1genes : Son plantillas inmutables utilizadas para crear contenedores. Las im\u00e1genes son versiones preconfiguradas de un software o aplicaci\u00f3n que incluyen todo lo necesario para ejecutarse. Docker Engine : Es el motor que ejecuta y gestiona los contenedores. Permite construir im\u00e1genes, iniciar contenedores y comunicarse con el hardware del sistema. Docker Hub : Es un repositorio en l\u00ednea donde se pueden almacenar y compartir im\u00e1genes de Docker. Ofrece una amplia variedad de im\u00e1genes predefinidas listas para usar. \u00bfC\u00f3mo funciona Docker? Construcci\u00f3n de una imagen : Los desarrolladores crean un archivo llamado Dockerfile, donde se especifican los pasos para construir la imagen de una aplicaci\u00f3n. A partir del Dockerfile, Docker genera una imagen. Ejecuci\u00f3n de un contenedor : Usando una imagen, Docker inicia un contenedor que ejecuta la aplicaci\u00f3n empaquetada. Distribuci\u00f3n de im\u00e1genes : Las im\u00e1genes pueden ser subidas a Docker Hub u otros registros privados para compartirlas y utilizarlas en diferentes sistemas. Para saber m\u00e1s pod\u00e9is consultar su p\u00e1gina Web: https://www.docker.com/ Instalaci\u00f3n de Docker en Ubuntu \u00b6 https://docs.docker.com/desktop/setup/install/linux/ubuntu/ Requisitos previos \u00b6 Aseg\u00farate de que tu sistema est\u00e1 actualizado: sudo apt update && sudo apt upgrade -y Desinstala versiones antiguas de Docker si est\u00e1n instaladas: sudo apt remove docker docker-engine docker.io containerd runc Pasos para instalar Docker \u00b6 1) Instalar paquetes necesarios: sudo apt install apt-transport-https ca-certificates curl software-properties-common 2) Agregar la clave GPG de Docker: curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg 3) Agregar el repositorio de Docker: echo \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null 4) Actualizar el \u00edndice de paquetes e instalar Docker: sudo apt update sudo apt install docker-ce docker-ce-cli containerd.io 5) Verificar la instalaci\u00f3n: docker --version 6) Habilitar Docker para que inicie con el sistema: sudo systemctl enable docker 7) Opcional: Permitir ejecutar Docker sin sudo : sudo usermod -aG docker $USER # Sal y vuelve a iniciar sesi\u00f3n para aplicar los cambios Probar Docker \u00b6 Ejecuta el siguiente comando para probar si Docker est\u00e1 funcionando correctamente: docker run hello-world Instalaci\u00f3n de Docker en Windows \u00b6 https://docs.docker.com/desktop/setup/install/windows-install/ Requisitos previos \u00b6 Windows 10 o superior con soporte para WSL 2. Habilitar virtualizaci\u00f3n en el BIOS. Pasos para instalar Docker \u00b6 1) Descargar Docker Desktop: Ve al sitio oficial de Docker y descarga Docker Desktop: https://www.docker.com/products/docker-desktop 2) Ejecutar el instalador: Sigue las instrucciones del asistente de instalaci\u00f3n. 3) Habilitar WSL 2: Aseg\u00farate de que WSL 2 est\u00e1 habilitado en tu sistema: dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart wsl --set-default-version 2 4) Configurar Docker Desktop: Abre Docker Desktop y sigue las instrucciones para configurar WSL 2. 5) Verificar la instalaci\u00f3n: Abre una terminal y ejecuta: docker --version 6) Probar Docker: Ejecuta el comando: docker run hello-world Opcional: Configuraci\u00f3n adicional \u00b6 Habilitar compartir recursos (discos, memoria, CPU) en la configuraci\u00f3n de Docker Desktop. Instalar herramientas complementarias como Docker Compose. Con estos pasos, Docker deber\u00eda estar instalado y funcionando correctamente tanto en Ubuntu como en Windows.","title":"\ud83d\udd39 Docker"},{"location":"Docker/#docker","text":"Docker es una herramienta que utiliza la tecnolog\u00eda de contenedores para empaquetar aplicaciones y sus dependencias en unidades port\u00e1tiles y ligeras. Esto garantiza que una aplicaci\u00f3n se ejecute de la misma manera en cualquier entorno, ya sea en una computadora local, un servidor de desarrollo, o en la nube. Conceptos clave de Docker Contenedores : Son entornos aislados que contienen todo lo necesario para ejecutar una aplicaci\u00f3n: c\u00f3digo, bibliotecas, dependencias, y configuraciones. A diferencia de las m\u00e1quinas virtuales, los contenedores comparten el mismo n\u00facleo del sistema operativo, lo que los hace m\u00e1s ligeros y eficientes. Im\u00e1genes : Son plantillas inmutables utilizadas para crear contenedores. Las im\u00e1genes son versiones preconfiguradas de un software o aplicaci\u00f3n que incluyen todo lo necesario para ejecutarse. Docker Engine : Es el motor que ejecuta y gestiona los contenedores. Permite construir im\u00e1genes, iniciar contenedores y comunicarse con el hardware del sistema. Docker Hub : Es un repositorio en l\u00ednea donde se pueden almacenar y compartir im\u00e1genes de Docker. Ofrece una amplia variedad de im\u00e1genes predefinidas listas para usar. \u00bfC\u00f3mo funciona Docker? Construcci\u00f3n de una imagen : Los desarrolladores crean un archivo llamado Dockerfile, donde se especifican los pasos para construir la imagen de una aplicaci\u00f3n. A partir del Dockerfile, Docker genera una imagen. Ejecuci\u00f3n de un contenedor : Usando una imagen, Docker inicia un contenedor que ejecuta la aplicaci\u00f3n empaquetada. Distribuci\u00f3n de im\u00e1genes : Las im\u00e1genes pueden ser subidas a Docker Hub u otros registros privados para compartirlas y utilizarlas en diferentes sistemas. Para saber m\u00e1s pod\u00e9is consultar su p\u00e1gina Web: https://www.docker.com/","title":"Docker"},{"location":"Docker/#instalacion-de-docker-en-ubuntu","text":"https://docs.docker.com/desktop/setup/install/linux/ubuntu/","title":"Instalaci\u00f3n de Docker en Ubuntu"},{"location":"Docker/#requisitos-previos","text":"Aseg\u00farate de que tu sistema est\u00e1 actualizado: sudo apt update && sudo apt upgrade -y Desinstala versiones antiguas de Docker si est\u00e1n instaladas: sudo apt remove docker docker-engine docker.io containerd runc","title":"Requisitos previos"},{"location":"Docker/#pasos-para-instalar-docker","text":"1) Instalar paquetes necesarios: sudo apt install apt-transport-https ca-certificates curl software-properties-common 2) Agregar la clave GPG de Docker: curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg 3) Agregar el repositorio de Docker: echo \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null 4) Actualizar el \u00edndice de paquetes e instalar Docker: sudo apt update sudo apt install docker-ce docker-ce-cli containerd.io 5) Verificar la instalaci\u00f3n: docker --version 6) Habilitar Docker para que inicie con el sistema: sudo systemctl enable docker 7) Opcional: Permitir ejecutar Docker sin sudo : sudo usermod -aG docker $USER # Sal y vuelve a iniciar sesi\u00f3n para aplicar los cambios","title":"Pasos para instalar Docker"},{"location":"Docker/#probar-docker","text":"Ejecuta el siguiente comando para probar si Docker est\u00e1 funcionando correctamente: docker run hello-world","title":"Probar Docker"},{"location":"Docker/#instalacion-de-docker-en-windows","text":"https://docs.docker.com/desktop/setup/install/windows-install/","title":"Instalaci\u00f3n de Docker en Windows"},{"location":"Docker/#requisitos-previos_1","text":"Windows 10 o superior con soporte para WSL 2. Habilitar virtualizaci\u00f3n en el BIOS.","title":"Requisitos previos"},{"location":"Docker/#pasos-para-instalar-docker_1","text":"1) Descargar Docker Desktop: Ve al sitio oficial de Docker y descarga Docker Desktop: https://www.docker.com/products/docker-desktop 2) Ejecutar el instalador: Sigue las instrucciones del asistente de instalaci\u00f3n. 3) Habilitar WSL 2: Aseg\u00farate de que WSL 2 est\u00e1 habilitado en tu sistema: dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart wsl --set-default-version 2 4) Configurar Docker Desktop: Abre Docker Desktop y sigue las instrucciones para configurar WSL 2. 5) Verificar la instalaci\u00f3n: Abre una terminal y ejecuta: docker --version 6) Probar Docker: Ejecuta el comando: docker run hello-world","title":"Pasos para instalar Docker"},{"location":"Docker/#opcional-configuracion-adicional","text":"Habilitar compartir recursos (discos, memoria, CPU) en la configuraci\u00f3n de Docker Desktop. Instalar herramientas complementarias como Docker Compose. Con estos pasos, Docker deber\u00eda estar instalado y funcionando correctamente tanto en Ubuntu como en Windows.","title":"Opcional: Configuraci\u00f3n adicional"},{"location":"Spring/","text":"Spring Framework \u00b6 Spring es un framework de c\u00f3digo abierto que te ayuda a crear aplicaciones en Java o Kotlin de forma m\u00e1s f\u00e1cil, r\u00e1pida y ordenada. En vez de que t\u00fa tengas que hacer todo a mano (crear objetos, conectar clases, preparar la base de datos, configurar servidores\u2026), Spring lo hace por ti autom\u00e1ticamente. \ud83d\udcad Imagina que construir una aplicaci\u00f3n es como montar un mueble enorme. Sin Spring: t\u00fa haces todos los agujeros, ajustes y conexiones. Con Spring: el mueble viene ya pre-montado y solo colocas las piezas que necesitas. \ud83e\ude84 Spring te da la estructura y se encarga de la parte dif\u00edcil. Filosof\u00eda de Spring Spring se basa principalmente en dos ideas fundamentales : 1\ufe0f\u20e3 Inversi\u00f3n de Control (IoC) \ud83d\udd04 : Spring se encarga de crear y gestionar los objetos de tu aplicaci\u00f3n. 2\ufe0f\u20e3 Inyecci\u00f3n de Dependencias (DI)\ud83d\udd0c : Spring coloca los objetos donde hacen falta autom\u00e1ticamente. Es como si Spring fuera quien enchufa los cables para que todas las piezas funcionen juntas sin que t\u00fa los conectes. Adem\u00e1s de IoC y DI, Spring se basa en tres pilares pr\u00e1cticos : 3\ufe0f\u20e3 Anotaciones : indican qu\u00e9 hace cada clase. @Controller \u2192 muestra p\u00e1ginas @RestController \u2192 devuelve JSON @Service \u2192 l\u00f3gica de negocio @Repository \u2192 acceso a datos @Entity \u2192 tabla de la base de datos 4\ufe0f\u20e3 Autoconfiguraci\u00f3n (Spring Boot) : prepara el proyecto por ti. servidor web conexi\u00f3n a BD estructura de proyecto dependencias necesarias 5\ufe0f\u20e3 Starters : paquetes listos para usar seg\u00fan lo que quieras hacer.. spring-boot-starter-web \u2192 para rutas y controladores spring-boot-starter-data-jpa \u2192 para BD y CRUD spring-boot-starter-thymeleaf \u2192 para p\u00e1ginas HTML Componentes principales: Los componentes principales de Spring Framework son: Spring Core : El n\u00facleo del framework, encargado de la inyecci\u00f3n de dependencias. Spring MVC : Permite el desarrollo de aplicaciones web utilizando el patr\u00f3n Modelo-Vista-Controlador. Spring Boot : Facilita la creaci\u00f3n de aplicaciones basadas en Spring con una configuraci\u00f3n m\u00ednima. Spring Data : Simplifica el acceso a datos con soporte para JPA, MongoDB, Redis, entre otros. Spring Security : Proporciona herramientas para implementar seguridad en aplicaciones. Spring Cloud : Ayuda en la construcci\u00f3n de aplicaciones distribuidas y microservicios. Requisitos previos para crear una aplicaci\u00f3n con Spring JDK: Aseg\u00farate de tener Java Development Kit instalado. Maven o Gradle: Para gestionar dependencias. IDE: IntelliJ IDEA, Eclipse u otro entorno de desarrollo.","title":"\ud83d\udd39 Spring Framework"},{"location":"Spring/#spring-framework","text":"Spring es un framework de c\u00f3digo abierto que te ayuda a crear aplicaciones en Java o Kotlin de forma m\u00e1s f\u00e1cil, r\u00e1pida y ordenada. En vez de que t\u00fa tengas que hacer todo a mano (crear objetos, conectar clases, preparar la base de datos, configurar servidores\u2026), Spring lo hace por ti autom\u00e1ticamente. \ud83d\udcad Imagina que construir una aplicaci\u00f3n es como montar un mueble enorme. Sin Spring: t\u00fa haces todos los agujeros, ajustes y conexiones. Con Spring: el mueble viene ya pre-montado y solo colocas las piezas que necesitas. \ud83e\ude84 Spring te da la estructura y se encarga de la parte dif\u00edcil. Filosof\u00eda de Spring Spring se basa principalmente en dos ideas fundamentales : 1\ufe0f\u20e3 Inversi\u00f3n de Control (IoC) \ud83d\udd04 : Spring se encarga de crear y gestionar los objetos de tu aplicaci\u00f3n. 2\ufe0f\u20e3 Inyecci\u00f3n de Dependencias (DI)\ud83d\udd0c : Spring coloca los objetos donde hacen falta autom\u00e1ticamente. Es como si Spring fuera quien enchufa los cables para que todas las piezas funcionen juntas sin que t\u00fa los conectes. Adem\u00e1s de IoC y DI, Spring se basa en tres pilares pr\u00e1cticos : 3\ufe0f\u20e3 Anotaciones : indican qu\u00e9 hace cada clase. @Controller \u2192 muestra p\u00e1ginas @RestController \u2192 devuelve JSON @Service \u2192 l\u00f3gica de negocio @Repository \u2192 acceso a datos @Entity \u2192 tabla de la base de datos 4\ufe0f\u20e3 Autoconfiguraci\u00f3n (Spring Boot) : prepara el proyecto por ti. servidor web conexi\u00f3n a BD estructura de proyecto dependencias necesarias 5\ufe0f\u20e3 Starters : paquetes listos para usar seg\u00fan lo que quieras hacer.. spring-boot-starter-web \u2192 para rutas y controladores spring-boot-starter-data-jpa \u2192 para BD y CRUD spring-boot-starter-thymeleaf \u2192 para p\u00e1ginas HTML Componentes principales: Los componentes principales de Spring Framework son: Spring Core : El n\u00facleo del framework, encargado de la inyecci\u00f3n de dependencias. Spring MVC : Permite el desarrollo de aplicaciones web utilizando el patr\u00f3n Modelo-Vista-Controlador. Spring Boot : Facilita la creaci\u00f3n de aplicaciones basadas en Spring con una configuraci\u00f3n m\u00ednima. Spring Data : Simplifica el acceso a datos con soporte para JPA, MongoDB, Redis, entre otros. Spring Security : Proporciona herramientas para implementar seguridad en aplicaciones. Spring Cloud : Ayuda en la construcci\u00f3n de aplicaciones distribuidas y microservicios. Requisitos previos para crear una aplicaci\u00f3n con Spring JDK: Aseg\u00farate de tener Java Development Kit instalado. Maven o Gradle: Para gestionar dependencias. IDE: IntelliJ IDEA, Eclipse u otro entorno de desarrollo.","title":"Spring Framework"},{"location":"SpringBoot/","text":"\ud83d\udd39Spring Boot \u00b6 Spring es el framework completo; Spring Boot es la forma f\u00e1cil y moderna de usar Spring. Tradicionalmente Spring era complicado de configurar, hab\u00eda que preparar servidores, XML, dependencias, etc. Spring Boot se enfoca en simplificar y acelerar el desarrollo de aplicaciones web y microservicios, ofreciendo una configuraci\u00f3n autom\u00e1tica y la capacidad de crear aplicaciones que se ejecutan de forma independiente sin necesidad de un servidor web externo. Spring Boot es una capa por encima de Spring que lo hace f\u00e1cil: configura todo autom\u00e1ticamente trae un servidor web incorporado evita escribir XML permite arrancar una app con un bot\u00f3n usa starters (dependencias ya preparadas) permite crear proyectos en segundos Pasos para crear una aplicaci\u00f3n con Spring Boot Fundamentalmente existen tres pasos a realizar . El primero es crear un proyecto Maven/Gradle y descargar las dependencias necesarias. En segundo lugar desarrollamos la aplicaci\u00f3n y en tercer lugar la desplegamos en un servidor. Si nos ponemos a pensar un poco a detalle en el tema, \u00fanicamente el paso dos es una tarea de desarrollo. Los otros pasos est\u00e1n m\u00e1s orientados a infraestructura. SpringBoot nace con la intenci\u00f3n de simplificar los pasos 1 y 3 y que nos podamos centrar en el desarrollo de nuestra aplicaci\u00f3n. \u00bfC\u00f3mo funciona? El enfoque es sencillo y lo entenderemos realizando un ejemplo. Tambi\u00e9n tendr\u00e1 especial importancia el archivo applicantion.properties que ser\u00e1 donde configuraremos aspectos relativos con nuestra aplicaci\u00f3n, tales como las conexiones a base de datos o el puerto por donde acceder a nuestra aplicaci\u00f3n por ejemplo. Tambi\u00e9n podemos ver todas las dependencias que se han a\u00f1adido gracias al archivo pom.xml \ud83d\udd39Ejemplo con SpringBoot \u00b6 Para entender la filosf\u00eda de Spring lo mejor es hacer una primera aplicaci\u00f3n sencilla. Esta aplicaci\u00f3n consistir\u00e1 en devolver un saludo al usuario a trav\u00e9s de un navegador web. Acontinuaci\u00f3n se detallan los pasos a seguir. Podemos crear los proyectos Spring Boot de dos maneras: Mediante una herramienta web online ( https://start.spring.io/ ) denominada Spring Initializr , donde por medio de unos par\u00e1metros de configuraci\u00f3n, genera autom\u00e1ticamente un proyecto Maven o Gradle, seg\u00fan elijamos, en un archivo comprimido Zip, con la estructura de la aplicaci\u00f3n y que puede ser importada directamente desde un IDE. Mediante un IDE, como Eclipse, IntelliJ...etc, teniendo instalados los plugins necesarios. En nuestro caso crearemos un proyecto Maven de Spring Boot en IntelliJ : Crear la aplicaci\u00f3n y a\u00f1adir dependencias 1\ufe0f\u20e3 Creamos el proyecto y lo configuramos desde File-->New-->Project : Elige Spring Boot . Configura las siguientes opciones: Language: Kotlin Build System: Maven Especifica un nombre para el proyecto: PrimerSpringBoot \u00daltima versi\u00f3n de JDK \u00daltima versi\u00f3n de Java 2\ufe0f\u20e3 Posteriormente seleccionamos las dependencias necesarias: Spring Web (para el desarrollo de aplicaciones web) 3\ufe0f\u20e3 Despu\u00e9s de aceptar, y si todo ha ido correctamente, ya tendremos nuestro proyecto creado. Nota Para este proyecto solo necesitaremos la dependenica Spring Web : Se utiliza para desarrollar aplicaciones web, ya sea basadas en REST o tradicionales con HTML din\u00e1mico. Incluye un servidor web embebido (por defecto, Tomcat) para ejecutar la aplicaci\u00f3n sin necesidad de configurarlo manualmente. Facilita el manejo de rutas HTTP (GET, POST, PUT, DELETE, etc.) y par\u00e1metros de solicitud a trav\u00e9s de m\u00e9todos en los controladores. Usa la biblioteca Jackson (incluida por defecto) para convertir autom\u00e1ticamente objetos Kotlin/Java a JSON y viceversa. Ofrece herramientas para manejar errores y excepciones de forma global mediante @ControllerAdvice o controladores personalizados. Al iniciar nuestra aplicaci\u00f3n, lo primero que observamos es que se crea una clase PrimerSpringBootApplication que sirve como contenedor para la configuraci\u00f3n de la aplicaci\u00f3n. No necesitas implementar m\u00e9todos adicionales, ya que Spring Boot se encarga de todo gracias a la anotaci\u00f3n @SpringBootApplication . La clase est\u00e1 anotada con @SpringBootApplication y, runApplication , es una funci\u00f3n de extensi\u00f3n proporcionada por Spring Boot para lanzar la aplicaci\u00f3n. @SpringBootApplication class PrimerSpringBootApplication fun main(args: Array<String>) { runApplication<PrimerSpringBootApplication>(*args) } El tipo gen\u00e9rico < PrimerSpringBootApplication > indica que \u00e9sta es la clase principal de la aplicaci\u00f3n que contiene la anotaci\u00f3n @SpringBootApplication . *args pasa los argumentos de la l\u00ednea de comandos a la aplicaci\u00f3n. Se utiliza para descomponer un array (como Array < String > ) en argumentos individuales, lo que es necesario para pasar los par\u00e1metros de la l\u00ednea de comandos al m\u00e9todo runApplication. Agregar un m\u00e9todo que env\u00ede un saludo Agregaremos el m\u00e9todo sayHello() directamente a la clase principal, PrimerSpringBootApplication , con todas las anotaciones e importaciones necesarias:: package com.example.primerspringboot import org.springframework.boot.autoconfigure.SpringBootApplication import org.springframework.boot.runApplication import org.springframework.web.bind.annotation.GetMapping import org.springframework.web.bind.annotation.RequestParam import org.springframework.web.bind.annotation.RestController @SpringBootApplication @RestController class PrimerSpringBootApplication{ @GetMapping(\"/hello\") fun sayHello( @RequestParam(value = \"myName\", defaultValue = \"World\") name: String): String { return \"Hello $name!\" } } fun main(args: Array<String>) { runApplication<PrimerSpringBootApplication>(*args) } @RestController : se utiliza para que Spring reconozca la clase como un controlador que maneja solicitudes HTTP. Combina: @Controller: Define la clase como un controlador web. @ResponseBody: Indica que los m\u00e9todos devolver\u00e1n directamente el cuerpo de la respuesta (en este caso, texto plano en lugar de una vista HTML). @GetMapping(\"/hello\") : Es una anotaci\u00f3n de Spring que indica que este m\u00e9todo debe manejar las solicitudes HTTP GET que lleguen a la URL /hello. Enlaza la URL /hello con el m\u00e9todo sayHello. Cada vez que se acceda a esa ruta en un navegador con un m\u00e9todo GET, Spring ejecutar\u00e1 el m\u00e9todo sayHello. Por ejemplo, al visitar http://localhost:8080/hello (asumiendo el puerto predeterminado 8080), este m\u00e9todo ser\u00e1 invocado. @RequestParam : se usa para extraer un par\u00e1metro de la consulta (query parameter) enviado en la URL. El m\u00e9todo espera un par\u00e1metro de consulta llamado myName. Si el cliente no incluye myName en la solicitud, el valor predeterminado ser\u00e1 \"World\", gracias a defaultValue = \"World\". Ejecuta la aplicaci\u00f3n Spring Al ejecutar la aplicaci\u00f3n, la pesta\u00f1a Consola muestra la salida de los mensajes de registro de Spring. De manera predeterminada, el servidor Apache Tomcat integrado escucha en el puerto 8080 . Nota Si tienes el puerto 8080 ocupado, te aparecer\u00e1 el siguiete error: Puedes cambiar el puerto en el archivo application.properties que se encuentra en la carpeta resources de tu proyecto. Por ejemplo estaleciendo el puerto a 8888: Ahora abre el navegador web a la direcci\u00f3n http://localhost:8080/hello , o con el puerto que hayas seleccionado. Deber\u00edas ver que tu aplicaci\u00f3n responde con Hello World! . Nota Esta es la respuesta gen\u00e9rica predeterminada. Puedes proporcionar un par\u00e1metro en tu solicitud web para que la aplicaci\u00f3n sepa c\u00f3mo saludarte correctamente. Por ejemplo, prueba http://localhost:8080/hello?myName=Alicia . Para entender el funcionamiento de la aplicaci\u00f3n, aqu\u00ed tienes resumido su flujo de ejecuci\u00f3n: Flujo de ejecuci\u00f3n Inicio de la aplicaci\u00f3n: Se ejecuta el m\u00e9todo main, lo que inicia un servidor web embebido (por defecto, Tomcat ) en el puerto 8080 . Solicitudes HTTP: Cuando un cliente env\u00eda una solicitud GET a /hello con o sin el par\u00e1metro myName , el m\u00e9todo sayHello maneja la solicitud. Respuesta: La aplicaci\u00f3n devuelve un mensaje personalizado en texto plano seg\u00fan el par\u00e1metro myName . A\u00f1adir una p\u00e1gina de inicio La aplicaci\u00f3n Spring Boot creada tiene un punto final disponible en /hello . Sin embargo, si abres el contexto ra\u00edz de tu aplicaci\u00f3n en http://localhost:8080/ , obtendr\u00e1s un error porque no hay ning\u00fan recurso ra\u00edz definido. Spring Boot est\u00e1 configurado para servir autom\u00e1ticamente cualquier archivo colocado en: static/ public/ resources/ META-INF/resources/ Esto significa que si pones un archivo est\u00e1tico ah\u00ed: el servidor embebido (Tomcat) lo devuelve tal cual no pasa por ning\u00fan controlador no necesita anotaciones no tienes que hacer un @GetMapping. 1\ufe0f\u20e3 A\u00f1ade una p\u00e1gina de inicio HTML est\u00e1tica con enlaces a su punto final. Crea el archivo index.html en /src /main /resources /static/ . 2\ufe0f\u20e3 Modifica la plantilla predeterminada o reempl\u00e1zala con el siguiente c\u00f3digo HTML: <!DOCTYPE HTML> <html> <head> <title>Your first Spring application</title> <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" /> </head> <body> <p><a href=\"/hello\">Greet the world!</a></p> <form action=\"/hello\" method=\"GET\" id=\"nameForm\"> <div> <label for=\"nameField\">How should the app call you?</label> <input name=\"myName\" id=\"nameField\"> <button>Greet me!</button> </div> </form> </body> </html> 3\ufe0f\u20e3 Ejecuta la aplicaci\u00f3n de nuevo. Ahora tu aplicaci\u00f3n servir\u00e1 index.html como recurso ra\u00edz en http://localhost:8080/ .","title":"\ud83d\udd39 SpringBoot"},{"location":"SpringBoot/#spring-boot","text":"Spring es el framework completo; Spring Boot es la forma f\u00e1cil y moderna de usar Spring. Tradicionalmente Spring era complicado de configurar, hab\u00eda que preparar servidores, XML, dependencias, etc. Spring Boot se enfoca en simplificar y acelerar el desarrollo de aplicaciones web y microservicios, ofreciendo una configuraci\u00f3n autom\u00e1tica y la capacidad de crear aplicaciones que se ejecutan de forma independiente sin necesidad de un servidor web externo. Spring Boot es una capa por encima de Spring que lo hace f\u00e1cil: configura todo autom\u00e1ticamente trae un servidor web incorporado evita escribir XML permite arrancar una app con un bot\u00f3n usa starters (dependencias ya preparadas) permite crear proyectos en segundos Pasos para crear una aplicaci\u00f3n con Spring Boot Fundamentalmente existen tres pasos a realizar . El primero es crear un proyecto Maven/Gradle y descargar las dependencias necesarias. En segundo lugar desarrollamos la aplicaci\u00f3n y en tercer lugar la desplegamos en un servidor. Si nos ponemos a pensar un poco a detalle en el tema, \u00fanicamente el paso dos es una tarea de desarrollo. Los otros pasos est\u00e1n m\u00e1s orientados a infraestructura. SpringBoot nace con la intenci\u00f3n de simplificar los pasos 1 y 3 y que nos podamos centrar en el desarrollo de nuestra aplicaci\u00f3n. \u00bfC\u00f3mo funciona? El enfoque es sencillo y lo entenderemos realizando un ejemplo. Tambi\u00e9n tendr\u00e1 especial importancia el archivo applicantion.properties que ser\u00e1 donde configuraremos aspectos relativos con nuestra aplicaci\u00f3n, tales como las conexiones a base de datos o el puerto por donde acceder a nuestra aplicaci\u00f3n por ejemplo. Tambi\u00e9n podemos ver todas las dependencias que se han a\u00f1adido gracias al archivo pom.xml","title":"\ud83d\udd39Spring Boot"},{"location":"SpringBoot/#ejemplo-con-springboot","text":"Para entender la filosf\u00eda de Spring lo mejor es hacer una primera aplicaci\u00f3n sencilla. Esta aplicaci\u00f3n consistir\u00e1 en devolver un saludo al usuario a trav\u00e9s de un navegador web. Acontinuaci\u00f3n se detallan los pasos a seguir. Podemos crear los proyectos Spring Boot de dos maneras: Mediante una herramienta web online ( https://start.spring.io/ ) denominada Spring Initializr , donde por medio de unos par\u00e1metros de configuraci\u00f3n, genera autom\u00e1ticamente un proyecto Maven o Gradle, seg\u00fan elijamos, en un archivo comprimido Zip, con la estructura de la aplicaci\u00f3n y que puede ser importada directamente desde un IDE. Mediante un IDE, como Eclipse, IntelliJ...etc, teniendo instalados los plugins necesarios. En nuestro caso crearemos un proyecto Maven de Spring Boot en IntelliJ : Crear la aplicaci\u00f3n y a\u00f1adir dependencias 1\ufe0f\u20e3 Creamos el proyecto y lo configuramos desde File-->New-->Project : Elige Spring Boot . Configura las siguientes opciones: Language: Kotlin Build System: Maven Especifica un nombre para el proyecto: PrimerSpringBoot \u00daltima versi\u00f3n de JDK \u00daltima versi\u00f3n de Java 2\ufe0f\u20e3 Posteriormente seleccionamos las dependencias necesarias: Spring Web (para el desarrollo de aplicaciones web) 3\ufe0f\u20e3 Despu\u00e9s de aceptar, y si todo ha ido correctamente, ya tendremos nuestro proyecto creado. Nota Para este proyecto solo necesitaremos la dependenica Spring Web : Se utiliza para desarrollar aplicaciones web, ya sea basadas en REST o tradicionales con HTML din\u00e1mico. Incluye un servidor web embebido (por defecto, Tomcat) para ejecutar la aplicaci\u00f3n sin necesidad de configurarlo manualmente. Facilita el manejo de rutas HTTP (GET, POST, PUT, DELETE, etc.) y par\u00e1metros de solicitud a trav\u00e9s de m\u00e9todos en los controladores. Usa la biblioteca Jackson (incluida por defecto) para convertir autom\u00e1ticamente objetos Kotlin/Java a JSON y viceversa. Ofrece herramientas para manejar errores y excepciones de forma global mediante @ControllerAdvice o controladores personalizados. Al iniciar nuestra aplicaci\u00f3n, lo primero que observamos es que se crea una clase PrimerSpringBootApplication que sirve como contenedor para la configuraci\u00f3n de la aplicaci\u00f3n. No necesitas implementar m\u00e9todos adicionales, ya que Spring Boot se encarga de todo gracias a la anotaci\u00f3n @SpringBootApplication . La clase est\u00e1 anotada con @SpringBootApplication y, runApplication , es una funci\u00f3n de extensi\u00f3n proporcionada por Spring Boot para lanzar la aplicaci\u00f3n. @SpringBootApplication class PrimerSpringBootApplication fun main(args: Array<String>) { runApplication<PrimerSpringBootApplication>(*args) } El tipo gen\u00e9rico < PrimerSpringBootApplication > indica que \u00e9sta es la clase principal de la aplicaci\u00f3n que contiene la anotaci\u00f3n @SpringBootApplication . *args pasa los argumentos de la l\u00ednea de comandos a la aplicaci\u00f3n. Se utiliza para descomponer un array (como Array < String > ) en argumentos individuales, lo que es necesario para pasar los par\u00e1metros de la l\u00ednea de comandos al m\u00e9todo runApplication. Agregar un m\u00e9todo que env\u00ede un saludo Agregaremos el m\u00e9todo sayHello() directamente a la clase principal, PrimerSpringBootApplication , con todas las anotaciones e importaciones necesarias:: package com.example.primerspringboot import org.springframework.boot.autoconfigure.SpringBootApplication import org.springframework.boot.runApplication import org.springframework.web.bind.annotation.GetMapping import org.springframework.web.bind.annotation.RequestParam import org.springframework.web.bind.annotation.RestController @SpringBootApplication @RestController class PrimerSpringBootApplication{ @GetMapping(\"/hello\") fun sayHello( @RequestParam(value = \"myName\", defaultValue = \"World\") name: String): String { return \"Hello $name!\" } } fun main(args: Array<String>) { runApplication<PrimerSpringBootApplication>(*args) } @RestController : se utiliza para que Spring reconozca la clase como un controlador que maneja solicitudes HTTP. Combina: @Controller: Define la clase como un controlador web. @ResponseBody: Indica que los m\u00e9todos devolver\u00e1n directamente el cuerpo de la respuesta (en este caso, texto plano en lugar de una vista HTML). @GetMapping(\"/hello\") : Es una anotaci\u00f3n de Spring que indica que este m\u00e9todo debe manejar las solicitudes HTTP GET que lleguen a la URL /hello. Enlaza la URL /hello con el m\u00e9todo sayHello. Cada vez que se acceda a esa ruta en un navegador con un m\u00e9todo GET, Spring ejecutar\u00e1 el m\u00e9todo sayHello. Por ejemplo, al visitar http://localhost:8080/hello (asumiendo el puerto predeterminado 8080), este m\u00e9todo ser\u00e1 invocado. @RequestParam : se usa para extraer un par\u00e1metro de la consulta (query parameter) enviado en la URL. El m\u00e9todo espera un par\u00e1metro de consulta llamado myName. Si el cliente no incluye myName en la solicitud, el valor predeterminado ser\u00e1 \"World\", gracias a defaultValue = \"World\". Ejecuta la aplicaci\u00f3n Spring Al ejecutar la aplicaci\u00f3n, la pesta\u00f1a Consola muestra la salida de los mensajes de registro de Spring. De manera predeterminada, el servidor Apache Tomcat integrado escucha en el puerto 8080 . Nota Si tienes el puerto 8080 ocupado, te aparecer\u00e1 el siguiete error: Puedes cambiar el puerto en el archivo application.properties que se encuentra en la carpeta resources de tu proyecto. Por ejemplo estaleciendo el puerto a 8888: Ahora abre el navegador web a la direcci\u00f3n http://localhost:8080/hello , o con el puerto que hayas seleccionado. Deber\u00edas ver que tu aplicaci\u00f3n responde con Hello World! . Nota Esta es la respuesta gen\u00e9rica predeterminada. Puedes proporcionar un par\u00e1metro en tu solicitud web para que la aplicaci\u00f3n sepa c\u00f3mo saludarte correctamente. Por ejemplo, prueba http://localhost:8080/hello?myName=Alicia . Para entender el funcionamiento de la aplicaci\u00f3n, aqu\u00ed tienes resumido su flujo de ejecuci\u00f3n: Flujo de ejecuci\u00f3n Inicio de la aplicaci\u00f3n: Se ejecuta el m\u00e9todo main, lo que inicia un servidor web embebido (por defecto, Tomcat ) en el puerto 8080 . Solicitudes HTTP: Cuando un cliente env\u00eda una solicitud GET a /hello con o sin el par\u00e1metro myName , el m\u00e9todo sayHello maneja la solicitud. Respuesta: La aplicaci\u00f3n devuelve un mensaje personalizado en texto plano seg\u00fan el par\u00e1metro myName . A\u00f1adir una p\u00e1gina de inicio La aplicaci\u00f3n Spring Boot creada tiene un punto final disponible en /hello . Sin embargo, si abres el contexto ra\u00edz de tu aplicaci\u00f3n en http://localhost:8080/ , obtendr\u00e1s un error porque no hay ning\u00fan recurso ra\u00edz definido. Spring Boot est\u00e1 configurado para servir autom\u00e1ticamente cualquier archivo colocado en: static/ public/ resources/ META-INF/resources/ Esto significa que si pones un archivo est\u00e1tico ah\u00ed: el servidor embebido (Tomcat) lo devuelve tal cual no pasa por ning\u00fan controlador no necesita anotaciones no tienes que hacer un @GetMapping. 1\ufe0f\u20e3 A\u00f1ade una p\u00e1gina de inicio HTML est\u00e1tica con enlaces a su punto final. Crea el archivo index.html en /src /main /resources /static/ . 2\ufe0f\u20e3 Modifica la plantilla predeterminada o reempl\u00e1zala con el siguiente c\u00f3digo HTML: <!DOCTYPE HTML> <html> <head> <title>Your first Spring application</title> <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" /> </head> <body> <p><a href=\"/hello\">Greet the world!</a></p> <form action=\"/hello\" method=\"GET\" id=\"nameForm\"> <div> <label for=\"nameField\">How should the app call you?</label> <input name=\"myName\" id=\"nameField\"> <button>Greet me!</button> </div> </form> </body> </html> 3\ufe0f\u20e3 Ejecuta la aplicaci\u00f3n de nuevo. Ahora tu aplicaci\u00f3n servir\u00e1 index.html como recurso ra\u00edz en http://localhost:8080/ .","title":"\ud83d\udd39Ejemplo con SpringBoot"},{"location":"SpringData/","text":"\ud83d\udd39Spring Data \u00b6 Spring Data es un proyecto dentro del ecosistema Spring que proporciona herramientas y abstracciones para facilitar el acceso a bases de datos y otras fuentes de datos de manera eficiente y consistente . Su objetivo principal es simplificar la interacci\u00f3n con diferentes tipos de bases de datos , tanto relacionales (como PostgreSQL o MySQL) como NoSQL (por ejemplo MongoDB o Cassandra), reduciendo la cantidad de c\u00f3digo necesario y unificando la forma de trabajar con los datos . \u00bfPara qu\u00e9 se utiliza? 1\ufe0f\u20e3 Acceso Simplificado a Datos: Reduce la necesidad de escribir consultas SQL complejas o c\u00f3digo JDBC al exponer m\u00e9todos predefinidos para operaciones comunes. Permite realizar operaciones CRUD (Crear, Leer, Actualizar, Eliminar) con facilidad. 2\ufe0f\u20e3 Abstracci\u00f3n de Repositorios: Ofrece la interfaz Repository y subinterfaces como CrudRepository y JpaRepository que proporcionan m\u00e9todos est\u00e1ndar para la gesti\u00f3n de entidades en bases de datos relacionales. 3\ufe0f\u20e3 Consultas Personalizadas: Permite escribir consultas personalizadas mediante anotaciones como @Query . Tambi\u00e9n admite la creaci\u00f3n de m\u00e9todos de consulta basados en el nombre del m\u00e9todo, como findByNombre(String nombre) . 4\ufe0f\u20e3 Compatibilidad con M\u00faltiples Tecnolog\u00edas de Bases de Datos: Relacionales: Mediante JPA (Java Persistence API). NoSQL: MongoDB, Redis, Neo4j, Cassandra, etc. Buscadores: Elasticsearch, Solr. 5\ufe0f\u20e3 Configuraci\u00f3n Declarativa: Al integrar Spring Data con Spring Boot, se pueden configurar muchas opciones mediante propiedades en application.properties , evitando configuraciones manuales detalladas. 6\ufe0f\u20e3 Integraci\u00f3n con Spring Boot: Con dependencias espec\u00edficas como spring-boot-starter-data-jpa o spring-boot-starter-data-mongodb , Spring Data se integra perfectamente con el resto del ecosistema de Spring. Principales M\u00f3dulos de Spring Data En lugar de proporcionar una \u00fanica soluci\u00f3n, Spring Data est\u00e1 compuesto por varios m\u00f3dulos, cada uno dise\u00f1ado para un tipo concreto de tecnolog\u00eda de persistencia, como bases de datos relacionales, NoSQL o sistemas de b\u00fasqueda. Gracias a esta estructura modular, el desarrollador puede cambiar la tecnolog\u00eda de persistencia sin modificar la arquitectura general de la aplicaci\u00f3n. Spring Data JPA: : Proporciona una integraci\u00f3n con JPA para bases de datos relacionales. Es ideal para trabajar con entidades Java mapeadas a tablas de bases de datos. JPA es la especificaci\u00f3n para persistir, leer y gestionar data desde los objetos Java a la base de datos. Spring Data MongoDB: : Facilita el acceso a bases de datos MongoDB, una base de datos NoSQL orientada a documentos. Spring Data Redis: : Para aplicaciones que necesitan interactuar con Redis, una base de datos en memoria. Spring Data Cassandra: : Proporciona soporte para bases de datos distribuidas como Cassandra. Spring Data Elasticsearch: : Simplifica las interacciones con Elasticsearch, un motor de b\u00fasqueda y an\u00e1lisis. \ud83d\udd39Spring Data JPA \u00b6 Spring Data JPA es parte de Spring Framework. Es un m\u00f3dulo de Spring Data que sirve para simplificar el acceso a bases de datos relacionales usando JPA (Java Persistence API). Permite trabajar con bases de datos utlizando objetos (clases) sin tener que escribir SQL ni c\u00f3digo repetitivo. Con Spring Data JPA: Solo defines entidades (@Entity) Creas interfaces Repository Spring genera autom\u00e1ticamente el c\u00f3digo \ud83d\udd39Anotaciones JPA \u00b6 Categor\u00eda Anotaci\u00f3n Descripci\u00f3n Mapeo JPA @Entity Marca una clase como entidad JPA @Table Especifica el nombre de la tabla @Id Indica la clave primaria @GeneratedValue Define c\u00f3mo se genera la clave primaria @Column Configura una columna @JoinColumn Define la clave for\u00e1nea @Lob Campo de gran tama\u00f1o @Transient Excluye un campo del mapeo Relaciones JPA @ManyToOne Relaci\u00f3n muchos a uno @OneToMany Relaci\u00f3n uno a muchos @OneToOne Relaci\u00f3n uno a uno @ManyToMany Relaci\u00f3n muchos a muchos Spring Data JPA @Repository Marca una interfaz como repositorio Spring @Query Define una consulta personalizada (JPQL o SQL) @Param Par\u00e1metros nombrados en consultas @Modifying Consultas de actualizaci\u00f3n o borrado @EnableJpaRepositories Habilita repositorios JPA @EntityGraph Controla la carga de relaciones Transacciones @Transactional Ejecuta m\u00e9todos dentro de una transacci\u00f3n @Rollback Fuerza la reversi\u00f3n de la transacci\u00f3n (tests) Ejemplos @Entity - Marca una clase como una entidad JPA, mapeada a una tabla en la base de datos. @Entity data class User( @Id val id: Long, val name: String ) @Table - Especifica el nombre de la tabla que corresponde a la entidad. @Entity @Table(name = \"users\") data class User( @Id val id: Long, val name: String ) @Id - Indica que un campo es la clave primaria de la tabla. @Id val id: Long @GeneratedValue - Define c\u00f3mo se genera el valor de la clave primaria. Estrategias comunes: GenerationType.IDENTITY , GenerationType.SEQUENCE , etc. @Id @GeneratedValue(strategy = GenerationType.IDENTITY) val id: Long @Column - Configura una columna de la tabla, como nombre, si es nula o \u00fanica. @Column(name = \"user_name\", nullable = false, unique = true) val name: String @ManyToOne , @OneToMany , @OneToOne , @ManyToMany Define relaciones entre entidades. @ManyToOne val department: Department @JoinColumn - Especifica la columna que act\u00faa como clave for\u00e1nea. @ManyToOne @JoinColumn(name = \"department_id\") val department: Department @Lob - Indica que un campo es un objeto grande (texto o binario). @Lob val description: String @Transient - Excluye un campo del mapeo de base de datos (no se almacena). @Transient val calculatedField: String @Repository - Marca una interfaz o clase como repositorio Spring. El data class representa la entidad (tabla), mientras que el @Repository se encarga de las operaciones de acceso a datos sobre esa entidad. @Repository interface UserRepository : JpaRepository<User, Long> @Query - Define una consulta personalizada usando JPQL o SQL nativo. Ejemplo (JPQL): @Query(\"SELECT u FROM User u WHERE u.name = :name\") fun findByName(@Param(\"name\") name: String): List<User> Ejemplo (SQL nativo): @Query(value = \"SELECT * FROM users WHERE user_name = :name\", nativeQuery = true) fun findByNameNative(@Param(\"name\") name: String): List<User> @Param - Define par\u00e1metros nombrados para consultas con @Query . @Query(\"SELECT u FROM User u WHERE u.name = :name\") fun findByName(@Param(\"name\") name: String): List<User> @Modifying - Se utiliza con consultas @Query para operaciones de actualizaci\u00f3n o eliminaci\u00f3n. @Modifying @Query(\"UPDATE User u SET u.name = :name WHERE u.id = :id\") fun updateName(@Param(\"id\") id: Long, @Param(\"name\") name: String) @EnableJpaRepositories - Habilita la funcionalidad de Spring Data JPA y escanea paquetes para detectar repositorios. @EnableJpaRepositories(basePackages = [\"com.example.repository\"]) @EntityGraph - Especifica c\u00f3mo cargar las relaciones en una consulta, evitando lazy loading. @EntityGraph(attributePaths = [\"roles\"]) fun findByName(name: String): User @Transactional - Marca un m\u00e9todo o clase para ejecutar dentro de una transacci\u00f3n. @Transactional fun updateUserDetails(user: User) { ... } @Rollback - Utilizada en pruebas para forzar la reversi\u00f3n de una transacci\u00f3n. @Transactional @Rollback fun testSaveUser() { ... } \ud83d\udd39Consultas \u00b6 Las consultas a la Base de datos las podemos hacer de dos maneras, utilizando la convenci\u00f3n de nombres en funciones de Spring Data JPA o con la anotaci\u00f3n @Query . \u2714\ufe0f La convenci\u00f3n de nombres se utiliza: En consultas sencillas y que no requieren l\u00f3gica compleja ni m\u00faltiples combinaciones. Cuando quieres mantener un c\u00f3digo m\u00e1s limpio y directo. \u2714\ufe0f La anotaci\u00f3n @Query se utiliza: En consultas complejas que involucren m\u00faltiples tablas, condiciones avanzadas o subconsultas. Si prefieres optimizar manualmente las consultas. Cuando la convenci\u00f3n de nombres generar\u00eda un nombre de m\u00e9todo excesivamente largo. Convenci\u00f3n de Nombres Spring Data JPA permite definir m\u00e9todos en repositorios siguiendo una convenci\u00f3n de nombres espec\u00edfica. Esto simplifica la escritura de consultas comunes sin necesidad de usar JPQL o SQL. Para ello analiza el nombre de los m\u00e9todos en el repositorio e interpreta su significado para generar consultas autom\u00e1ticamente. La estructura b\u00e1sica es: findBy + NombreDeCampo + Condici\u00f3n 1) findBy : Indica que se busca una entidad en la base de datos. Alternativas: readBy (lectura de datos) queryBy (consulta de datos) getBy (obtener datos) 2) NombreDeCampo : Debe coincidir exactamente con el nombre del atributo en la entidad. Se puede incluir navegaci\u00f3n de atributos para relaciones (EntidadRelacionada.Atributo). 3) Condici\u00f3n (opcional): Permite a\u00f1adir operadores l\u00f3gicos como And, Or, etc. Ejemplo: findByNombreAndEdad. Ejemplos de m\u00e9todos seg\u00fan la convenci\u00f3n Consultas simples M\u00e9todo: findByNombre(String nombre) Consulta generada: SELECT * FROM entidad WHERE nombre = ? Consultas con condiciones M\u00e9todo: findByNombreAndEdad(String nombre, Integer edad) Consulta generada: SELECT * FROM entidad WHERE nombre = ? AND edad = ? Consultas con orden M\u00e9todo: findByNombreOrderByEdadDesc(String nombre) Consulta generada: SELECT * FROM entidad WHERE nombre = ? ORDER BY edad DESC Consultas con relaciones. Si hay una relaci\u00f3n entre entidades, se puede navegar por los campos relacionados: M\u00e9todo: findByComarcaNomC(String nomC) Consulta generada: SELECT * FROM entidad e JOIN comarca c ON e.comarca_id = c.id WHERE c.nomC = ? Palabras clave en la convenci\u00f3n A tener en cuenta Coincidencia exacta del nombre del campo : Los nombres deben coincidir con los atributos definidos en la entidad. Relaciones : Usa la notaci\u00f3n EntidadRelacionada.Atributo para navegar entre tablas relacionadas. Orden : Los m\u00e9todos pueden incluir palabras clave de ordenaci\u00f3n, como OrderBy . Par\u00e1metros : Los m\u00e9todos generados reciben par\u00e1metros en el mismo orden en que se declaran en el nombre del m\u00e9todo. \ud83d\udd39 @Query Estructura b\u00e1sica: @Query(\"SELECT e FROM EntityName e WHERE e.property = :value\") fun findByProperty(@Param(\"value\") value: String): List<EntityName> Se utilizan nombres de entidades y propiedades de las clases en lugar de nombres de tablas y columnas. Se puede navegar por relaciones entre entidades. :nombreParametro para par\u00e1metros din\u00e1micos. Ejemplo sencillo: @Query(\"SELECT c FROM Comarca c WHERE c.provincia = :provincia\") fun findByProvincia(@Param(\"provincia\") provincia: String): List<Comarca> Ejemplo con relaciones: Siguiendo con nuestro ejemplo de geo_ad, la consulta para buscar Institutos en una Provincia por Poblaci\u00f3n M\u00ednima quedar\u00eda as\u00ed: @Query(\"\"\" SELECT i FROM Institut i JOIN i.poblacio p JOIN p.comarca c WHERE c.provincia = :provincia AND p.poblacion >= :minPoblacion \"\"\") fun findByProvinciaAndPoblacion( @Param(\"provincia\") provincia: String, @Param(\"minPoblacion\") minPoblacion: Int ): List<Institut> Este mismo ejemplo utilizando convenci\u00f3n de nombres quedar\u00eda as\u00ed: @Repository interface InstitutRepository : JpaRepository<Institut, String> { fun findByPoblacioComarcaProvinciaAndPoblacioPoblacionGreaterThanEqual( provincia: String, minPoblacion: Int ): List<Institut> } findBy : Indica que es un m\u00e9todo de consulta. PoblacioComarcaProvincia : Navega por las relaciones de las entidades Institut Poblacio -> Comarca para filtrar por la provincia. AndPoblacioPoblacionGreaterThanEqual : Navega por Institut -> Poblacio y aplica el filtro de poblaci\u00f3n m\u00ednima. Conclusi\u00f3n A medida que las relaciones aumentan en complejidad, los nombres de los m\u00e9todos pueden volverse dif\u00edciles de leer y mantener. \ud83d\udd39 Ejemplo con Postgres (Entidad) \u00b6 En este ejemplo vamos a crear una aplicaci\u00f3n sencilla que acceda a una base de datos Postgres. Para ello utilizaremos la base de datos geo_ad , que ya conocemos de temas anteriores, y que se encuentra en el servidor externo 89.36.214.106 . La aplicaci\u00f3n simplemente mostrar\u00e1 la informaci\u00f3n de la tabla comarcas . Para esta aplicaci\u00f3n crearemos un nuevo proyecto, con la misma configuraci\u00f3n que el anterior, pero a\u00f1adiremos las dependencias necesarias de acceso a la Base de Datos. Configurar el proyecto 1) Creamos el proyecto y lo configuramos desde File-->New-->Project : Elige Spring Boot . Configura las siguientes opciones: Language: Kotlin Build System: Maven Especifica un nombre para el proyecto: PrimerSpringMVC \u00daltima versi\u00f3n de JDK \u00daltima versi\u00f3n de Java 2) Posteriormente seleccionamos las dependencias necesarias: Note Como la aplicaci\u00f3n accede a una Base de datos, necesitaremos las dependencias adicionales Spring Data JPA y PostgreSQL Driver . Spring Web (para el desarrollo de aplicaciones web) Thymeleaf (motor de plantillas para la vista) Spring Boot DevTools (opcional, para facilitar el desarrollo) Spring Data JPA (facilita la integraci\u00f3n de aplicaciones Spring con bases de datos relacionales utilizando el marco JPA (Java Persistence API)) PostgresSQL Driver (proporciona el controlador JDBC para conectarse a bases de datos PostgreSQL.) Despu\u00e9s de aceptar, y si todo ha ido correctamente, ya tendremos nuestro proyecto creado y preparado para a\u00f1adir los elementos de programaci\u00f3n. Al iniciar nuestra aplicaci\u00f3n, lo primero que observamos es que se crea una clase SpringJpaApplication que sirve como contenedor para la configuraci\u00f3n de la aplicaci\u00f3n. No necesita implementar m\u00e9todos adicionales, ya que Spring Boot se encarga de todo gracias a la anotaci\u00f3n @SpringBootApplication . Crear la estructura del Proyecto La estructura b\u00e1sica del proyecto debe reflejar el patr\u00f3n MVC. Organiza las carpetas de la siguiente forma: Controladores : src/main/kotlin/org/tuapp/controller Vistas : src/main/resources/templates Recursos est\u00e1ticos : src/main/resources/static Datos : src/main/kotlin/org/tuapp/model Repositorio : src/main/kotlin/org/tuapp/repository Para ello crea los paquetes: controller , model y repository dentro de la carpeta src/main/kotlin/org/tuapp . Implementaci\u00f3n de la aplicaci\u00f3n Ahora ya podemos a\u00f1adir la programaci\u00f3n necesaria para nuestra aplicaci\u00f3n siguiendo la estructura MVC creada. Dentro de cada paquete crearemos los siguientes archivos: Entidad JPA Define las entidades que corresponden a las tablas existentes en la base de datos. No necesitas configuraciones especiales m\u00e1s all\u00e1 de mapear las columnas. En nuestro caso definimos la entidad comarca y sus campos. En el paquete model crea un archivo llamado comarca.kt package org.example.springjpa.model import jakarta.persistence.* @Entity @Table(name = \"comarca\") class Comarca( @Id @Column(name = \"nom_c\") var nomC: String = \"\", @Column(name = \"provincia\") var provincia: String? = null ) Repositorio Crea un repositorio que permita ejecutar consultas sobre la tabla correspondiente. Dentro del paquete repository , crea un archivo llamado ComarcaRepository.kt package org.example.springjpa.repository import org.example.springjpa.model.Comarca import org.springframework.data.jpa.repository.JpaRepository import org.springframework.stereotype.Repository interface ComarcaRepository : JpaRepository<Comarca, String> { fun findByProvincia(provincia: String): List<Comarca> } Controlador El controlador manejar\u00e1 las solicitudes GET para obtener informaci\u00f3n de la base de datos. Dentro del paquete controller , crea un archivo llamado ComarcaRestController.kt package org.example.springjpa.controller import org.example.springjpa.model.Comarca import org.example.springjpa.repository.ComarcaRepository import org.springframework.web.bind.annotation.* @RestController @RequestMapping(\"/api/comarcas\") class ComarcaController(private val comarcaRepository: ComarcaRepository) { // Endpoint para obtener todas las comarcas @GetMapping fun obtenerComarcas(): List<Comarca> = comarcaRepository.findAll() } @RestController: Combina @Controller y @ResponseBody . Devuelve directamente datos en formato JSON. ObtenerComarcas() : Devuelve una lista de objetos comarca. Spring autom\u00e1ticamente convierte esta lista a JSON usando Jackson (que viene incluido con Spring Boot). Vistas Las vistas pueden ser representadas por tecnolog\u00edas como JSP, Thymeleaf, o JSON (en caso de APIs). En Spring, tanto las vistas HTML como las respuestas JSON se generan autom\u00e1ticamente: las vistas se renderizan con Thymeleaf y los objetos se serializan a JSON sin configuraci\u00f3n adicional. En este ejemplo vamos a visualizar los datos en un navegador con formato JSON y m\u00e1s adelante lo haremos mediante Thymeleaf para ver ambos casos. Configurar la conexi\u00f3n al Servidor Postgres: En el archivo src/main/resources/application.properties configura la conexi\u00f3n a tu base de datos existente: spring.datasource.url=jdbc:postgresql://<HOST>:<PUERTO>/<DB_NAME> spring.datasource.username=<USUARIO> spring.datasource.password=<CONTRASE\u00d1A> spring.jpa.hibernate.ddl-auto=update Cambiaremos los datos de conexi\u00f3n al servidor externo: 89.36.214.106 spring.application.name=SpringJPA spring.datasource.url=jdbc:postgresql://89.36.214.106:5432/geo_ad spring.datasource.username=geo_ad spring.datasource.password=geo_ad Configuraci\u00f3n b\u00e1sica de JPA En una aplicaci\u00f3n Spring Boot con Spring Data JPA, es fundamental definir expl\u00edcitamente ciertos par\u00e1metros de configuraci\u00f3n en el archivo application.properties . Estas propiedades permiten controlar el comportamiento de Hibernate, evitar efectos no deseados sobre la base de datos y facilitar la comprensi\u00f3n del funcionamiento interno del framework. En el contexto de este proyecto, donde se trabaja con una base de datos PostgreSQL creada previamente, se establecen las siguientes propiedades con los siguientes objetivos: Garantizar que Spring no modifique el esquema de la base de datos, manteniendo el control sobre tablas, claves y relaciones. spring.jpa.hibernate.ddl-auto=none Visualizar las consultas SQL reales que Hibernate genera y ejecuta, con fines did\u00e1cticos y de depuraci\u00f3n. spring.jpa.show-sql=true Indicar expl\u00edcitamente el tipo de base de datos utilizada, asegurando que Hibernate emplea el dialecto y la sintaxis SQL correctos. spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect Por estos motivos, el archivo application.properties quedar\u00e1 finalmente as\u00ed: Ejecutar la aplicaci\u00f3n La aplicaci\u00f3n estar\u00e1 disponible en http://localhost:8080/api/comarcas , o el puerto que hayas especificado, para listar las comarcas. Ser\u00eda deseable que el resultado se mostrara de manera m\u00e1s amigable para el usuario, por lo que en el siguiente ejemplo haremos los cambios necesarios para utilizar Thymeleaf y que el resultado se muestre en cajas de texto. Thymeleaf para mostrar los resultados: 1) Configuraci\u00f3n de dependencias . Aseg\u00farate de tener la dependencia de Thymeleaf en tu archivo pom.xml . Esta dependencia la hemos seleccionado al configurar la aplicaci\u00f3n y seguramente ya la tengamos incluida. <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-thymeleaf</artifactId> </dependency> 2) Configurar Thymeleaf en application.properties A\u00f1ade las siguientes propiedades: spring.thymeleaf.prefix=classpath:/templates/ spring.thymeleaf.suffix=.html spring.thymeleaf.cache=false 3) Crear un nuevo Controlador . Cada controller debe tener rutas distintas, ya que devuelve HTML en lugar de JSON. ComarcaMvcController.kt package org.example.springjpa.controller import org.springframework.stereotype.Controller import org.springframework.ui.Model import org.example.springjpa.repository.ComarcaRepository import org.springframework.web.bind.annotation.* @Controller //en lugar de @RestController @RequestMapping(\"/comarcas\") class ComarcaControllerEntity(private val ComarcaRepository: ComarcaRepository) { @GetMapping fun listarComarcas(model:Model): String { val comarcas = ComarcaRepository.findAll() model.addAttribute(\"comarcas\", comarcas) return \"comarcas\" // Nombre de la plantilla HTML } } 4) Vistas Para agregar un entorno de usuario amigable con cajas de texto y que los datos de la base de datos se muestren en una aplicaci\u00f3n web, crea un archivo comarcas.html en el directorio src/main/resources/templates . <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Lista de Comarcas</title> </head> <body> <h1>Lista de Comarcas</h1> <table border=\"1\"> <tr> <th>ID</th> <th>Provincia</th> </tr> <tr th:each=\"comarca : ${comarcas}\"> <td th:text=\"${comarca.nomC}\">Nombre</td> <td th:text=\"${comarca.provincia}\">Provincia</td> </tr> </table> </body> </html> th:each : Itera sobre la lista de comarcas. th:text : Inserta din\u00e1micamente el valor de un campo en el HTML. Ejecuatar la aplicaci\u00f3n Accede a http://localhost:8080/comarcas para listar las comarcas. En el navegador, se mostrar\u00e1 una tabla HTML con las comarcas almacenadas en la base de datos. Los datos din\u00e1micos se renderizan usando Thymeleaf . Este enfoque permite crear interfaces web amigables y bien estructuradas. Consultas a la Base de datos Con la anotaci\u00f3n @Query en el repositorio, podemos realizar consultas personalizadas a la base de datos. A continuaci\u00f3n veremos los cambios que deber\u00edamos hacer en los ficheros para poder hacer una consulta con par\u00e1metros y visualizar los datos tanto en json com con thymeleaf: Cambios en los ficheros .kt: ComarcaRepository package org.example.springjpa.repository import org.springframework.data.jpa.repository.Query import org.springframework.data.repository.query.Param import org.example.springjpa.model.Comarca import org.springframework.data.jpa.repository.JpaRepository import org.springframework.stereotype.Repository @Repository interface ComarcaRepository : JpaRepository<Comarca, String> { @Query(\"SELECT c FROM Comarca c WHERE c.provincia = :provincia\") fun findComarcasporProvincia(@Param(\"provincia\") provincia: String): List<Comarca> } ComarcaRestController package org.example.springjpa.controller import org.example.springjpa.model.Comarca import org.example.springjpa.repository.ComarcaRepository import org.springframework.web.bind.annotation.* @RestController //en lugar de @Controller @RequestMapping(\"/api/comarcas\") class ComarcaController(private val ComarcaRepository: ComarcaRepository) { @GetMapping(\"/buscar\") fun BuscarComarcasporProvincia(@RequestParam provincia: String): List<Comarca> { return ComarcaRepository.findComarcasporProvincia(provincia) } } Anotaciones importantes @Query : Permite definir consultas SQL personalizadas directamente en el repositorio. La consulta SELECT c FROM Comarca c WHERE c.provincia = :provincia selecciona todas las comarcas donde la columna provincia coincide con el par\u00e1metro provincia. @Param : Vincula el par\u00e1metro de la consulta con el valor que se pasa desde el m\u00e9todo. En este caso, @Param(\"provincia\") conecta el par\u00e1metro provincia de la consulta SQL con el argumento del m\u00e9todo. @GetMapping y @RequestParam : Define un endpoint HTTP GET en el controlador. El par\u00e1metro provincia se obtiene de la URL. Por ejemplo, si queremos listar las comarcas de la provincia de Alacant, obtenemos: http://localhost:8080/comarcas/buscar?provincia=Alacant Visualizar la salida con Thymeleaf Si la visualizaci\u00f3n la queremos hacer con Thymeleaf los cambios a realizar se har\u00edan solo en ComarcaMvcController , ya que el formulaio comarcas.html se puede seguir utilizando si queremos mostrar los mismos campos: import org.springframework.stereotype.Controller import org.example.primerspringmvc.repository.ComarcaRepository import org.springframework.ui.Model import org.springframework.web.bind.annotation.* @Controller //en lugar de @RestController @RequestMapping(\"/comarcas\") class ComarcaController(private val ComarcaRepository: ComarcaRepository) { @GetMapping fun listarComarcas(model:Model): String { val comarcas = ComarcaRepository.findAll() model.addAttribute(\"comarcas\", comarcas) return \"comarcas\" // Nombre de la plantilla HTML } @GetMapping(\"/buscar\") fun buscarComarcasPorProvincia(@RequestParam provincia: String, model: Model): String { val comarcas= ComarcaRepository.findComarcasporProvincia(provincia) model.addAttribute(\"comarcas\", comarcas) return \"comarcas\" // Nombre de la plantilla HTML } } Y el resultado se ver\u00eda as\u00ed: \ud83d\udd39Postgres en Docker \u00b6 Para no tener que instalarnos un servidor Postgres en nuestro equipo, podemos tener nuestra base de datos en un contenedor Docker. En este caso, los cambios principales se centran en la configuraci\u00f3n de conexi\u00f3n en la aplicaci\u00f3n y en el despliegue del contenedor de PostgreSQL. Antes de acceder al contenedor tenemos que crearlo. En nuestro caso crearemos un contenedor Docker de Postgres y posteriormente restauraremos la base de datos geo_ad en dicho contenedor, para poder disponer de la misma configuracion y los mismos datos que en el servidor externo. Partimos del hecho que tenemos instalado Docker en nuesto equipo, en caso contario te dejo un peque\u00f1o tutorial de como instalarlo en el apartado Docker de esta unidad. Los pasos a seguir para crear dicho contendor son: 1. Ejecutar PostgreSQL en Docker Crea y ejecuta el contenedor de PostgreSQL: docker run --name postgres-container -e POSTGRES_USER=admin -e POSTGRES_PASSWORD=admin -e POSTGRES_DB=demo -p 5432:5432 -d postgres POSTGRES_USER: Usuario de la base de datos. POSTGRES_PASSWORD: Contrase\u00f1a del usuario. POSTGRES_DB: Nombre de la base de datos. -p 5432:5432: Mapea el puerto 5432 del contenedor al puerto 5432 de tu m\u00e1quina. Verifica que el contenedor est\u00e9 corriendo: docker ps (Opcional) Con\u00e9ctate al contenedor para verificar la base de datos, desde DBeaver , o desde el terminal: docker exec -it postgres-container psql -U admin -d demo 2. Restaurar la base de datos en el contenedor con DBeaver : Vamos a restaurar la base de datos geo_ad en la base de datos demo , que hemos creado con docker. Para ello os he dejado un archivo dump , en Aules , que contiene el backup de geo_ad. Lo siguiente ser\u00e1 restaurar este backup en demo , siguiendo esto pasos: Crear una nueva conexi\u00f3n en DBeaver al contenedor local: Host: localhost Puerto: 5432 Usuario y contrase\u00f1a: admin Base de datos: demo Restaurar el archivo de respaldo: Haz clic derecho en la base de datos en el contenedor \u2192 Herramientas > Restaurar (Restore). Archivo de respaldo : Selecciona el archivo de respaldo exportado, disponible en Aules. Pulsa Start y espera a que termine la restauraci\u00f3n. Una vez terminado selecciona cancelar para que no vuelva a realizar la restauraci\u00f3n. 3. Cambios en la Configuraci\u00f3n de la Aplicaci\u00f3n En el archivo application.properties , configura la conexi\u00f3n a PostgreSQL en el contenedor Docker. spring.datasource.url=jdbc:postgresql://localhost:5432/demo spring.datasource.username=admin spring.datasource.password=admin spring.jpa.hibernate.ddl-auto=none spring.jpa.show-sql=true spring.jpa.properties.hibernate.format_sql=true Todos los cambios que necesitas para ejecutar la aplicaci\u00f3n y que acceda a la base de datos que se encuentra en el contenedor son los anteriormente descritos. El resto de ficheros y estructura no se ver\u00e1 afectada. Una vez tenemos la base de datos restaurada con los datos de geo_ad ya podemos ejecutar la aplicaci\u00f3n y comprobar que los resultados son los mismos que si accedemos a la base de datos del servidor. \ud83d\udd39CRUD b\u00e1sico \u00b6 Siguiendo con el ejemplo del apartado anterior, que accede a una base de datos relacional Postgres en un contenedor Docker , en este apartado iremos m\u00e1s all\u00e1 y veremos como realizar operaciones CRUD , ya que ahora la base de datos est\u00e1 en local y podemos hacer todas las modificaciones que necesitemos. Como ejemplo, haremos modificaciones sobre la tabla comarcas . \ud83d\udc49El \u00fanico fichero a modificar ser\u00e1 el controlador , ya que Las operaciones CRUD son acciones, y las acciones se gestionan en el Controller. Tambien se crear\u00e1n nuevas vistas para visualizar los resultados con Thymeleaf : ComarcaMvcController.kt package org.example.springjpa.controller import org.example.springjpa.model.Comarca import org.springframework.stereotype.Controller import org.springframework.ui.Model import org.example.springjpa.repository.ComarcaRepository import org.springframework.web.bind.annotation.* @Controller //en lugar de @RestController @RequestMapping(\"/comarcas\") class ComarcaControllerEntity(private val ComarcaRepository: ComarcaRepository) { @GetMapping fun listarComarcas(model:Model): String { val comarcas = ComarcaRepository.findAll() model.addAttribute(\"comarcas\", comarcas) return \"comarcas\" // Nombre de la plantilla HTML } @GetMapping(\"/buscar\") fun buscarComarcasPorProvincia(@RequestParam provincia: String, model: Model): String { val comarcas= ComarcaRepository.findComarcasporProvincia(provincia) model.addAttribute(\"comarcas\", comarcas) return \"comarcas\" // Nombre de la plantilla HTML } @GetMapping(\"/nueva\") fun mostrarFormularioNuevaComarca(model: Model): String { model.addAttribute(\"comarca\", Comarca()) return \"nueva_comarca\" } @PostMapping(\"/nueva\") fun guardarComarca(@ModelAttribute comarca: Comarca): String { ComarcaRepository.save(comarca) return \"redirect:/comarcas\" } @GetMapping(\"/editar/{id}\") fun mostrarFormularioEditarComarca( @PathVariable id: String, model: Model ): String { val comarca = ComarcaRepository.findById(id) .orElseThrow { IllegalArgumentException(\"Comarca no encontrada: $id\") } model.addAttribute(\"comarca\", comarca) return \"editar_comarca\" } @PostMapping(\"/editar/{id}\") fun actualizarComarca( @PathVariable id: String, @ModelAttribute comarca: Comarca ): String { val comarcaExistente = ComarcaRepository.findById(id) .orElseThrow { IllegalArgumentException(\"Comarca no encontrada: $id\") } // Solo se actualizan los campos editables comarcaExistente.provincia = comarca.provincia ComarcaRepository.save(comarcaExistente) return \"redirect:/comarcas\" } @GetMapping(\"/eliminar/{id}\") fun eliminarComarca(@PathVariable id: String): String { if (!ComarcaRepository.existsById(id)) { throw IllegalArgumentException(\"Comarca no encontrada: $id\") } ComarcaRepository.deleteById(id) return \"redirect:/comarcas\" } } \ud83d\udc49Creamos las vistas que permiten gestionar las operaciones CRUD nueva_comarca.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <meta charset=\"UTF-8\"> <title>Nueva Comarca</title> </head> <body> <h1>Nueva Comarca</h1> <form th:action=\"@{/comarcas/nueva}\" th:object=\"${comarca}\" method=\"post\"> <label for=\"nomC\">Nombre:</label> <input type=\"text\" th:field=\"*{nomC}\" required> <br> <label for=\"provincia\">Provincia:</label> <input type=\"text\" th:field=\"*{provincia}\" required> <br> <button type=\"submit\">Guardar</button> </form> </body> </html> editar_comarca.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <meta charset=\"UTF-8\"> <title>Editar Comarca</title> </head> <body> <h1>Editar Comarca</h1> <form th:action=\"@{/comarcas/editar/{id}(id=${comarca.nomC})}\" th:object=\"${comarca}\" method=\"post\"> <label for=\"nomC\">Nombre:</label> <input type=\"text\" th:field=\"*{nomC}\" readonly> <br> <label for=\"provincia\">Provincia:</label> <input type=\"text\" th:field=\"*{provincia}\" required> <br> <button type=\"submit\">Actualizar</button> </form> </body> </html> eliminar_comarca.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <meta charset=\"UTF-8\"> <title>Eliminar Comarca</title> </head> <body> <h1>Eliminar Comarca</h1> <p>\u00bfEst\u00e1s seguro de que deseas eliminar la siguiente comarca?</p> <ul> <li><strong>Nombre:</strong> <span th:text=\"${comarca.nomC}\">Nombre</span></li> <li><strong>Provincia:</strong> <span th:text=\"${comarca.provincia}\">Provincia</span></li> </ul> <form th:action=\"@{/comarcas/eliminar/{id}(id=${comarca.nomC})}\" method=\"post\"> <button type=\"submit\">S\u00ed, eliminar</button> <a th:href=\"@{/comarcas}\">Cancelar</a> </form> </body> </html> \ud83d\udc49Modificamos la vista comarcas.html que muestra todas las comarcas y permite acceder al resto de operaciones del CRUD. <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Lista de Comarcas</title> </head> <body> <h1>Lista de Comarcas</h1> <table border=\"1\"> <tr> <th>Nombre</th> <th>Provincia</th> <th>Acciones</th> </tr> <tr th:each=\"comarca : ${comarcas}\"> <td th:text=\"${comarca.nomC}\">Nombre</td> <td th:text=\"${comarca.provincia}\">Provincia</td> <td> <a th:href=\"@{/comarcas/editar/{id}(id=${comarca.nomC})}\">Editar</a> <a th:href=\"@{/comarcas/eliminar/{id}(id=${comarca.nomC})}\">Eliminar</a> </td> </tr> </table> </body> </html> \ud83d\udc49El resultado ser\u00eda el siguiente: URL Captura http://localhost:8080/comarcas http://localhost:8080/comarcas/nueva http://localhost:8080/comarcas/editar/ComarcaNueva http://localhost:8080/comarcas/eliminar/ComarcaNueva \ud83d\udd39DTO (Data Transfer Object) \u00b6 Hasta ahora, los ejemplos mostraban c\u00f3mo devolver directamente las entidades desde el controlador. Aunque esto funciona, no es una buena pr\u00e1ctica en aplicaciones reales, ya que expone el modelo de la base de datos y puede provocar problemas de seguridad y mantenimiento. En este ejemplo se introduce el uso de DTO (Data Transfer Object) para separar las entidades JPA de los datos que se env\u00edan al cliente. Hasta ahora hemos visto que el Controller llama directamente al Repository . Al introducir DTO, se a\u00f1ade la capa Service porque ahora tenemos una nueva responsabilidad. En resumen, el repositorio sigue trabajando con entidades, el servicio transforma esas entidades en DTO y el controlador devuelve los DTO al cliente. Hasta ahora el Controller Con Service + DTO , el objetivo es - Accede directamente al Repository - El controller solo gestiona peticiones y vistas - Trabaja con entidades JPA - La l\u00f3gica de negocio y transformaci\u00f3n va al Service - Decide qu\u00e9 datos se muestran en la vista BD \u2192 Entity \u2192 Repository \u2192 Controller \u2192 Vista BD \u2192 Entity \u2192 Repository \u2192 Service \u2192 DTO \u2192 Controller \u2192 Vista Cu\u00e1ndo utilizar DTO en las operaciones CRUD Los DTO se utilizan para leer y comunicar datos, no para persistirlos: Operaci\u00f3n Uso de DTO Explicaci\u00f3n \u2795 CREATE \u26a0\ufe0f A veces Normalmente se puede usar directamente la entidad . El DTO solo es necesario si el formulario no coincide con la entidad. \ud83d\udd0d READ \u2705 S\u00ed Al listar o mostrar datos es recomendable usar DTO , ya que los datos salen de la aplicaci\u00f3n hacia el exterior. \u270f\ufe0f UPDATE \u26a0\ufe0f A veces Se utiliza DTO cuando no queremos permitir modificar todos los campos de la entidad. \ud83d\uddd1\ufe0f DELETE \u274c No No se usa DTO, ya que \u00fanicamente se env\u00eda el identificador del objeto a eliminar. Cambios que se introducen en cada capa \ud83d\udc49 Paquetes que NO cambian al usar DTO model \u2192 Las entidades JPA (@Entity) siguen siendo las mismas. repository \u2192 Contin\u00faa trabajando con entidades y Spring Data JPA. \ud83d\udc49 Paquetes que S\u00cd cambian al usar DTO dto (nuevo paquete) \u2192 No depende de JPA y No tiene anotaciones ComarcaDTO.kt package org.example.springjpa.dto data class ComarcaDTO( val nomC: String, //Cambiamos nom_c \u2192 nomC (m\u00e1s claro para la API) val provincia: String? ) service (nuevo paquete) \u2192 Aqu\u00ed es donde introducimos DTO correctamente. ComarcaService.kt package org.example.springjpa.service import org.example.springjpa.dto.ComarcaDTO import org.example.springjpa.repository.ComarcaRepository import org.springframework.stereotype.Service @Service class ComarcaService( private val comarcaRepository: ComarcaRepository //inyecta el Repository ) { /** * Devuelve el listado completo de comarcas. * Se define en la capa Service para separar la l\u00f3gica de negocio * del controller y devolver los datos ya transformados en DTO, * evitando que la vista trabaje directamente con entidades. */ fun obtenerComarcas(): List<ComarcaDTO> { //los datos van a salir hacia la vista return comarcaRepository.findAll() .map { comarca -> //Se usa map para transformar cada entidad en un DTO ComarcaDTO( //Se seleccionan solo los campos necesarios nomC = comarca.nomC, //Se pueden renombrar campos provincia = comarca.provincia ) } } // M\u00e9todo espec\u00edfico para buscar comarcas por provincia. //Se define para que el controller no acceda al repository // y para centralizar la conversi\u00f3n Entity \u2192 DTO. fun obtenerComarcasPorProvincia(provincia: String): List<ComarcaDTO> { return comarcaRepository.findByProvincia(provincia) .map { ComarcaDTO( nomC = it.nomC, provincia = it.provincia ?: \"\" ) } } } controller \u2192 Cambiamo sel conrolador. Ahora devuelve DTO ComarcaRestController.kt package org.example.springjpa.controller import org.example.springjpa.dto.ComarcaDTO import org.example.springjpa.service.ComarcaService import org.springframework.web.bind.annotation.* @RestController @RequestMapping(\"/api/comarcas\") class ComarcaController( private val comarcaService: ComarcaService ) { // Listado general @GetMapping fun obtenerComarcas(): List<ComarcaDTO> = comarcaService.obtenerComarcas() // B\u00fasqueda por provincia @GetMapping(\"/buscar\") fun obtenerComarcasPorProvincia( @RequestParam provincia: String ): List<ComarcaDTO> = comarcaService.obtenerComarcasPorProvincia(provincia) } El DTO no afecta a c\u00f3mo se accede a la aplicaci\u00f3n, sino a qu\u00e9 informaci\u00f3n se devuelve y c\u00f3mo se presenta. \ud83d\udd39Ampliaci\u00f3n (BD completa) \u00b6 Para practicar la funcionalidad de Spring Data JPA vamos a seguir con el ejemplo SpringJPA . Recordemos que la aplicaci\u00f3n accede a la base de datos local en Docker . En este ejemplo vamos a mapear las 3 tablas de la base de datos: comarca, poblacio e institut y a realizar los cambios necesarios para crear algunas consultas y operaciones CRUD. Utilizaremos Thymeleaf para mostrar los resultados. Entidad Comarca . Ya la ten\u00edamos creada en el ejemplo anterior. import jakarta.persistence.* @Entity @Table(name = \"comarca\") data class comarca( @Id @Column(name = \"nom_c\") val nomC: String = \"\", @Column(name = \"provincia\") val provincia: String? = null ) Entidad Poblacio import jakarta.persistence.* @Entity @Table(name = \"poblacio\") class poblacio( @Id @Column(name = \"cod_m\") val codM: Int = 0, @Column(name = \"nom\") val nom: String = \"\", @Column(name = \"poblacio\") val poblacio: Int? = null, @Column(name = \"extensio\") val extensio: Double? = null, @Column(name = \"altura\") val altura: Int? = null, @Column(name = \"longitud\") val longitud: String? = null, @Column(name = \"latitud\") val latitud: String? = null, @Column(name = \"llengua\") val llengua: String? = null, @ManyToOne //clave ajena a comarca @JoinColumn(name = \"nom_c\", referencedColumnName = \"nom_c\") val comarca: Comarca? = null ) Entidad Institut import jakarta.persistence.* @Entity @Table(name = \"institut\") data class institut( @Id @Column(name = \"codi\") val codi: String = \"\", @Column(name = \"adreca\") val adreca: String? = null, @Column(name = \"codpostal\") val codPostal: Int? = null, @Column(name = \"nom\") val nom: String? = null, @Column(name = \"numero\") val numero: String? = null, @ManyToOne //clave ajena a poblacio @JoinColumn(name = \"cod_m\", referencedColumnName = \"cod_m\") val poblacio: poblacio? = null ) Repositorio para Comarca: ComarcaRepository . package org.example.springjpa.repository import org.springframework.data.jpa.repository.Query import org.springframework.data.repository.query.Param import org.example.springjpa.model.Comarca import org.springframework.data.jpa.repository.JpaRepository import org.springframework.stereotype.Repository @Repository interface ComarcaRepository : JpaRepository<Comarca, String> { @Query(\"SELECT c FROM Comarca c WHERE c.provincia = :provincia\") fun findComarcasporProvincia(@Param(\"provincia\") provincia: String): List<Comarca> fun findByProvincia(provincia: String): List<Comarca> } Repositorio para Institut: InstitutRepository package org.example.primerspringmvc.repository import org.example.primerspringmvc.model.institut import org.springframework.data.jpa.repository.JpaRepository interface InstitutRepository : JpaRepository<institut, String> { // Obtener institutos de una poblaci\u00f3n fun findByPoblacioNom(nom: String): List<institut> // Obtener institutos de una comarca fun findByPoblacioComarcaNomC(nomC: String): List<institut> // Obtener institutos de una provincia fun findByPoblacioComarcaProvincia(provincia: String): List<institut> // Obtener institutos cuya poblaci\u00f3n es mayor a fun findByPoblacioPoblacioGreaterThan(poblacio: Int): List<institut> } Repositorio para Poblacio: PoblacioRepository import org.example.primerspringmvc.model.poblacio import org.springframework.data.jpa.repository.JpaRepository interface PoblacioRepository : JpaRepository<poblacio, String> { // Obtener poblaciones de una comarca fun findByComarcaNomC(nomC: String): List<poblacio> // Obtener poblaciones de una provincia fun findByComarcaProvincia(provincia: String): List<poblacio> } Controlador para Institut: InstitutMvcController package org.example.springjpa.controller import org.example.springjpa.repository.InstitutRepository import org.springframework.stereotype.Controller import org.springframework.ui.Model import org.springframework.web.bind.annotation.* @Controller @RequestMapping(\"/instituts\") class InstitutController(private val institutRepository: InstitutRepository) { //Muestra todos los intitutos @GetMapping fun listarInstituts(model: Model): String { val instituts = institutRepository.findAll() model.addAttribute(\"instituts\", instituts) return \"instituts\" } // Muestra institutos de una poblaci\u00f3n @GetMapping(\"/por-poblacio\") fun obtenerInstitutsPoblacio(@RequestParam poblacio: String, model: Model): String { val institutsPoblacio = institutRepository.findByPoblacioNom(poblacio) model.addAttribute(\"instituts\", institutsPoblacio) return \"instituts\" // Plantilla para mostrar la lista de institutos } // Muestra institutos de una comarca @GetMapping(\"/por-comarca\") fun obtenerInstitutsComarca(@RequestParam comarca: String, model: Model): String { val institutsComarca = institutRepository.findByPoblacioComarcaNomC(comarca) model.addAttribute(\"instituts\", institutsComarca) return \"instituts\" // Plantilla para mostrar la lista de institutos } // Muestra institutos de una provincia @GetMapping(\"/por-provincia\") fun obtenerInstitutsProvincia(@RequestParam provincia: String, model: Model): String { val institutsProvincia = institutRepository.findByPoblacioComarcaProvincia(provincia) model.addAttribute(\"instituts\", institutsProvincia) return \"instituts\" // Plantilla para mostrar la lista de institutos } // Muestra institutos con poblaci\u00f3n superior a un valor @GetMapping(\"/poblacion-superior\") fun obtenerInstitutsPoblacionSuperior(@RequestParam poblacio: Int, model: Model): String { val institutsConPoblacionSuperiorA = institutRepository.findByPoblacioPoblacioGreaterThan(poblacio) model.addAttribute(\"instituts\", institutsConPoblacionSuperiorA) return \"instituts\" // Plantilla para mostrar la lista de institutos } } Controlador para Poblacio: PoblacioMvcController package org.example.springjpa.controller import org.example.springjpa.repository.PoblacioRepository import org.springframework.stereotype.Controller import org.springframework.ui.Model import org.springframework.web.bind.annotation.* @Controller @RequestMapping(\"/poblacions\") class PoblacioController(private val poblacioRepository: PoblacioRepository) { // Muestra todas las poblaciones @GetMapping fun listarTodasPoblacions(model: Model): String { val poblacions = poblacioRepository.findAll() model.addAttribute(\"poblacions\", poblacions) return \"poblacions\" // Vista Thymeleaf para mostrar todas las poblaciones } // Muestra las poblaciones por comarca @GetMapping(\"/por-comarca\") fun listarPoblacionsPorComarca(@RequestParam comarca: String, model: Model): String { val poblacions = poblacioRepository.findByComarcaNomC(comarca) model.addAttribute(\"poblacions\", poblacions) return \"poblacions\" // Vista Thymeleaf para mostrar las poblaciones por comarca } @GetMapping(\"/por-provincia\") fun listarPoblacionsPorProvincia(@RequestParam provincia: String, model: Model): String { val poblacions = poblacioRepository.findByComarcaProvincia(provincia) model.addAttribute(\"poblacions\", poblacions) return \"poblacions\" // Vista Thymeleaf para mostrar las poblaciones por comarca } } Vista instituts.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Instituts</title> </head> <body> <h1>Llista d'Instituts</h1> <table border=\"1\"> <tr> <th>Codi</th> <th>Nom</th> <th>Adre\u00e7a</th> <th>Poblaci\u00f3</th> <th>Habitants</th> <th>Comarca</th> <th>Provincia</th> </tr> <tr th:each=\"institut : ${instituts}\"> <td th:text=\"${institut.codi}\">Codi</td> <td th:text=\"${institut.nom}\">Nom</td> <td th:text=\"${institut.adreca}\">Adre\u00e7a</td> <td th:text=\"${institut.poblacio?.nom}\">Poblaci\u00f3</td> <td th:text=\"${institut.poblacio?.poblacio}\">Habitants</td> <td th:text=\"${institut.poblacio?.comarca?.nomC}\">Comarca</td> <td th:text=\"${institut.poblacio?.comarca?.provincia}\">Provincia</td> </tr> </table> </body> </html> Vista poblacions.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Poblacions</title> </head> <body> <h1>Llista de Poblacions per Comarca</h1> <table border=\"1\"> <tr> <th>Codi</th> <th>Nom</th> <th>Comarca</th> <th>Provincia</th> </tr> <tr th:each=\"poblacio : ${poblacions}\"> <td th:text=\"${poblacio.codM}\">Codi</td> <td th:text=\"${poblacio.nom}\">Nom</td> <td th:text=\"${poblacio.comarca?.nomC}\">Comarca</td> <td th:text=\"${poblacio.comarca?.provincia}\">Provincia</td> </tr> </table> </body> </html> Con esta configuraci\u00f3n podemos listar los siguientes ejemplos : Todos los institutos: http://localhost:8080/instituts Todas las poblaciones: http://localhost:8080/poblacions Todas las comarcas: http://localhost:8080/comarcas Listar institutos de una poblaci\u00f3n: http://localhost:8080/instituts/por-poblacio?poblacio=Gandia Listar institutos de una comarca: http://localhost:8080/instituts/por-comarca?comarca=Safor Listar institutos de una provincia: http://localhost:8080/instituts/por-provincia?provincia=Alacant Listar comarcas de una provincia: http://localhost:8080/comarcas/por-provincia?provincia=Alacant Listar poblaciones de una comarca http://localhost:8080/poblacions/por-comarca?comarca=Safor Listar poblaciones de una provincia: http://localhost:8080/poblacions/por-provincia?provincia=Alacant Listar institutos con poblaci\u00f3n superior a un valor: http://localhost:8080/instituts/poblacion-superior?poblacio=20000 Transformaci\u00f3n del ejemplo utilizando DTO Las entidades NO cambian Los repositorios NO cambian Se a\u00f1aden DTO + Service Los Controller pasan DTO a la vista En este ejemplo mostraremos los resultados en JSON y por tanto utilizaremos los controladores REST. \ud83d\udc49 Nuevo paquete dto package org.example.springjpa.dto data class ComarcaDTO( val nomC: String, val provincia: String? ) package org.example.springjpa.dto data class PoblacioDTO( val codM: Int, val nom: String, val poblacio: Int?, val comarcaNom: String ) package org.example.springjpa.dto data class InstitutDTO( val codi: String, val nom: String?, val adreca: String?, val poblacioNom: String, val comarcaNom: String, val provincia: String ) \ud83d\udc49 Nuevo paquete PoblacioService package org.example.springjpa.service import org.example.springjpa.dto.PoblacioDTO import org.example.springjpa.repository.PoblacioRepository import org.springframework.stereotype.Service @Service class PoblacioService( private val poblacioRepository: PoblacioRepository ) { fun obtenerPoblacionesPorComarca(nomC: String): List<PoblacioDTO> = poblacioRepository.findByComarcaNomC(nomC).map { PoblacioDTO( codM = it.codM, nom = it.nom, poblacio = it.poblacio, comarcaNom = it.comarca?.nomC ?: \"\" ) } } \ud83d\udc49 Nuevo paquete InstitutService package org.example.springjpa.service import org.example.springjpa.dto.InstitutDTO import org.example.springjpa.repository.InstitutRepository import org.springframework.stereotype.Service @Service class InstitutService( private val institutRepository: InstitutRepository ) { fun obtenerInstitutosPorProvincia(provincia: String): List<InstitutDTO> = institutRepository.findByPoblacioComarcaProvincia(provincia) .map { InstitutDTO( codi = it.codi, nom = it.nom, adreca = it.adreca, poblacioNom = it.poblacio?.nom ?: \"\", comarcaNom = it.poblacio?.comarca?.nomC ?: \"\", provincia = it.poblacio?.comarca?.provincia ?: \"\" ) } } \ud83d\udc49 Nuevo Paquete InstitutRestcontroller package org.example.springjpa.controller import org.example.springjpa.service.InstitutService import org.example.springjpa.dto.InstitutDTO import org.springframework.web.bind.annotation.* @RestController @RequestMapping(\"/api/instituts\") class InstitutRestController( private val institutService: InstitutService ) { @GetMapping(\"/provincia\") fun obtenirPerProvincia( @RequestParam provincia: String ): List<InstitutDTO> = institutService.obtenerInstitutosPorProvincia(provincia) } \ud83d\udc49 Nuevo Paquete PoblacioRestcontroller package org.example.springjpa.controller import org.example.springjpa.dto.PoblacioDTO import org.example.springjpa.service.PoblacioService import org.springframework.web.bind.annotation.* @RestController @RequestMapping(\"/api/poblacions\") class PoblacioRestController( private val poblacioService: PoblacioService ) { // Obtener poblaciones de una comarca @GetMapping(\"/comarca\") fun obtenirPerComarca( @RequestParam nomC: String ): List<PoblacioDTO> = poblacioService.obtenerPoblacionesPorComarca(nomC) } Listar las poblaciones de la Comarca del Ports: http://localhost:8080/api/poblacions/comarca?nomC=Ports Listar las poblaciones de la provincia de Val\u00e8ncia: http://localhost:8080/api/poblacions/provincia?provincia=Val%C3%A8ncia \ud83d\udd39Spring Data MongoDB \u00b6 El componente Spring MongoDB Es un m\u00f3dulo de Spring Data que facilita la integraci\u00f3n de aplicaciones Spring con MongoDB . Adem\u00e1s proporciona una abstracci\u00f3n sobre las operaciones b\u00e1sicas de MongoDB como CRUD, consultas personalizadas, y soporte para agregaciones. Requisitos Tener MongoDB instalado o utilizar una instancia en la nube o en un contenedor Docker. Spring Boot configurado con Maven (en nuestro caso) o Gradle. Dependencias Maven <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-data-mongodb</artifactId> </dependency> Configuraci\u00f3n de las propiedades application.properties spring.data.mongodb.host=localhost spring.data.mongodb.port=27017 spring.data.mongodb.database=nombre_base_de_datos Si est\u00e1s usando MongoDB con autenticaci\u00f3n, a\u00f1ade: spring.data.mongodb.username=usuario spring.data.mongodb.password=contrase\u00f1a \ud83d\udd39Anotaciones comunes \u00b6 Estas anotaciones permiten mapear documentos, gestionar colecciones y realizar operaciones de manera sencilla. Las principales anotaciones utilizadas en Spring Data MongoDB son: @Document Se utiliza para marcar una clase como un documento MongoDB que ser\u00e1 persistido en una colecci\u00f3n. @Document(collection = \"coleccion\") * collection : Especifica el nombre de la colecci\u00f3n. Si no se define, se usa el nombre de la clase en min\u00fasculas. @Id Marca un campo como identificador \u00fanico del documento. Este campo se mapea al campo _id en MongoDB. @Field Se utiliza para mapear un campo de la clase a un campo espec\u00edfico en el documento MongoDB. @Field(\"descripcion\") val descripcionProducto: String @Transient Indica que un campo no debe ser persistido en la base de datos. @Transient val temporal: String = \"No se guarda en MongoDB\" @DBRef Se utiliza para definir una relaci\u00f3n entre documentos, similar a una clave for\u00e1nea. El atributo se mapea a una referencia en MongoDB. @DBRef val categoria: Categoria @CompoundIndex Define \u00edndices compuestos en la colecci\u00f3n para optimizar consultas. @CompoundIndex(def = \"{'nombre': 1, 'precio': -1}\", unique = true) * def: Define los campos que forman el \u00edndice. * unique: Indica si el \u00edndice debe ser \u00fanico. \ud83d\udd39Aplicaci\u00f3n Spring Data MongoDB \u00b6 En este apartado del tema ya tenemos que saber como crear una aplicaic\u00f3n Spring Boot desde IntelliJ, solo necesitas saber las dependencias necesarias y las anotaciones para incorporar Spring Data MongoDB y poco m\u00e1s. El resto ya depende de lo que quieras construir con la base de datos. Para este ejemplo partiremos de un archivo json que contiene 10 men\u00fas con sus correspondientes platos. Has de a\u00f1adir este documento como una colecci\u00f3n a tu BD Mongo. Lo tienes disponible en la carpeta recursos y tambi\u00e9n lo puedes copiar directamente. Lo primero que debes hacer es insertar este archivo en tu MongoDB local, como una colecci\u00f3n (InsertMany) Archivo json con los menus: [ { \"_id\": \"1\", \"nombre\": \"Men\u00fa Mediterr\u00e1neo\", \"descripcion\": \"Un men\u00fa saludable inspirado en la dieta mediterr\u00e1nea.\", \"fecha\": \"2025-01-08\", \"platos\": [ { \"nombre\": \"Ensalada Griega\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Lechuga\", \"Tomate\", \"Pepino\", \"Aceitunas\", \"Queso Feta\"], \"precio\": 5.5 }, { \"nombre\": \"Moussaka\", \"categoria\": \"Principal\", \"ingredientes\": [\"Berenjena\", \"Carne de Cordero\", \"Tomate\", \"Bechamel\", \"Queso\"], \"precio\": 12.0 } ], \"precioTotal\": 17.5 }, { \"_id\": \"2\", \"nombre\": \"Men\u00fa Asi\u00e1tico\", \"descripcion\": \"Sabores frescos y aut\u00e9nticos de Asia.\", \"fecha\": \"2025-01-09\", \"platos\": [ { \"nombre\": \"Rollitos de Primavera\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Zanahoria\", \"Col\", \"Brotes de Soja\", \"Fideos de Arroz\"], \"precio\": 4.0 }, { \"nombre\": \"Pad Thai\", \"categoria\": \"Principal\", \"ingredientes\": [\"Fideos de Arroz\", \"Camarones\", \"Tofu\", \"Man\u00ed\"], \"precio\": 10.0 } ], \"precioTotal\": 14.0 }, { \"_id\": \"3\", \"nombre\": \"Men\u00fa Vegetariano\", \"descripcion\": \"Opciones deliciosas sin carne.\", \"fecha\": \"2025-01-10\", \"platos\": [ { \"nombre\": \"Hummus con Pan de Pita\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Garbanzos\", \"Tahini\", \"Lim\u00f3n\", \"Ajo\"], \"precio\": 4.5 }, { \"nombre\": \"Lasa\u00f1a Vegetariana\", \"categoria\": \"Principal\", \"ingredientes\": [\"Pasta\", \"Espinacas\", \"Ricotta\", \"Tomate\"], \"precio\": 9.0 } ], \"precioTotal\": 13.5 }, { \"_id\": \"4\", \"nombre\": \"Men\u00fa Italiano\", \"descripcion\": \"Especialidades cl\u00e1sicas de Italia.\", \"fecha\": \"2025-01-11\", \"platos\": [ { \"nombre\": \"Bruschetta\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Pan\", \"Tomate\", \"Albahaca\", \"Aceite de Oliva\"], \"precio\": 5.0 }, { \"nombre\": \"Pizza Margarita\", \"categoria\": \"Principal\", \"ingredientes\": [\"Masa de Pizza\", \"Tomate\", \"Mozzarella\", \"Albahaca\"], \"precio\": 10.0 } ], \"precioTotal\": 15.0 }, { \"_id\": \"5\", \"nombre\": \"Men\u00fa Mexicano\", \"descripcion\": \"Platos picantes y llenos de sabor.\", \"fecha\": \"2025-01-12\", \"platos\": [ { \"nombre\": \"Guacamole con Totopos\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Aguacate\", \"Lim\u00f3n\", \"Cilantro\", \"Totopos\"], \"precio\": 4.5 }, { \"nombre\": \"Tacos al Pastor\", \"categoria\": \"Principal\", \"ingredientes\": [\"Tortilla\", \"Carne de Cerdo\", \"Pi\u00f1a\", \"Cebolla\"], \"precio\": 9.0 } ], \"precioTotal\": 13.5 }, { \"_id\": \"6\", \"nombre\": \"Men\u00fa Americano\", \"descripcion\": \"Comida cl\u00e1sica de los Estados Unidos.\", \"fecha\": \"2025-01-13\", \"platos\": [ { \"nombre\": \"Alitas de Pollo\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Pollo\", \"Salsa BBQ\", \"Especias\"], \"precio\": 6.0 }, { \"nombre\": \"Hamburguesa con Queso\", \"categoria\": \"Principal\", \"ingredientes\": [\"Pan\", \"Carne de Res\", \"Queso\", \"Lechuga\"], \"precio\": 10.0 } ], \"precioTotal\": 16.0 }, { \"_id\": \"7\", \"nombre\": \"Men\u00fa de Mariscos\", \"descripcion\": \"Frescos sabores del oc\u00e9ano.\", \"fecha\": \"2025-01-14\", \"platos\": [ { \"nombre\": \"C\u00f3ctel de Camarones\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Camarones\", \"Salsa C\u00f3ctel\", \"Lim\u00f3n\"], \"precio\": 7.0 }, { \"nombre\": \"Paella de Mariscos\", \"categoria\": \"Principal\", \"ingredientes\": [\"Arroz\", \"Camarones\", \"Mejillones\", \"Calamares\"], \"precio\": 12.0 } ], \"precioTotal\": 19.0 }, { \"_id\": \"8\", \"nombre\": \"Men\u00fa Franc\u00e9s\", \"descripcion\": \"Platos refinados y elegantes.\", \"fecha\": \"2025-01-15\", \"platos\": [ { \"nombre\": \"Quiche Lorraine\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Huevo\", \"Nata\", \"Tocino\", \"Queso Gruy\u00e8re\"], \"precio\": 6.5 }, { \"nombre\": \"Ratatouille\", \"categoria\": \"Principal\", \"ingredientes\": [\"Berenjena\", \"Calabac\u00edn\", \"Tomate\", \"Pimiento\"], \"precio\": 9.5 } ], \"precioTotal\": 16.0 }, { \"_id\": \"9\", \"nombre\": \"Men\u00fa Indio\", \"descripcion\": \"Sabores especiados y ex\u00f3ticos.\", \"fecha\": \"2025-01-16\", \"platos\": [ { \"nombre\": \"Samosas\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Papas\", \"Especias\", \"Masa Frita\"], \"precio\": 4.0 }, { \"nombre\": \"Pollo Tikka Masala\", \"categoria\": \"Principal\", \"ingredientes\": [\"Pollo\", \"Salsa de Tomate\", \"Especias\", \"Crema\"], \"precio\": 11.0 } ], \"precioTotal\": 15.0 }, { \"_id\": \"10\", \"nombre\": \"Men\u00fa Japon\u00e9s\", \"descripcion\": \"Delicados sabores de Jap\u00f3n.\", \"fecha\": \"2025-01-17\", \"platos\": [ { \"nombre\": \"Sopa de Miso\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Miso\", \"Tofu\", \"Alga Wakame\"], \"precio\": 3.5 }, { \"nombre\": \"Sushi Variado\", \"categoria\": \"Principal\", \"ingredientes\": [\"Arroz\", \"Pescado\", \"Alga Nori\", \"Vegetales\"], \"precio\": 12.5 } ], \"precioTotal\": 16.0 } ] Modelo MVC Lo siguiente ser\u00e1 crear la estructura del modelo MVC con los archivos necesarios. En la siguiene imagen podeis ver como quedar\u00e1: Modelo Los modelos son las clases que representan las colecciones en MongoDB. Menu.kt import org.springframework.data.annotation.Id import org.springframework.data.mongodb.core.mapping.Document @Document(collection = \"menus\") // Nombre de la colecci\u00f3n en MongoDB data class Menu( @Id val id: String, // Identificador \u00fanico del men\u00fa val nombre: String, // Nombre del men\u00fa val descripcion: String, // Descripci\u00f3n del men\u00fa val fecha: String, // Fecha asociada al men\u00fa val platos: List<Plato> = emptyList(), // Lista de platos val precioTotal: Double = 0.0 // Precio total del men\u00fa ) data class Plato( val nombre: String, val categoria: String, val ingredientes: List<String> = emptyList(), val precio: Double = 0.0 ) Repositorios Proporciona una interfaz MongoRepository que simplifica las operaciones CRUD. MenuRepository.kt import org.springframework.data.mongodb.repository.MongoRepository import org.springframework.stereotype.Repository import org.example.primerspringmongo.model.* @Repository interface MenuRepository : MongoRepository<Menu, String> { fun findByNombre(nombre: String): List<Menu> fun findByPlatosCategoria(categoria: String): List<Menu> } Controlador Gestiona las solicitudes entrantes, procesa datos y determina las respuestas adecuadas. MenuController.kt import org.example.primerspringmongo.model.Menu import org.example.primerspringmongo.repository.MenuRepository import org.springframework.stereotype.Controller import org.springframework.ui.Model import org.springframework.web.bind.annotation.* @Controller @RequestMapping(\"/menus\") class MenuController(private val menuRepository: MenuRepository) { // Listar todos los men\u00fas @GetMapping fun listarMenus(model: Model): String { val menus = menuRepository.findAll() model.addAttribute(\"menus\", menus) return \"menus/listar\" } @GetMapping(\"/buscar\") fun buscarPorNombre(@RequestParam nombre: String, model: Model): String { val menus = menuRepository.findByNombre(nombre) // Consulta en el repositorio model.addAttribute(\"menus\", menus) // Pasar los men\u00fas al modelo model.addAttribute(\"nombre\", nombre) // Pasar el nombre buscado return \"menus/listar\" // Nombre de la plantilla Thymeleaf } // Guardar un nuevo men\u00fa @PostMapping(\"/guardar\") fun guardarMenu(@ModelAttribute menu: Menu): String { menuRepository.save(menu) return \"redirect:/menus\" } // Ver detalles de un men\u00fa @GetMapping(\"/{id}\") fun verDetalles(@PathVariable id: String, model: Model): String { val menu = menuRepository.findById(id) if (menu.isPresent) { model.addAttribute(\"menu\", menu.get()) return \"menus/detalles\" } return \"redirect:/menus\" } // Mostrar formulario para editar un men\u00fa @GetMapping(\"/editar/{id}\") fun mostrarFormularioEditar(@PathVariable id: String, model: Model): String { val menu = menuRepository.findById(id) if (menu.isPresent) { model.addAttribute(\"menu\", menu.get()) return \"menus/editar\" } return \"redirect:/menus\" } // Actualizar un men\u00fa existente @PostMapping(\"/actualizar/{id}\") fun actualizarMenu(@PathVariable id: String, @ModelAttribute menu: Menu): String { if (menuRepository.existsById(id)) { menuRepository.save(menu) } return \"redirect:/menus\" } // Eliminar un men\u00fa @GetMapping(\"/eliminar/{id}\") fun eliminarMenu(@PathVariable id: String): String { menuRepository.deleteById(id) return \"redirect:/menus\" } } PlatoController.kt import org.example.primerspringmongo.repository.MenuRepository import org.springframework.stereotype.Controller import org.springframework.ui.Model import org.springframework.web.bind.annotation.* @Controller @RequestMapping(\"/platos\") class PlatoController(private val menuRepository: MenuRepository) { // Listar todos los platos de un men\u00fa @GetMapping(\"/{menuId}\") fun listarPlatos(@PathVariable menuId: String, model: Model): String { val menu = menuRepository.findById(menuId) if (menu.isPresent) { model.addAttribute(\"menu\", menu.get()) model.addAttribute(\"platos\", menu.get().platos) return \"platos/listar\" } return \"redirect:/menus\" } @GetMapping(\"/categoria\") fun buscarPorCategoria(@RequestParam categoria: String, model: Model): String { val menus = menuRepository.findByPlatosCategoria(categoria) // Consulta en el repositorio model.addAttribute(\"menus\", menus) // Lista de men\u00fas encontrados model.addAttribute(\"categoriaBuscada\", categoria) // Categor\u00eda buscada return \"platos/buscarPorCategoria\" // Plantilla Thymeleaf } @GetMapping(\"/{menuId}/ingredientes/{platoNombre}\") fun verIngredientes( @PathVariable menuId: String, @PathVariable platoNombre: String, model: Model ): String { val menu = menuRepository.findById(menuId) if (menu.isPresent) { val plato = menu.get().platos.find { it.nombre == platoNombre } if (plato != null) { println(\"Plato encontrado: $plato\") println(\"Ingredientes: ${plato.ingredientes}\") model.addAttribute(\"menu\", menu.get()) model.addAttribute(\"plato\", plato) model.addAttribute(\"ingredientes\", plato.ingredientes ?: emptyList<String>()) return \"platos/ingredientes\" } } model.addAttribute(\"error\", \"El plato o el men\u00fa no existen.\") return \"error\" } } Vista Permiten visualizar los resultados con un formato personalizado. En la siguiente imagen ten\u00e9is la estructura de los archivos: Vistas para visualizar los menus: /menus listar.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Lista de Men\u00fas</title> </head> <body> <h1>Lista de Men\u00fas</h1> <a href=\"/menus/crear\">Crear Nuevo Men\u00fa</a> <table border=\"1\"> <thead> <tr> <th>Nombre</th> <th>Descripci\u00f3n</th> <th>Acciones</th> </tr> </thead> <tbody> <tr th:each=\"menu : ${menus}\"> <td th:text=\"${menu.nombre}\"></td> <td th:text=\"${menu.descripcion}\"></td> <td> <a th:href=\"@{'/menus/' + ${menu.id}}\">Detalles</a> <a th:href=\"@{'/menus/editar/' + ${menu.id}}\">Editar</a> <a th:href=\"@{'/menus/eliminar/' + ${menu.id}}\" onclick=\"return confirm('\u00bfSeguro que quieres eliminar este men\u00fa?')\">Eliminar</a> </td> </tr> </tbody> </table> </body> </html> crear.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Crear/Editar Men\u00fa</title> </head> <body> <h1 th:text=\"${#strings.equals(menu.id, '') ? 'Crear Nuevo Men\u00fa' : 'Editar Men\u00fa'}\"></h1> <form th:action=\"@{${#strings.equals(menu.id, '') ? '/menus/guardar' : '/menus/actualizar/' + menu.id}}\" th:object=\"${menu}\" method=\"post\"> <label for=\"nombre\">Nombre:</label> <input type=\"text\" id=\"nombre\" name=\"nombre\" th:value=\"${menu.nombre}\" required><br> <label for=\"descripcion\">Descripci\u00f3n:</label> <textarea id=\"descripcion\" name=\"descripcion\" th:text=\"${menu.descripcion}\" required></textarea><br> <label for=\"fecha\">Fecha:</label> <input type=\"date\" id=\"fecha\" name=\"fecha\" th:value=\"${menu.fecha}\" required><br> <label for=\"precioTotal\">Precio Total:</label> <input type=\"number\" id=\"precioTotal\" name=\"precioTotal\" th:value=\"${menu.precioTotal}\" step=\"0.01\" required><br> <button type=\"submit\">Guardar</button> <a href=\"/menus\">Cancelar</a> </form> </body> </html> detalles.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Detalles del Men\u00fa</title> </head> <body> <h1>Detalles del Men\u00fa</h1> <p><strong>Nombre:</strong> <span th:text=\"${menu.nombre}\"></span></p> <p><strong>Descripci\u00f3n:</strong> <span th:text=\"${menu.descripcion}\"></span></p> <p><strong>Fecha:</strong> <span th:text=\"${menu.fecha}\"></span></p> <p><strong>Precio Total:</strong> <span th:text=\"${menu.precioTotal}\"></span></p> <h2>Platos</h2> <ul> <li th:each=\"plato : ${menu.platos}\"> <strong th:text=\"${plato.nombre}\"></strong> - <span th:text=\"${plato.categoria}\"></span> (<span th:text=\"${plato.precio}\"></span> \u20ac) </li> </ul> <a href=\"/menus\">Volver</a> </body> </html> editar.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Crear/Editar Men\u00fa</title> </head> <body> <h1 th:text=\"${#strings.equals(menu.id, '') ? 'Crear Nuevo Men\u00fa' : 'Editar Men\u00fa'}\"></h1> <form th:action=\"@{${#strings.equals(menu.id, '') ? '/menus/guardar' : '/menus/actualizar/' + menu.id}}\" th:object=\"${menu}\" method=\"post\"> <label for=\"nombre\">Nombre:</label> <input type=\"text\" id=\"nombre\" name=\"nombre\" th:value=\"${menu.nombre}\" required><br> <label for=\"descripcion\">Descripci\u00f3n:</label> <textarea id=\"descripcion\" name=\"descripcion\" th:text=\"${menu.descripcion}\" required></textarea><br> <label for=\"fecha\">Fecha:</label> <input type=\"date\" id=\"fecha\" name=\"fecha\" th:value=\"${menu.fecha}\" required><br> <label for=\"precioTotal\">Precio Total:</label> <input type=\"number\" id=\"precioTotal\" name=\"precioTotal\" th:value=\"${menu.precioTotal}\" step=\"0.01\" required><br> <button type=\"submit\">Guardar</button> <a href=\"/menus\">Cancelar</a> </form> </body> </html> Vistas para visualizar los platos: /platos listar.kt <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Platos del Men\u00fa</title> </head> <body> <h1 th:text=\"'Platos del Men\u00fa: ' + ${menu.nombre}\"></h1> <a th:href=\"@{/menus}\">Volver a Men\u00fas</a> <table border=\"1\"> <thead> <tr> <th>Nombre</th> <th>Categor\u00eda</th> <th>Precio</th> <th>Ingredientes</th> </tr> </thead> <tbody> <tr th:each=\"plato : ${platos}\"> <td th:text=\"${plato.nombre}\"></td> <td th:text=\"${plato.categoria}\"></td> <td th:text=\"${plato.precio} + ' \u20ac'\"></td> <td> <a th:href=\"@{'/platos/' + ${menu.id} + '/ingredientes/' + ${plato.nombre}}\">Ver Ingredientes</a> </td> </tr> </tbody> </table> </body> </html> ingredientes.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Ingredientes</title> </head> <body> <h1 th:text=\"'Ingredientes del plato: ' + ${plato?.nombre}\"></h1> <div th:if=\"${error}\"> <p th:text=\"${error}\" style=\"color: red;\"></p> </div> <ul th:if=\"${ingredientes != null && !ingredientes.isEmpty()}\"> <li th:each=\"ingrediente : ${ingredientes}\" th:text=\"${ingrediente}\"></li> </ul> <p th:if=\"${ingredientes == null || ingredientes.isEmpty()}\" style=\"color: gray;\"> No hay ingredientes disponibles para este plato. </p> <a th:href=\"@{'/platos/' + ${menu.id}}\">Volver a los platos</a> </body> </html> buscarPorCategoria.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Buscar Men\u00fas por Categor\u00eda</title> </head> <body> <h1>Resultados para categor\u00eda: <span th:text=\"${categoriaBuscada}\"></span></h1> <table border=\"1\" th:if=\"${menus}\"> <thead> <tr> <th>ID</th> <th>Nombre</th> <th>Descripci\u00f3n</th> <th>Platos</th> </tr> </thead> <tbody> <tr th:each=\"menu : ${menus}\"> <td th:text=\"${menu.id}\"></td> <td th:text=\"${menu.nombre}\"></td> <td th:text=\"${menu.descripcion}\"></td> <td> <ul> <li th:each=\"plato : ${menu.platos}\" th:if=\"${plato.categoria == categoriaBuscada}\" th:text=\"${plato.nombre}\"></li> </ul> </td> </tr> </tbody> </table> <p th:if=\"${menus == null || menus.isEmpty()}\" style=\"color: gray;\"> No se encontraron men\u00fas con platos de la categor\u00eda <span th:text=\"${categoriaBuscada}\"></span>. </p> <a href=\"/menus\">Volver a la lista de men\u00fas</a> </body> </html> Con esta configuraci\u00f3n podemos listar los siguientes ejemplos: http://localhost:8888/menus : Lista todos los men\u00fas http://localhost:8888/menus/buscar?nombre=Men\u00fa Vegetariano: Busca un men\u00fa concreto. http://localhost:8888/platos/1: Lista los platos del men\u00fa 1. http://localhost:8888/platos/1/ingredientes/Ensalada Griega: Lista los ingredients del plato del men\u00fa 1. Nota Estos son alugunos ejemplos pero pod\u00e9is modificar el controlador y crear nuevas vistas para a\u00f1adir funcionalidad al programa y que muestre m\u00e1s resultados.","title":"\ud83d\udd39 Spring Data"},{"location":"SpringData/#spring-data","text":"Spring Data es un proyecto dentro del ecosistema Spring que proporciona herramientas y abstracciones para facilitar el acceso a bases de datos y otras fuentes de datos de manera eficiente y consistente . Su objetivo principal es simplificar la interacci\u00f3n con diferentes tipos de bases de datos , tanto relacionales (como PostgreSQL o MySQL) como NoSQL (por ejemplo MongoDB o Cassandra), reduciendo la cantidad de c\u00f3digo necesario y unificando la forma de trabajar con los datos . \u00bfPara qu\u00e9 se utiliza? 1\ufe0f\u20e3 Acceso Simplificado a Datos: Reduce la necesidad de escribir consultas SQL complejas o c\u00f3digo JDBC al exponer m\u00e9todos predefinidos para operaciones comunes. Permite realizar operaciones CRUD (Crear, Leer, Actualizar, Eliminar) con facilidad. 2\ufe0f\u20e3 Abstracci\u00f3n de Repositorios: Ofrece la interfaz Repository y subinterfaces como CrudRepository y JpaRepository que proporcionan m\u00e9todos est\u00e1ndar para la gesti\u00f3n de entidades en bases de datos relacionales. 3\ufe0f\u20e3 Consultas Personalizadas: Permite escribir consultas personalizadas mediante anotaciones como @Query . Tambi\u00e9n admite la creaci\u00f3n de m\u00e9todos de consulta basados en el nombre del m\u00e9todo, como findByNombre(String nombre) . 4\ufe0f\u20e3 Compatibilidad con M\u00faltiples Tecnolog\u00edas de Bases de Datos: Relacionales: Mediante JPA (Java Persistence API). NoSQL: MongoDB, Redis, Neo4j, Cassandra, etc. Buscadores: Elasticsearch, Solr. 5\ufe0f\u20e3 Configuraci\u00f3n Declarativa: Al integrar Spring Data con Spring Boot, se pueden configurar muchas opciones mediante propiedades en application.properties , evitando configuraciones manuales detalladas. 6\ufe0f\u20e3 Integraci\u00f3n con Spring Boot: Con dependencias espec\u00edficas como spring-boot-starter-data-jpa o spring-boot-starter-data-mongodb , Spring Data se integra perfectamente con el resto del ecosistema de Spring. Principales M\u00f3dulos de Spring Data En lugar de proporcionar una \u00fanica soluci\u00f3n, Spring Data est\u00e1 compuesto por varios m\u00f3dulos, cada uno dise\u00f1ado para un tipo concreto de tecnolog\u00eda de persistencia, como bases de datos relacionales, NoSQL o sistemas de b\u00fasqueda. Gracias a esta estructura modular, el desarrollador puede cambiar la tecnolog\u00eda de persistencia sin modificar la arquitectura general de la aplicaci\u00f3n. Spring Data JPA: : Proporciona una integraci\u00f3n con JPA para bases de datos relacionales. Es ideal para trabajar con entidades Java mapeadas a tablas de bases de datos. JPA es la especificaci\u00f3n para persistir, leer y gestionar data desde los objetos Java a la base de datos. Spring Data MongoDB: : Facilita el acceso a bases de datos MongoDB, una base de datos NoSQL orientada a documentos. Spring Data Redis: : Para aplicaciones que necesitan interactuar con Redis, una base de datos en memoria. Spring Data Cassandra: : Proporciona soporte para bases de datos distribuidas como Cassandra. Spring Data Elasticsearch: : Simplifica las interacciones con Elasticsearch, un motor de b\u00fasqueda y an\u00e1lisis.","title":"\ud83d\udd39Spring Data"},{"location":"SpringData/#spring-data-jpa","text":"Spring Data JPA es parte de Spring Framework. Es un m\u00f3dulo de Spring Data que sirve para simplificar el acceso a bases de datos relacionales usando JPA (Java Persistence API). Permite trabajar con bases de datos utlizando objetos (clases) sin tener que escribir SQL ni c\u00f3digo repetitivo. Con Spring Data JPA: Solo defines entidades (@Entity) Creas interfaces Repository Spring genera autom\u00e1ticamente el c\u00f3digo","title":"\ud83d\udd39Spring Data JPA"},{"location":"SpringData/#anotaciones-jpa","text":"Categor\u00eda Anotaci\u00f3n Descripci\u00f3n Mapeo JPA @Entity Marca una clase como entidad JPA @Table Especifica el nombre de la tabla @Id Indica la clave primaria @GeneratedValue Define c\u00f3mo se genera la clave primaria @Column Configura una columna @JoinColumn Define la clave for\u00e1nea @Lob Campo de gran tama\u00f1o @Transient Excluye un campo del mapeo Relaciones JPA @ManyToOne Relaci\u00f3n muchos a uno @OneToMany Relaci\u00f3n uno a muchos @OneToOne Relaci\u00f3n uno a uno @ManyToMany Relaci\u00f3n muchos a muchos Spring Data JPA @Repository Marca una interfaz como repositorio Spring @Query Define una consulta personalizada (JPQL o SQL) @Param Par\u00e1metros nombrados en consultas @Modifying Consultas de actualizaci\u00f3n o borrado @EnableJpaRepositories Habilita repositorios JPA @EntityGraph Controla la carga de relaciones Transacciones @Transactional Ejecuta m\u00e9todos dentro de una transacci\u00f3n @Rollback Fuerza la reversi\u00f3n de la transacci\u00f3n (tests) Ejemplos @Entity - Marca una clase como una entidad JPA, mapeada a una tabla en la base de datos. @Entity data class User( @Id val id: Long, val name: String ) @Table - Especifica el nombre de la tabla que corresponde a la entidad. @Entity @Table(name = \"users\") data class User( @Id val id: Long, val name: String ) @Id - Indica que un campo es la clave primaria de la tabla. @Id val id: Long @GeneratedValue - Define c\u00f3mo se genera el valor de la clave primaria. Estrategias comunes: GenerationType.IDENTITY , GenerationType.SEQUENCE , etc. @Id @GeneratedValue(strategy = GenerationType.IDENTITY) val id: Long @Column - Configura una columna de la tabla, como nombre, si es nula o \u00fanica. @Column(name = \"user_name\", nullable = false, unique = true) val name: String @ManyToOne , @OneToMany , @OneToOne , @ManyToMany Define relaciones entre entidades. @ManyToOne val department: Department @JoinColumn - Especifica la columna que act\u00faa como clave for\u00e1nea. @ManyToOne @JoinColumn(name = \"department_id\") val department: Department @Lob - Indica que un campo es un objeto grande (texto o binario). @Lob val description: String @Transient - Excluye un campo del mapeo de base de datos (no se almacena). @Transient val calculatedField: String @Repository - Marca una interfaz o clase como repositorio Spring. El data class representa la entidad (tabla), mientras que el @Repository se encarga de las operaciones de acceso a datos sobre esa entidad. @Repository interface UserRepository : JpaRepository<User, Long> @Query - Define una consulta personalizada usando JPQL o SQL nativo. Ejemplo (JPQL): @Query(\"SELECT u FROM User u WHERE u.name = :name\") fun findByName(@Param(\"name\") name: String): List<User> Ejemplo (SQL nativo): @Query(value = \"SELECT * FROM users WHERE user_name = :name\", nativeQuery = true) fun findByNameNative(@Param(\"name\") name: String): List<User> @Param - Define par\u00e1metros nombrados para consultas con @Query . @Query(\"SELECT u FROM User u WHERE u.name = :name\") fun findByName(@Param(\"name\") name: String): List<User> @Modifying - Se utiliza con consultas @Query para operaciones de actualizaci\u00f3n o eliminaci\u00f3n. @Modifying @Query(\"UPDATE User u SET u.name = :name WHERE u.id = :id\") fun updateName(@Param(\"id\") id: Long, @Param(\"name\") name: String) @EnableJpaRepositories - Habilita la funcionalidad de Spring Data JPA y escanea paquetes para detectar repositorios. @EnableJpaRepositories(basePackages = [\"com.example.repository\"]) @EntityGraph - Especifica c\u00f3mo cargar las relaciones en una consulta, evitando lazy loading. @EntityGraph(attributePaths = [\"roles\"]) fun findByName(name: String): User @Transactional - Marca un m\u00e9todo o clase para ejecutar dentro de una transacci\u00f3n. @Transactional fun updateUserDetails(user: User) { ... } @Rollback - Utilizada en pruebas para forzar la reversi\u00f3n de una transacci\u00f3n. @Transactional @Rollback fun testSaveUser() { ... }","title":"\ud83d\udd39Anotaciones JPA"},{"location":"SpringData/#consultas","text":"Las consultas a la Base de datos las podemos hacer de dos maneras, utilizando la convenci\u00f3n de nombres en funciones de Spring Data JPA o con la anotaci\u00f3n @Query . \u2714\ufe0f La convenci\u00f3n de nombres se utiliza: En consultas sencillas y que no requieren l\u00f3gica compleja ni m\u00faltiples combinaciones. Cuando quieres mantener un c\u00f3digo m\u00e1s limpio y directo. \u2714\ufe0f La anotaci\u00f3n @Query se utiliza: En consultas complejas que involucren m\u00faltiples tablas, condiciones avanzadas o subconsultas. Si prefieres optimizar manualmente las consultas. Cuando la convenci\u00f3n de nombres generar\u00eda un nombre de m\u00e9todo excesivamente largo. Convenci\u00f3n de Nombres Spring Data JPA permite definir m\u00e9todos en repositorios siguiendo una convenci\u00f3n de nombres espec\u00edfica. Esto simplifica la escritura de consultas comunes sin necesidad de usar JPQL o SQL. Para ello analiza el nombre de los m\u00e9todos en el repositorio e interpreta su significado para generar consultas autom\u00e1ticamente. La estructura b\u00e1sica es: findBy + NombreDeCampo + Condici\u00f3n 1) findBy : Indica que se busca una entidad en la base de datos. Alternativas: readBy (lectura de datos) queryBy (consulta de datos) getBy (obtener datos) 2) NombreDeCampo : Debe coincidir exactamente con el nombre del atributo en la entidad. Se puede incluir navegaci\u00f3n de atributos para relaciones (EntidadRelacionada.Atributo). 3) Condici\u00f3n (opcional): Permite a\u00f1adir operadores l\u00f3gicos como And, Or, etc. Ejemplo: findByNombreAndEdad. Ejemplos de m\u00e9todos seg\u00fan la convenci\u00f3n Consultas simples M\u00e9todo: findByNombre(String nombre) Consulta generada: SELECT * FROM entidad WHERE nombre = ? Consultas con condiciones M\u00e9todo: findByNombreAndEdad(String nombre, Integer edad) Consulta generada: SELECT * FROM entidad WHERE nombre = ? AND edad = ? Consultas con orden M\u00e9todo: findByNombreOrderByEdadDesc(String nombre) Consulta generada: SELECT * FROM entidad WHERE nombre = ? ORDER BY edad DESC Consultas con relaciones. Si hay una relaci\u00f3n entre entidades, se puede navegar por los campos relacionados: M\u00e9todo: findByComarcaNomC(String nomC) Consulta generada: SELECT * FROM entidad e JOIN comarca c ON e.comarca_id = c.id WHERE c.nomC = ? Palabras clave en la convenci\u00f3n A tener en cuenta Coincidencia exacta del nombre del campo : Los nombres deben coincidir con los atributos definidos en la entidad. Relaciones : Usa la notaci\u00f3n EntidadRelacionada.Atributo para navegar entre tablas relacionadas. Orden : Los m\u00e9todos pueden incluir palabras clave de ordenaci\u00f3n, como OrderBy . Par\u00e1metros : Los m\u00e9todos generados reciben par\u00e1metros en el mismo orden en que se declaran en el nombre del m\u00e9todo. \ud83d\udd39 @Query Estructura b\u00e1sica: @Query(\"SELECT e FROM EntityName e WHERE e.property = :value\") fun findByProperty(@Param(\"value\") value: String): List<EntityName> Se utilizan nombres de entidades y propiedades de las clases en lugar de nombres de tablas y columnas. Se puede navegar por relaciones entre entidades. :nombreParametro para par\u00e1metros din\u00e1micos. Ejemplo sencillo: @Query(\"SELECT c FROM Comarca c WHERE c.provincia = :provincia\") fun findByProvincia(@Param(\"provincia\") provincia: String): List<Comarca> Ejemplo con relaciones: Siguiendo con nuestro ejemplo de geo_ad, la consulta para buscar Institutos en una Provincia por Poblaci\u00f3n M\u00ednima quedar\u00eda as\u00ed: @Query(\"\"\" SELECT i FROM Institut i JOIN i.poblacio p JOIN p.comarca c WHERE c.provincia = :provincia AND p.poblacion >= :minPoblacion \"\"\") fun findByProvinciaAndPoblacion( @Param(\"provincia\") provincia: String, @Param(\"minPoblacion\") minPoblacion: Int ): List<Institut> Este mismo ejemplo utilizando convenci\u00f3n de nombres quedar\u00eda as\u00ed: @Repository interface InstitutRepository : JpaRepository<Institut, String> { fun findByPoblacioComarcaProvinciaAndPoblacioPoblacionGreaterThanEqual( provincia: String, minPoblacion: Int ): List<Institut> } findBy : Indica que es un m\u00e9todo de consulta. PoblacioComarcaProvincia : Navega por las relaciones de las entidades Institut Poblacio -> Comarca para filtrar por la provincia. AndPoblacioPoblacionGreaterThanEqual : Navega por Institut -> Poblacio y aplica el filtro de poblaci\u00f3n m\u00ednima. Conclusi\u00f3n A medida que las relaciones aumentan en complejidad, los nombres de los m\u00e9todos pueden volverse dif\u00edciles de leer y mantener.","title":"\ud83d\udd39Consultas"},{"location":"SpringData/#ejemplo-con-postgres-entidad","text":"En este ejemplo vamos a crear una aplicaci\u00f3n sencilla que acceda a una base de datos Postgres. Para ello utilizaremos la base de datos geo_ad , que ya conocemos de temas anteriores, y que se encuentra en el servidor externo 89.36.214.106 . La aplicaci\u00f3n simplemente mostrar\u00e1 la informaci\u00f3n de la tabla comarcas . Para esta aplicaci\u00f3n crearemos un nuevo proyecto, con la misma configuraci\u00f3n que el anterior, pero a\u00f1adiremos las dependencias necesarias de acceso a la Base de Datos. Configurar el proyecto 1) Creamos el proyecto y lo configuramos desde File-->New-->Project : Elige Spring Boot . Configura las siguientes opciones: Language: Kotlin Build System: Maven Especifica un nombre para el proyecto: PrimerSpringMVC \u00daltima versi\u00f3n de JDK \u00daltima versi\u00f3n de Java 2) Posteriormente seleccionamos las dependencias necesarias: Note Como la aplicaci\u00f3n accede a una Base de datos, necesitaremos las dependencias adicionales Spring Data JPA y PostgreSQL Driver . Spring Web (para el desarrollo de aplicaciones web) Thymeleaf (motor de plantillas para la vista) Spring Boot DevTools (opcional, para facilitar el desarrollo) Spring Data JPA (facilita la integraci\u00f3n de aplicaciones Spring con bases de datos relacionales utilizando el marco JPA (Java Persistence API)) PostgresSQL Driver (proporciona el controlador JDBC para conectarse a bases de datos PostgreSQL.) Despu\u00e9s de aceptar, y si todo ha ido correctamente, ya tendremos nuestro proyecto creado y preparado para a\u00f1adir los elementos de programaci\u00f3n. Al iniciar nuestra aplicaci\u00f3n, lo primero que observamos es que se crea una clase SpringJpaApplication que sirve como contenedor para la configuraci\u00f3n de la aplicaci\u00f3n. No necesita implementar m\u00e9todos adicionales, ya que Spring Boot se encarga de todo gracias a la anotaci\u00f3n @SpringBootApplication . Crear la estructura del Proyecto La estructura b\u00e1sica del proyecto debe reflejar el patr\u00f3n MVC. Organiza las carpetas de la siguiente forma: Controladores : src/main/kotlin/org/tuapp/controller Vistas : src/main/resources/templates Recursos est\u00e1ticos : src/main/resources/static Datos : src/main/kotlin/org/tuapp/model Repositorio : src/main/kotlin/org/tuapp/repository Para ello crea los paquetes: controller , model y repository dentro de la carpeta src/main/kotlin/org/tuapp . Implementaci\u00f3n de la aplicaci\u00f3n Ahora ya podemos a\u00f1adir la programaci\u00f3n necesaria para nuestra aplicaci\u00f3n siguiendo la estructura MVC creada. Dentro de cada paquete crearemos los siguientes archivos: Entidad JPA Define las entidades que corresponden a las tablas existentes en la base de datos. No necesitas configuraciones especiales m\u00e1s all\u00e1 de mapear las columnas. En nuestro caso definimos la entidad comarca y sus campos. En el paquete model crea un archivo llamado comarca.kt package org.example.springjpa.model import jakarta.persistence.* @Entity @Table(name = \"comarca\") class Comarca( @Id @Column(name = \"nom_c\") var nomC: String = \"\", @Column(name = \"provincia\") var provincia: String? = null ) Repositorio Crea un repositorio que permita ejecutar consultas sobre la tabla correspondiente. Dentro del paquete repository , crea un archivo llamado ComarcaRepository.kt package org.example.springjpa.repository import org.example.springjpa.model.Comarca import org.springframework.data.jpa.repository.JpaRepository import org.springframework.stereotype.Repository interface ComarcaRepository : JpaRepository<Comarca, String> { fun findByProvincia(provincia: String): List<Comarca> } Controlador El controlador manejar\u00e1 las solicitudes GET para obtener informaci\u00f3n de la base de datos. Dentro del paquete controller , crea un archivo llamado ComarcaRestController.kt package org.example.springjpa.controller import org.example.springjpa.model.Comarca import org.example.springjpa.repository.ComarcaRepository import org.springframework.web.bind.annotation.* @RestController @RequestMapping(\"/api/comarcas\") class ComarcaController(private val comarcaRepository: ComarcaRepository) { // Endpoint para obtener todas las comarcas @GetMapping fun obtenerComarcas(): List<Comarca> = comarcaRepository.findAll() } @RestController: Combina @Controller y @ResponseBody . Devuelve directamente datos en formato JSON. ObtenerComarcas() : Devuelve una lista de objetos comarca. Spring autom\u00e1ticamente convierte esta lista a JSON usando Jackson (que viene incluido con Spring Boot). Vistas Las vistas pueden ser representadas por tecnolog\u00edas como JSP, Thymeleaf, o JSON (en caso de APIs). En Spring, tanto las vistas HTML como las respuestas JSON se generan autom\u00e1ticamente: las vistas se renderizan con Thymeleaf y los objetos se serializan a JSON sin configuraci\u00f3n adicional. En este ejemplo vamos a visualizar los datos en un navegador con formato JSON y m\u00e1s adelante lo haremos mediante Thymeleaf para ver ambos casos. Configurar la conexi\u00f3n al Servidor Postgres: En el archivo src/main/resources/application.properties configura la conexi\u00f3n a tu base de datos existente: spring.datasource.url=jdbc:postgresql://<HOST>:<PUERTO>/<DB_NAME> spring.datasource.username=<USUARIO> spring.datasource.password=<CONTRASE\u00d1A> spring.jpa.hibernate.ddl-auto=update Cambiaremos los datos de conexi\u00f3n al servidor externo: 89.36.214.106 spring.application.name=SpringJPA spring.datasource.url=jdbc:postgresql://89.36.214.106:5432/geo_ad spring.datasource.username=geo_ad spring.datasource.password=geo_ad Configuraci\u00f3n b\u00e1sica de JPA En una aplicaci\u00f3n Spring Boot con Spring Data JPA, es fundamental definir expl\u00edcitamente ciertos par\u00e1metros de configuraci\u00f3n en el archivo application.properties . Estas propiedades permiten controlar el comportamiento de Hibernate, evitar efectos no deseados sobre la base de datos y facilitar la comprensi\u00f3n del funcionamiento interno del framework. En el contexto de este proyecto, donde se trabaja con una base de datos PostgreSQL creada previamente, se establecen las siguientes propiedades con los siguientes objetivos: Garantizar que Spring no modifique el esquema de la base de datos, manteniendo el control sobre tablas, claves y relaciones. spring.jpa.hibernate.ddl-auto=none Visualizar las consultas SQL reales que Hibernate genera y ejecuta, con fines did\u00e1cticos y de depuraci\u00f3n. spring.jpa.show-sql=true Indicar expl\u00edcitamente el tipo de base de datos utilizada, asegurando que Hibernate emplea el dialecto y la sintaxis SQL correctos. spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect Por estos motivos, el archivo application.properties quedar\u00e1 finalmente as\u00ed: Ejecutar la aplicaci\u00f3n La aplicaci\u00f3n estar\u00e1 disponible en http://localhost:8080/api/comarcas , o el puerto que hayas especificado, para listar las comarcas. Ser\u00eda deseable que el resultado se mostrara de manera m\u00e1s amigable para el usuario, por lo que en el siguiente ejemplo haremos los cambios necesarios para utilizar Thymeleaf y que el resultado se muestre en cajas de texto. Thymeleaf para mostrar los resultados: 1) Configuraci\u00f3n de dependencias . Aseg\u00farate de tener la dependencia de Thymeleaf en tu archivo pom.xml . Esta dependencia la hemos seleccionado al configurar la aplicaci\u00f3n y seguramente ya la tengamos incluida. <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-thymeleaf</artifactId> </dependency> 2) Configurar Thymeleaf en application.properties A\u00f1ade las siguientes propiedades: spring.thymeleaf.prefix=classpath:/templates/ spring.thymeleaf.suffix=.html spring.thymeleaf.cache=false 3) Crear un nuevo Controlador . Cada controller debe tener rutas distintas, ya que devuelve HTML en lugar de JSON. ComarcaMvcController.kt package org.example.springjpa.controller import org.springframework.stereotype.Controller import org.springframework.ui.Model import org.example.springjpa.repository.ComarcaRepository import org.springframework.web.bind.annotation.* @Controller //en lugar de @RestController @RequestMapping(\"/comarcas\") class ComarcaControllerEntity(private val ComarcaRepository: ComarcaRepository) { @GetMapping fun listarComarcas(model:Model): String { val comarcas = ComarcaRepository.findAll() model.addAttribute(\"comarcas\", comarcas) return \"comarcas\" // Nombre de la plantilla HTML } } 4) Vistas Para agregar un entorno de usuario amigable con cajas de texto y que los datos de la base de datos se muestren en una aplicaci\u00f3n web, crea un archivo comarcas.html en el directorio src/main/resources/templates . <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Lista de Comarcas</title> </head> <body> <h1>Lista de Comarcas</h1> <table border=\"1\"> <tr> <th>ID</th> <th>Provincia</th> </tr> <tr th:each=\"comarca : ${comarcas}\"> <td th:text=\"${comarca.nomC}\">Nombre</td> <td th:text=\"${comarca.provincia}\">Provincia</td> </tr> </table> </body> </html> th:each : Itera sobre la lista de comarcas. th:text : Inserta din\u00e1micamente el valor de un campo en el HTML. Ejecuatar la aplicaci\u00f3n Accede a http://localhost:8080/comarcas para listar las comarcas. En el navegador, se mostrar\u00e1 una tabla HTML con las comarcas almacenadas en la base de datos. Los datos din\u00e1micos se renderizan usando Thymeleaf . Este enfoque permite crear interfaces web amigables y bien estructuradas. Consultas a la Base de datos Con la anotaci\u00f3n @Query en el repositorio, podemos realizar consultas personalizadas a la base de datos. A continuaci\u00f3n veremos los cambios que deber\u00edamos hacer en los ficheros para poder hacer una consulta con par\u00e1metros y visualizar los datos tanto en json com con thymeleaf: Cambios en los ficheros .kt: ComarcaRepository package org.example.springjpa.repository import org.springframework.data.jpa.repository.Query import org.springframework.data.repository.query.Param import org.example.springjpa.model.Comarca import org.springframework.data.jpa.repository.JpaRepository import org.springframework.stereotype.Repository @Repository interface ComarcaRepository : JpaRepository<Comarca, String> { @Query(\"SELECT c FROM Comarca c WHERE c.provincia = :provincia\") fun findComarcasporProvincia(@Param(\"provincia\") provincia: String): List<Comarca> } ComarcaRestController package org.example.springjpa.controller import org.example.springjpa.model.Comarca import org.example.springjpa.repository.ComarcaRepository import org.springframework.web.bind.annotation.* @RestController //en lugar de @Controller @RequestMapping(\"/api/comarcas\") class ComarcaController(private val ComarcaRepository: ComarcaRepository) { @GetMapping(\"/buscar\") fun BuscarComarcasporProvincia(@RequestParam provincia: String): List<Comarca> { return ComarcaRepository.findComarcasporProvincia(provincia) } } Anotaciones importantes @Query : Permite definir consultas SQL personalizadas directamente en el repositorio. La consulta SELECT c FROM Comarca c WHERE c.provincia = :provincia selecciona todas las comarcas donde la columna provincia coincide con el par\u00e1metro provincia. @Param : Vincula el par\u00e1metro de la consulta con el valor que se pasa desde el m\u00e9todo. En este caso, @Param(\"provincia\") conecta el par\u00e1metro provincia de la consulta SQL con el argumento del m\u00e9todo. @GetMapping y @RequestParam : Define un endpoint HTTP GET en el controlador. El par\u00e1metro provincia se obtiene de la URL. Por ejemplo, si queremos listar las comarcas de la provincia de Alacant, obtenemos: http://localhost:8080/comarcas/buscar?provincia=Alacant Visualizar la salida con Thymeleaf Si la visualizaci\u00f3n la queremos hacer con Thymeleaf los cambios a realizar se har\u00edan solo en ComarcaMvcController , ya que el formulaio comarcas.html se puede seguir utilizando si queremos mostrar los mismos campos: import org.springframework.stereotype.Controller import org.example.primerspringmvc.repository.ComarcaRepository import org.springframework.ui.Model import org.springframework.web.bind.annotation.* @Controller //en lugar de @RestController @RequestMapping(\"/comarcas\") class ComarcaController(private val ComarcaRepository: ComarcaRepository) { @GetMapping fun listarComarcas(model:Model): String { val comarcas = ComarcaRepository.findAll() model.addAttribute(\"comarcas\", comarcas) return \"comarcas\" // Nombre de la plantilla HTML } @GetMapping(\"/buscar\") fun buscarComarcasPorProvincia(@RequestParam provincia: String, model: Model): String { val comarcas= ComarcaRepository.findComarcasporProvincia(provincia) model.addAttribute(\"comarcas\", comarcas) return \"comarcas\" // Nombre de la plantilla HTML } } Y el resultado se ver\u00eda as\u00ed:","title":"\ud83d\udd39 Ejemplo con Postgres (Entidad)"},{"location":"SpringData/#postgres-en-docker","text":"Para no tener que instalarnos un servidor Postgres en nuestro equipo, podemos tener nuestra base de datos en un contenedor Docker. En este caso, los cambios principales se centran en la configuraci\u00f3n de conexi\u00f3n en la aplicaci\u00f3n y en el despliegue del contenedor de PostgreSQL. Antes de acceder al contenedor tenemos que crearlo. En nuestro caso crearemos un contenedor Docker de Postgres y posteriormente restauraremos la base de datos geo_ad en dicho contenedor, para poder disponer de la misma configuracion y los mismos datos que en el servidor externo. Partimos del hecho que tenemos instalado Docker en nuesto equipo, en caso contario te dejo un peque\u00f1o tutorial de como instalarlo en el apartado Docker de esta unidad. Los pasos a seguir para crear dicho contendor son: 1. Ejecutar PostgreSQL en Docker Crea y ejecuta el contenedor de PostgreSQL: docker run --name postgres-container -e POSTGRES_USER=admin -e POSTGRES_PASSWORD=admin -e POSTGRES_DB=demo -p 5432:5432 -d postgres POSTGRES_USER: Usuario de la base de datos. POSTGRES_PASSWORD: Contrase\u00f1a del usuario. POSTGRES_DB: Nombre de la base de datos. -p 5432:5432: Mapea el puerto 5432 del contenedor al puerto 5432 de tu m\u00e1quina. Verifica que el contenedor est\u00e9 corriendo: docker ps (Opcional) Con\u00e9ctate al contenedor para verificar la base de datos, desde DBeaver , o desde el terminal: docker exec -it postgres-container psql -U admin -d demo 2. Restaurar la base de datos en el contenedor con DBeaver : Vamos a restaurar la base de datos geo_ad en la base de datos demo , que hemos creado con docker. Para ello os he dejado un archivo dump , en Aules , que contiene el backup de geo_ad. Lo siguiente ser\u00e1 restaurar este backup en demo , siguiendo esto pasos: Crear una nueva conexi\u00f3n en DBeaver al contenedor local: Host: localhost Puerto: 5432 Usuario y contrase\u00f1a: admin Base de datos: demo Restaurar el archivo de respaldo: Haz clic derecho en la base de datos en el contenedor \u2192 Herramientas > Restaurar (Restore). Archivo de respaldo : Selecciona el archivo de respaldo exportado, disponible en Aules. Pulsa Start y espera a que termine la restauraci\u00f3n. Una vez terminado selecciona cancelar para que no vuelva a realizar la restauraci\u00f3n. 3. Cambios en la Configuraci\u00f3n de la Aplicaci\u00f3n En el archivo application.properties , configura la conexi\u00f3n a PostgreSQL en el contenedor Docker. spring.datasource.url=jdbc:postgresql://localhost:5432/demo spring.datasource.username=admin spring.datasource.password=admin spring.jpa.hibernate.ddl-auto=none spring.jpa.show-sql=true spring.jpa.properties.hibernate.format_sql=true Todos los cambios que necesitas para ejecutar la aplicaci\u00f3n y que acceda a la base de datos que se encuentra en el contenedor son los anteriormente descritos. El resto de ficheros y estructura no se ver\u00e1 afectada. Una vez tenemos la base de datos restaurada con los datos de geo_ad ya podemos ejecutar la aplicaci\u00f3n y comprobar que los resultados son los mismos que si accedemos a la base de datos del servidor.","title":"\ud83d\udd39Postgres en Docker"},{"location":"SpringData/#crud-basico","text":"Siguiendo con el ejemplo del apartado anterior, que accede a una base de datos relacional Postgres en un contenedor Docker , en este apartado iremos m\u00e1s all\u00e1 y veremos como realizar operaciones CRUD , ya que ahora la base de datos est\u00e1 en local y podemos hacer todas las modificaciones que necesitemos. Como ejemplo, haremos modificaciones sobre la tabla comarcas . \ud83d\udc49El \u00fanico fichero a modificar ser\u00e1 el controlador , ya que Las operaciones CRUD son acciones, y las acciones se gestionan en el Controller. Tambien se crear\u00e1n nuevas vistas para visualizar los resultados con Thymeleaf : ComarcaMvcController.kt package org.example.springjpa.controller import org.example.springjpa.model.Comarca import org.springframework.stereotype.Controller import org.springframework.ui.Model import org.example.springjpa.repository.ComarcaRepository import org.springframework.web.bind.annotation.* @Controller //en lugar de @RestController @RequestMapping(\"/comarcas\") class ComarcaControllerEntity(private val ComarcaRepository: ComarcaRepository) { @GetMapping fun listarComarcas(model:Model): String { val comarcas = ComarcaRepository.findAll() model.addAttribute(\"comarcas\", comarcas) return \"comarcas\" // Nombre de la plantilla HTML } @GetMapping(\"/buscar\") fun buscarComarcasPorProvincia(@RequestParam provincia: String, model: Model): String { val comarcas= ComarcaRepository.findComarcasporProvincia(provincia) model.addAttribute(\"comarcas\", comarcas) return \"comarcas\" // Nombre de la plantilla HTML } @GetMapping(\"/nueva\") fun mostrarFormularioNuevaComarca(model: Model): String { model.addAttribute(\"comarca\", Comarca()) return \"nueva_comarca\" } @PostMapping(\"/nueva\") fun guardarComarca(@ModelAttribute comarca: Comarca): String { ComarcaRepository.save(comarca) return \"redirect:/comarcas\" } @GetMapping(\"/editar/{id}\") fun mostrarFormularioEditarComarca( @PathVariable id: String, model: Model ): String { val comarca = ComarcaRepository.findById(id) .orElseThrow { IllegalArgumentException(\"Comarca no encontrada: $id\") } model.addAttribute(\"comarca\", comarca) return \"editar_comarca\" } @PostMapping(\"/editar/{id}\") fun actualizarComarca( @PathVariable id: String, @ModelAttribute comarca: Comarca ): String { val comarcaExistente = ComarcaRepository.findById(id) .orElseThrow { IllegalArgumentException(\"Comarca no encontrada: $id\") } // Solo se actualizan los campos editables comarcaExistente.provincia = comarca.provincia ComarcaRepository.save(comarcaExistente) return \"redirect:/comarcas\" } @GetMapping(\"/eliminar/{id}\") fun eliminarComarca(@PathVariable id: String): String { if (!ComarcaRepository.existsById(id)) { throw IllegalArgumentException(\"Comarca no encontrada: $id\") } ComarcaRepository.deleteById(id) return \"redirect:/comarcas\" } } \ud83d\udc49Creamos las vistas que permiten gestionar las operaciones CRUD nueva_comarca.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <meta charset=\"UTF-8\"> <title>Nueva Comarca</title> </head> <body> <h1>Nueva Comarca</h1> <form th:action=\"@{/comarcas/nueva}\" th:object=\"${comarca}\" method=\"post\"> <label for=\"nomC\">Nombre:</label> <input type=\"text\" th:field=\"*{nomC}\" required> <br> <label for=\"provincia\">Provincia:</label> <input type=\"text\" th:field=\"*{provincia}\" required> <br> <button type=\"submit\">Guardar</button> </form> </body> </html> editar_comarca.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <meta charset=\"UTF-8\"> <title>Editar Comarca</title> </head> <body> <h1>Editar Comarca</h1> <form th:action=\"@{/comarcas/editar/{id}(id=${comarca.nomC})}\" th:object=\"${comarca}\" method=\"post\"> <label for=\"nomC\">Nombre:</label> <input type=\"text\" th:field=\"*{nomC}\" readonly> <br> <label for=\"provincia\">Provincia:</label> <input type=\"text\" th:field=\"*{provincia}\" required> <br> <button type=\"submit\">Actualizar</button> </form> </body> </html> eliminar_comarca.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <meta charset=\"UTF-8\"> <title>Eliminar Comarca</title> </head> <body> <h1>Eliminar Comarca</h1> <p>\u00bfEst\u00e1s seguro de que deseas eliminar la siguiente comarca?</p> <ul> <li><strong>Nombre:</strong> <span th:text=\"${comarca.nomC}\">Nombre</span></li> <li><strong>Provincia:</strong> <span th:text=\"${comarca.provincia}\">Provincia</span></li> </ul> <form th:action=\"@{/comarcas/eliminar/{id}(id=${comarca.nomC})}\" method=\"post\"> <button type=\"submit\">S\u00ed, eliminar</button> <a th:href=\"@{/comarcas}\">Cancelar</a> </form> </body> </html> \ud83d\udc49Modificamos la vista comarcas.html que muestra todas las comarcas y permite acceder al resto de operaciones del CRUD. <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Lista de Comarcas</title> </head> <body> <h1>Lista de Comarcas</h1> <table border=\"1\"> <tr> <th>Nombre</th> <th>Provincia</th> <th>Acciones</th> </tr> <tr th:each=\"comarca : ${comarcas}\"> <td th:text=\"${comarca.nomC}\">Nombre</td> <td th:text=\"${comarca.provincia}\">Provincia</td> <td> <a th:href=\"@{/comarcas/editar/{id}(id=${comarca.nomC})}\">Editar</a> <a th:href=\"@{/comarcas/eliminar/{id}(id=${comarca.nomC})}\">Eliminar</a> </td> </tr> </table> </body> </html> \ud83d\udc49El resultado ser\u00eda el siguiente: URL Captura http://localhost:8080/comarcas http://localhost:8080/comarcas/nueva http://localhost:8080/comarcas/editar/ComarcaNueva http://localhost:8080/comarcas/eliminar/ComarcaNueva","title":"\ud83d\udd39CRUD b\u00e1sico"},{"location":"SpringData/#dto-data-transfer-object","text":"Hasta ahora, los ejemplos mostraban c\u00f3mo devolver directamente las entidades desde el controlador. Aunque esto funciona, no es una buena pr\u00e1ctica en aplicaciones reales, ya que expone el modelo de la base de datos y puede provocar problemas de seguridad y mantenimiento. En este ejemplo se introduce el uso de DTO (Data Transfer Object) para separar las entidades JPA de los datos que se env\u00edan al cliente. Hasta ahora hemos visto que el Controller llama directamente al Repository . Al introducir DTO, se a\u00f1ade la capa Service porque ahora tenemos una nueva responsabilidad. En resumen, el repositorio sigue trabajando con entidades, el servicio transforma esas entidades en DTO y el controlador devuelve los DTO al cliente. Hasta ahora el Controller Con Service + DTO , el objetivo es - Accede directamente al Repository - El controller solo gestiona peticiones y vistas - Trabaja con entidades JPA - La l\u00f3gica de negocio y transformaci\u00f3n va al Service - Decide qu\u00e9 datos se muestran en la vista BD \u2192 Entity \u2192 Repository \u2192 Controller \u2192 Vista BD \u2192 Entity \u2192 Repository \u2192 Service \u2192 DTO \u2192 Controller \u2192 Vista Cu\u00e1ndo utilizar DTO en las operaciones CRUD Los DTO se utilizan para leer y comunicar datos, no para persistirlos: Operaci\u00f3n Uso de DTO Explicaci\u00f3n \u2795 CREATE \u26a0\ufe0f A veces Normalmente se puede usar directamente la entidad . El DTO solo es necesario si el formulario no coincide con la entidad. \ud83d\udd0d READ \u2705 S\u00ed Al listar o mostrar datos es recomendable usar DTO , ya que los datos salen de la aplicaci\u00f3n hacia el exterior. \u270f\ufe0f UPDATE \u26a0\ufe0f A veces Se utiliza DTO cuando no queremos permitir modificar todos los campos de la entidad. \ud83d\uddd1\ufe0f DELETE \u274c No No se usa DTO, ya que \u00fanicamente se env\u00eda el identificador del objeto a eliminar. Cambios que se introducen en cada capa \ud83d\udc49 Paquetes que NO cambian al usar DTO model \u2192 Las entidades JPA (@Entity) siguen siendo las mismas. repository \u2192 Contin\u00faa trabajando con entidades y Spring Data JPA. \ud83d\udc49 Paquetes que S\u00cd cambian al usar DTO dto (nuevo paquete) \u2192 No depende de JPA y No tiene anotaciones ComarcaDTO.kt package org.example.springjpa.dto data class ComarcaDTO( val nomC: String, //Cambiamos nom_c \u2192 nomC (m\u00e1s claro para la API) val provincia: String? ) service (nuevo paquete) \u2192 Aqu\u00ed es donde introducimos DTO correctamente. ComarcaService.kt package org.example.springjpa.service import org.example.springjpa.dto.ComarcaDTO import org.example.springjpa.repository.ComarcaRepository import org.springframework.stereotype.Service @Service class ComarcaService( private val comarcaRepository: ComarcaRepository //inyecta el Repository ) { /** * Devuelve el listado completo de comarcas. * Se define en la capa Service para separar la l\u00f3gica de negocio * del controller y devolver los datos ya transformados en DTO, * evitando que la vista trabaje directamente con entidades. */ fun obtenerComarcas(): List<ComarcaDTO> { //los datos van a salir hacia la vista return comarcaRepository.findAll() .map { comarca -> //Se usa map para transformar cada entidad en un DTO ComarcaDTO( //Se seleccionan solo los campos necesarios nomC = comarca.nomC, //Se pueden renombrar campos provincia = comarca.provincia ) } } // M\u00e9todo espec\u00edfico para buscar comarcas por provincia. //Se define para que el controller no acceda al repository // y para centralizar la conversi\u00f3n Entity \u2192 DTO. fun obtenerComarcasPorProvincia(provincia: String): List<ComarcaDTO> { return comarcaRepository.findByProvincia(provincia) .map { ComarcaDTO( nomC = it.nomC, provincia = it.provincia ?: \"\" ) } } } controller \u2192 Cambiamo sel conrolador. Ahora devuelve DTO ComarcaRestController.kt package org.example.springjpa.controller import org.example.springjpa.dto.ComarcaDTO import org.example.springjpa.service.ComarcaService import org.springframework.web.bind.annotation.* @RestController @RequestMapping(\"/api/comarcas\") class ComarcaController( private val comarcaService: ComarcaService ) { // Listado general @GetMapping fun obtenerComarcas(): List<ComarcaDTO> = comarcaService.obtenerComarcas() // B\u00fasqueda por provincia @GetMapping(\"/buscar\") fun obtenerComarcasPorProvincia( @RequestParam provincia: String ): List<ComarcaDTO> = comarcaService.obtenerComarcasPorProvincia(provincia) } El DTO no afecta a c\u00f3mo se accede a la aplicaci\u00f3n, sino a qu\u00e9 informaci\u00f3n se devuelve y c\u00f3mo se presenta.","title":"\ud83d\udd39DTO (Data Transfer Object)"},{"location":"SpringData/#ampliacion-bd-completa","text":"Para practicar la funcionalidad de Spring Data JPA vamos a seguir con el ejemplo SpringJPA . Recordemos que la aplicaci\u00f3n accede a la base de datos local en Docker . En este ejemplo vamos a mapear las 3 tablas de la base de datos: comarca, poblacio e institut y a realizar los cambios necesarios para crear algunas consultas y operaciones CRUD. Utilizaremos Thymeleaf para mostrar los resultados. Entidad Comarca . Ya la ten\u00edamos creada en el ejemplo anterior. import jakarta.persistence.* @Entity @Table(name = \"comarca\") data class comarca( @Id @Column(name = \"nom_c\") val nomC: String = \"\", @Column(name = \"provincia\") val provincia: String? = null ) Entidad Poblacio import jakarta.persistence.* @Entity @Table(name = \"poblacio\") class poblacio( @Id @Column(name = \"cod_m\") val codM: Int = 0, @Column(name = \"nom\") val nom: String = \"\", @Column(name = \"poblacio\") val poblacio: Int? = null, @Column(name = \"extensio\") val extensio: Double? = null, @Column(name = \"altura\") val altura: Int? = null, @Column(name = \"longitud\") val longitud: String? = null, @Column(name = \"latitud\") val latitud: String? = null, @Column(name = \"llengua\") val llengua: String? = null, @ManyToOne //clave ajena a comarca @JoinColumn(name = \"nom_c\", referencedColumnName = \"nom_c\") val comarca: Comarca? = null ) Entidad Institut import jakarta.persistence.* @Entity @Table(name = \"institut\") data class institut( @Id @Column(name = \"codi\") val codi: String = \"\", @Column(name = \"adreca\") val adreca: String? = null, @Column(name = \"codpostal\") val codPostal: Int? = null, @Column(name = \"nom\") val nom: String? = null, @Column(name = \"numero\") val numero: String? = null, @ManyToOne //clave ajena a poblacio @JoinColumn(name = \"cod_m\", referencedColumnName = \"cod_m\") val poblacio: poblacio? = null ) Repositorio para Comarca: ComarcaRepository . package org.example.springjpa.repository import org.springframework.data.jpa.repository.Query import org.springframework.data.repository.query.Param import org.example.springjpa.model.Comarca import org.springframework.data.jpa.repository.JpaRepository import org.springframework.stereotype.Repository @Repository interface ComarcaRepository : JpaRepository<Comarca, String> { @Query(\"SELECT c FROM Comarca c WHERE c.provincia = :provincia\") fun findComarcasporProvincia(@Param(\"provincia\") provincia: String): List<Comarca> fun findByProvincia(provincia: String): List<Comarca> } Repositorio para Institut: InstitutRepository package org.example.primerspringmvc.repository import org.example.primerspringmvc.model.institut import org.springframework.data.jpa.repository.JpaRepository interface InstitutRepository : JpaRepository<institut, String> { // Obtener institutos de una poblaci\u00f3n fun findByPoblacioNom(nom: String): List<institut> // Obtener institutos de una comarca fun findByPoblacioComarcaNomC(nomC: String): List<institut> // Obtener institutos de una provincia fun findByPoblacioComarcaProvincia(provincia: String): List<institut> // Obtener institutos cuya poblaci\u00f3n es mayor a fun findByPoblacioPoblacioGreaterThan(poblacio: Int): List<institut> } Repositorio para Poblacio: PoblacioRepository import org.example.primerspringmvc.model.poblacio import org.springframework.data.jpa.repository.JpaRepository interface PoblacioRepository : JpaRepository<poblacio, String> { // Obtener poblaciones de una comarca fun findByComarcaNomC(nomC: String): List<poblacio> // Obtener poblaciones de una provincia fun findByComarcaProvincia(provincia: String): List<poblacio> } Controlador para Institut: InstitutMvcController package org.example.springjpa.controller import org.example.springjpa.repository.InstitutRepository import org.springframework.stereotype.Controller import org.springframework.ui.Model import org.springframework.web.bind.annotation.* @Controller @RequestMapping(\"/instituts\") class InstitutController(private val institutRepository: InstitutRepository) { //Muestra todos los intitutos @GetMapping fun listarInstituts(model: Model): String { val instituts = institutRepository.findAll() model.addAttribute(\"instituts\", instituts) return \"instituts\" } // Muestra institutos de una poblaci\u00f3n @GetMapping(\"/por-poblacio\") fun obtenerInstitutsPoblacio(@RequestParam poblacio: String, model: Model): String { val institutsPoblacio = institutRepository.findByPoblacioNom(poblacio) model.addAttribute(\"instituts\", institutsPoblacio) return \"instituts\" // Plantilla para mostrar la lista de institutos } // Muestra institutos de una comarca @GetMapping(\"/por-comarca\") fun obtenerInstitutsComarca(@RequestParam comarca: String, model: Model): String { val institutsComarca = institutRepository.findByPoblacioComarcaNomC(comarca) model.addAttribute(\"instituts\", institutsComarca) return \"instituts\" // Plantilla para mostrar la lista de institutos } // Muestra institutos de una provincia @GetMapping(\"/por-provincia\") fun obtenerInstitutsProvincia(@RequestParam provincia: String, model: Model): String { val institutsProvincia = institutRepository.findByPoblacioComarcaProvincia(provincia) model.addAttribute(\"instituts\", institutsProvincia) return \"instituts\" // Plantilla para mostrar la lista de institutos } // Muestra institutos con poblaci\u00f3n superior a un valor @GetMapping(\"/poblacion-superior\") fun obtenerInstitutsPoblacionSuperior(@RequestParam poblacio: Int, model: Model): String { val institutsConPoblacionSuperiorA = institutRepository.findByPoblacioPoblacioGreaterThan(poblacio) model.addAttribute(\"instituts\", institutsConPoblacionSuperiorA) return \"instituts\" // Plantilla para mostrar la lista de institutos } } Controlador para Poblacio: PoblacioMvcController package org.example.springjpa.controller import org.example.springjpa.repository.PoblacioRepository import org.springframework.stereotype.Controller import org.springframework.ui.Model import org.springframework.web.bind.annotation.* @Controller @RequestMapping(\"/poblacions\") class PoblacioController(private val poblacioRepository: PoblacioRepository) { // Muestra todas las poblaciones @GetMapping fun listarTodasPoblacions(model: Model): String { val poblacions = poblacioRepository.findAll() model.addAttribute(\"poblacions\", poblacions) return \"poblacions\" // Vista Thymeleaf para mostrar todas las poblaciones } // Muestra las poblaciones por comarca @GetMapping(\"/por-comarca\") fun listarPoblacionsPorComarca(@RequestParam comarca: String, model: Model): String { val poblacions = poblacioRepository.findByComarcaNomC(comarca) model.addAttribute(\"poblacions\", poblacions) return \"poblacions\" // Vista Thymeleaf para mostrar las poblaciones por comarca } @GetMapping(\"/por-provincia\") fun listarPoblacionsPorProvincia(@RequestParam provincia: String, model: Model): String { val poblacions = poblacioRepository.findByComarcaProvincia(provincia) model.addAttribute(\"poblacions\", poblacions) return \"poblacions\" // Vista Thymeleaf para mostrar las poblaciones por comarca } } Vista instituts.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Instituts</title> </head> <body> <h1>Llista d'Instituts</h1> <table border=\"1\"> <tr> <th>Codi</th> <th>Nom</th> <th>Adre\u00e7a</th> <th>Poblaci\u00f3</th> <th>Habitants</th> <th>Comarca</th> <th>Provincia</th> </tr> <tr th:each=\"institut : ${instituts}\"> <td th:text=\"${institut.codi}\">Codi</td> <td th:text=\"${institut.nom}\">Nom</td> <td th:text=\"${institut.adreca}\">Adre\u00e7a</td> <td th:text=\"${institut.poblacio?.nom}\">Poblaci\u00f3</td> <td th:text=\"${institut.poblacio?.poblacio}\">Habitants</td> <td th:text=\"${institut.poblacio?.comarca?.nomC}\">Comarca</td> <td th:text=\"${institut.poblacio?.comarca?.provincia}\">Provincia</td> </tr> </table> </body> </html> Vista poblacions.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Poblacions</title> </head> <body> <h1>Llista de Poblacions per Comarca</h1> <table border=\"1\"> <tr> <th>Codi</th> <th>Nom</th> <th>Comarca</th> <th>Provincia</th> </tr> <tr th:each=\"poblacio : ${poblacions}\"> <td th:text=\"${poblacio.codM}\">Codi</td> <td th:text=\"${poblacio.nom}\">Nom</td> <td th:text=\"${poblacio.comarca?.nomC}\">Comarca</td> <td th:text=\"${poblacio.comarca?.provincia}\">Provincia</td> </tr> </table> </body> </html> Con esta configuraci\u00f3n podemos listar los siguientes ejemplos : Todos los institutos: http://localhost:8080/instituts Todas las poblaciones: http://localhost:8080/poblacions Todas las comarcas: http://localhost:8080/comarcas Listar institutos de una poblaci\u00f3n: http://localhost:8080/instituts/por-poblacio?poblacio=Gandia Listar institutos de una comarca: http://localhost:8080/instituts/por-comarca?comarca=Safor Listar institutos de una provincia: http://localhost:8080/instituts/por-provincia?provincia=Alacant Listar comarcas de una provincia: http://localhost:8080/comarcas/por-provincia?provincia=Alacant Listar poblaciones de una comarca http://localhost:8080/poblacions/por-comarca?comarca=Safor Listar poblaciones de una provincia: http://localhost:8080/poblacions/por-provincia?provincia=Alacant Listar institutos con poblaci\u00f3n superior a un valor: http://localhost:8080/instituts/poblacion-superior?poblacio=20000 Transformaci\u00f3n del ejemplo utilizando DTO Las entidades NO cambian Los repositorios NO cambian Se a\u00f1aden DTO + Service Los Controller pasan DTO a la vista En este ejemplo mostraremos los resultados en JSON y por tanto utilizaremos los controladores REST. \ud83d\udc49 Nuevo paquete dto package org.example.springjpa.dto data class ComarcaDTO( val nomC: String, val provincia: String? ) package org.example.springjpa.dto data class PoblacioDTO( val codM: Int, val nom: String, val poblacio: Int?, val comarcaNom: String ) package org.example.springjpa.dto data class InstitutDTO( val codi: String, val nom: String?, val adreca: String?, val poblacioNom: String, val comarcaNom: String, val provincia: String ) \ud83d\udc49 Nuevo paquete PoblacioService package org.example.springjpa.service import org.example.springjpa.dto.PoblacioDTO import org.example.springjpa.repository.PoblacioRepository import org.springframework.stereotype.Service @Service class PoblacioService( private val poblacioRepository: PoblacioRepository ) { fun obtenerPoblacionesPorComarca(nomC: String): List<PoblacioDTO> = poblacioRepository.findByComarcaNomC(nomC).map { PoblacioDTO( codM = it.codM, nom = it.nom, poblacio = it.poblacio, comarcaNom = it.comarca?.nomC ?: \"\" ) } } \ud83d\udc49 Nuevo paquete InstitutService package org.example.springjpa.service import org.example.springjpa.dto.InstitutDTO import org.example.springjpa.repository.InstitutRepository import org.springframework.stereotype.Service @Service class InstitutService( private val institutRepository: InstitutRepository ) { fun obtenerInstitutosPorProvincia(provincia: String): List<InstitutDTO> = institutRepository.findByPoblacioComarcaProvincia(provincia) .map { InstitutDTO( codi = it.codi, nom = it.nom, adreca = it.adreca, poblacioNom = it.poblacio?.nom ?: \"\", comarcaNom = it.poblacio?.comarca?.nomC ?: \"\", provincia = it.poblacio?.comarca?.provincia ?: \"\" ) } } \ud83d\udc49 Nuevo Paquete InstitutRestcontroller package org.example.springjpa.controller import org.example.springjpa.service.InstitutService import org.example.springjpa.dto.InstitutDTO import org.springframework.web.bind.annotation.* @RestController @RequestMapping(\"/api/instituts\") class InstitutRestController( private val institutService: InstitutService ) { @GetMapping(\"/provincia\") fun obtenirPerProvincia( @RequestParam provincia: String ): List<InstitutDTO> = institutService.obtenerInstitutosPorProvincia(provincia) } \ud83d\udc49 Nuevo Paquete PoblacioRestcontroller package org.example.springjpa.controller import org.example.springjpa.dto.PoblacioDTO import org.example.springjpa.service.PoblacioService import org.springframework.web.bind.annotation.* @RestController @RequestMapping(\"/api/poblacions\") class PoblacioRestController( private val poblacioService: PoblacioService ) { // Obtener poblaciones de una comarca @GetMapping(\"/comarca\") fun obtenirPerComarca( @RequestParam nomC: String ): List<PoblacioDTO> = poblacioService.obtenerPoblacionesPorComarca(nomC) } Listar las poblaciones de la Comarca del Ports: http://localhost:8080/api/poblacions/comarca?nomC=Ports Listar las poblaciones de la provincia de Val\u00e8ncia: http://localhost:8080/api/poblacions/provincia?provincia=Val%C3%A8ncia","title":"\ud83d\udd39Ampliaci\u00f3n (BD completa)"},{"location":"SpringData/#spring-data-mongodb","text":"El componente Spring MongoDB Es un m\u00f3dulo de Spring Data que facilita la integraci\u00f3n de aplicaciones Spring con MongoDB . Adem\u00e1s proporciona una abstracci\u00f3n sobre las operaciones b\u00e1sicas de MongoDB como CRUD, consultas personalizadas, y soporte para agregaciones. Requisitos Tener MongoDB instalado o utilizar una instancia en la nube o en un contenedor Docker. Spring Boot configurado con Maven (en nuestro caso) o Gradle. Dependencias Maven <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-data-mongodb</artifactId> </dependency> Configuraci\u00f3n de las propiedades application.properties spring.data.mongodb.host=localhost spring.data.mongodb.port=27017 spring.data.mongodb.database=nombre_base_de_datos Si est\u00e1s usando MongoDB con autenticaci\u00f3n, a\u00f1ade: spring.data.mongodb.username=usuario spring.data.mongodb.password=contrase\u00f1a","title":"\ud83d\udd39Spring Data MongoDB"},{"location":"SpringData/#anotaciones-comunes","text":"Estas anotaciones permiten mapear documentos, gestionar colecciones y realizar operaciones de manera sencilla. Las principales anotaciones utilizadas en Spring Data MongoDB son: @Document Se utiliza para marcar una clase como un documento MongoDB que ser\u00e1 persistido en una colecci\u00f3n. @Document(collection = \"coleccion\") * collection : Especifica el nombre de la colecci\u00f3n. Si no se define, se usa el nombre de la clase en min\u00fasculas. @Id Marca un campo como identificador \u00fanico del documento. Este campo se mapea al campo _id en MongoDB. @Field Se utiliza para mapear un campo de la clase a un campo espec\u00edfico en el documento MongoDB. @Field(\"descripcion\") val descripcionProducto: String @Transient Indica que un campo no debe ser persistido en la base de datos. @Transient val temporal: String = \"No se guarda en MongoDB\" @DBRef Se utiliza para definir una relaci\u00f3n entre documentos, similar a una clave for\u00e1nea. El atributo se mapea a una referencia en MongoDB. @DBRef val categoria: Categoria @CompoundIndex Define \u00edndices compuestos en la colecci\u00f3n para optimizar consultas. @CompoundIndex(def = \"{'nombre': 1, 'precio': -1}\", unique = true) * def: Define los campos que forman el \u00edndice. * unique: Indica si el \u00edndice debe ser \u00fanico.","title":"\ud83d\udd39Anotaciones comunes"},{"location":"SpringData/#aplicacion-spring-data-mongodb","text":"En este apartado del tema ya tenemos que saber como crear una aplicaic\u00f3n Spring Boot desde IntelliJ, solo necesitas saber las dependencias necesarias y las anotaciones para incorporar Spring Data MongoDB y poco m\u00e1s. El resto ya depende de lo que quieras construir con la base de datos. Para este ejemplo partiremos de un archivo json que contiene 10 men\u00fas con sus correspondientes platos. Has de a\u00f1adir este documento como una colecci\u00f3n a tu BD Mongo. Lo tienes disponible en la carpeta recursos y tambi\u00e9n lo puedes copiar directamente. Lo primero que debes hacer es insertar este archivo en tu MongoDB local, como una colecci\u00f3n (InsertMany) Archivo json con los menus: [ { \"_id\": \"1\", \"nombre\": \"Men\u00fa Mediterr\u00e1neo\", \"descripcion\": \"Un men\u00fa saludable inspirado en la dieta mediterr\u00e1nea.\", \"fecha\": \"2025-01-08\", \"platos\": [ { \"nombre\": \"Ensalada Griega\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Lechuga\", \"Tomate\", \"Pepino\", \"Aceitunas\", \"Queso Feta\"], \"precio\": 5.5 }, { \"nombre\": \"Moussaka\", \"categoria\": \"Principal\", \"ingredientes\": [\"Berenjena\", \"Carne de Cordero\", \"Tomate\", \"Bechamel\", \"Queso\"], \"precio\": 12.0 } ], \"precioTotal\": 17.5 }, { \"_id\": \"2\", \"nombre\": \"Men\u00fa Asi\u00e1tico\", \"descripcion\": \"Sabores frescos y aut\u00e9nticos de Asia.\", \"fecha\": \"2025-01-09\", \"platos\": [ { \"nombre\": \"Rollitos de Primavera\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Zanahoria\", \"Col\", \"Brotes de Soja\", \"Fideos de Arroz\"], \"precio\": 4.0 }, { \"nombre\": \"Pad Thai\", \"categoria\": \"Principal\", \"ingredientes\": [\"Fideos de Arroz\", \"Camarones\", \"Tofu\", \"Man\u00ed\"], \"precio\": 10.0 } ], \"precioTotal\": 14.0 }, { \"_id\": \"3\", \"nombre\": \"Men\u00fa Vegetariano\", \"descripcion\": \"Opciones deliciosas sin carne.\", \"fecha\": \"2025-01-10\", \"platos\": [ { \"nombre\": \"Hummus con Pan de Pita\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Garbanzos\", \"Tahini\", \"Lim\u00f3n\", \"Ajo\"], \"precio\": 4.5 }, { \"nombre\": \"Lasa\u00f1a Vegetariana\", \"categoria\": \"Principal\", \"ingredientes\": [\"Pasta\", \"Espinacas\", \"Ricotta\", \"Tomate\"], \"precio\": 9.0 } ], \"precioTotal\": 13.5 }, { \"_id\": \"4\", \"nombre\": \"Men\u00fa Italiano\", \"descripcion\": \"Especialidades cl\u00e1sicas de Italia.\", \"fecha\": \"2025-01-11\", \"platos\": [ { \"nombre\": \"Bruschetta\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Pan\", \"Tomate\", \"Albahaca\", \"Aceite de Oliva\"], \"precio\": 5.0 }, { \"nombre\": \"Pizza Margarita\", \"categoria\": \"Principal\", \"ingredientes\": [\"Masa de Pizza\", \"Tomate\", \"Mozzarella\", \"Albahaca\"], \"precio\": 10.0 } ], \"precioTotal\": 15.0 }, { \"_id\": \"5\", \"nombre\": \"Men\u00fa Mexicano\", \"descripcion\": \"Platos picantes y llenos de sabor.\", \"fecha\": \"2025-01-12\", \"platos\": [ { \"nombre\": \"Guacamole con Totopos\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Aguacate\", \"Lim\u00f3n\", \"Cilantro\", \"Totopos\"], \"precio\": 4.5 }, { \"nombre\": \"Tacos al Pastor\", \"categoria\": \"Principal\", \"ingredientes\": [\"Tortilla\", \"Carne de Cerdo\", \"Pi\u00f1a\", \"Cebolla\"], \"precio\": 9.0 } ], \"precioTotal\": 13.5 }, { \"_id\": \"6\", \"nombre\": \"Men\u00fa Americano\", \"descripcion\": \"Comida cl\u00e1sica de los Estados Unidos.\", \"fecha\": \"2025-01-13\", \"platos\": [ { \"nombre\": \"Alitas de Pollo\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Pollo\", \"Salsa BBQ\", \"Especias\"], \"precio\": 6.0 }, { \"nombre\": \"Hamburguesa con Queso\", \"categoria\": \"Principal\", \"ingredientes\": [\"Pan\", \"Carne de Res\", \"Queso\", \"Lechuga\"], \"precio\": 10.0 } ], \"precioTotal\": 16.0 }, { \"_id\": \"7\", \"nombre\": \"Men\u00fa de Mariscos\", \"descripcion\": \"Frescos sabores del oc\u00e9ano.\", \"fecha\": \"2025-01-14\", \"platos\": [ { \"nombre\": \"C\u00f3ctel de Camarones\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Camarones\", \"Salsa C\u00f3ctel\", \"Lim\u00f3n\"], \"precio\": 7.0 }, { \"nombre\": \"Paella de Mariscos\", \"categoria\": \"Principal\", \"ingredientes\": [\"Arroz\", \"Camarones\", \"Mejillones\", \"Calamares\"], \"precio\": 12.0 } ], \"precioTotal\": 19.0 }, { \"_id\": \"8\", \"nombre\": \"Men\u00fa Franc\u00e9s\", \"descripcion\": \"Platos refinados y elegantes.\", \"fecha\": \"2025-01-15\", \"platos\": [ { \"nombre\": \"Quiche Lorraine\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Huevo\", \"Nata\", \"Tocino\", \"Queso Gruy\u00e8re\"], \"precio\": 6.5 }, { \"nombre\": \"Ratatouille\", \"categoria\": \"Principal\", \"ingredientes\": [\"Berenjena\", \"Calabac\u00edn\", \"Tomate\", \"Pimiento\"], \"precio\": 9.5 } ], \"precioTotal\": 16.0 }, { \"_id\": \"9\", \"nombre\": \"Men\u00fa Indio\", \"descripcion\": \"Sabores especiados y ex\u00f3ticos.\", \"fecha\": \"2025-01-16\", \"platos\": [ { \"nombre\": \"Samosas\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Papas\", \"Especias\", \"Masa Frita\"], \"precio\": 4.0 }, { \"nombre\": \"Pollo Tikka Masala\", \"categoria\": \"Principal\", \"ingredientes\": [\"Pollo\", \"Salsa de Tomate\", \"Especias\", \"Crema\"], \"precio\": 11.0 } ], \"precioTotal\": 15.0 }, { \"_id\": \"10\", \"nombre\": \"Men\u00fa Japon\u00e9s\", \"descripcion\": \"Delicados sabores de Jap\u00f3n.\", \"fecha\": \"2025-01-17\", \"platos\": [ { \"nombre\": \"Sopa de Miso\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Miso\", \"Tofu\", \"Alga Wakame\"], \"precio\": 3.5 }, { \"nombre\": \"Sushi Variado\", \"categoria\": \"Principal\", \"ingredientes\": [\"Arroz\", \"Pescado\", \"Alga Nori\", \"Vegetales\"], \"precio\": 12.5 } ], \"precioTotal\": 16.0 } ] Modelo MVC Lo siguiente ser\u00e1 crear la estructura del modelo MVC con los archivos necesarios. En la siguiene imagen podeis ver como quedar\u00e1: Modelo Los modelos son las clases que representan las colecciones en MongoDB. Menu.kt import org.springframework.data.annotation.Id import org.springframework.data.mongodb.core.mapping.Document @Document(collection = \"menus\") // Nombre de la colecci\u00f3n en MongoDB data class Menu( @Id val id: String, // Identificador \u00fanico del men\u00fa val nombre: String, // Nombre del men\u00fa val descripcion: String, // Descripci\u00f3n del men\u00fa val fecha: String, // Fecha asociada al men\u00fa val platos: List<Plato> = emptyList(), // Lista de platos val precioTotal: Double = 0.0 // Precio total del men\u00fa ) data class Plato( val nombre: String, val categoria: String, val ingredientes: List<String> = emptyList(), val precio: Double = 0.0 ) Repositorios Proporciona una interfaz MongoRepository que simplifica las operaciones CRUD. MenuRepository.kt import org.springframework.data.mongodb.repository.MongoRepository import org.springframework.stereotype.Repository import org.example.primerspringmongo.model.* @Repository interface MenuRepository : MongoRepository<Menu, String> { fun findByNombre(nombre: String): List<Menu> fun findByPlatosCategoria(categoria: String): List<Menu> } Controlador Gestiona las solicitudes entrantes, procesa datos y determina las respuestas adecuadas. MenuController.kt import org.example.primerspringmongo.model.Menu import org.example.primerspringmongo.repository.MenuRepository import org.springframework.stereotype.Controller import org.springframework.ui.Model import org.springframework.web.bind.annotation.* @Controller @RequestMapping(\"/menus\") class MenuController(private val menuRepository: MenuRepository) { // Listar todos los men\u00fas @GetMapping fun listarMenus(model: Model): String { val menus = menuRepository.findAll() model.addAttribute(\"menus\", menus) return \"menus/listar\" } @GetMapping(\"/buscar\") fun buscarPorNombre(@RequestParam nombre: String, model: Model): String { val menus = menuRepository.findByNombre(nombre) // Consulta en el repositorio model.addAttribute(\"menus\", menus) // Pasar los men\u00fas al modelo model.addAttribute(\"nombre\", nombre) // Pasar el nombre buscado return \"menus/listar\" // Nombre de la plantilla Thymeleaf } // Guardar un nuevo men\u00fa @PostMapping(\"/guardar\") fun guardarMenu(@ModelAttribute menu: Menu): String { menuRepository.save(menu) return \"redirect:/menus\" } // Ver detalles de un men\u00fa @GetMapping(\"/{id}\") fun verDetalles(@PathVariable id: String, model: Model): String { val menu = menuRepository.findById(id) if (menu.isPresent) { model.addAttribute(\"menu\", menu.get()) return \"menus/detalles\" } return \"redirect:/menus\" } // Mostrar formulario para editar un men\u00fa @GetMapping(\"/editar/{id}\") fun mostrarFormularioEditar(@PathVariable id: String, model: Model): String { val menu = menuRepository.findById(id) if (menu.isPresent) { model.addAttribute(\"menu\", menu.get()) return \"menus/editar\" } return \"redirect:/menus\" } // Actualizar un men\u00fa existente @PostMapping(\"/actualizar/{id}\") fun actualizarMenu(@PathVariable id: String, @ModelAttribute menu: Menu): String { if (menuRepository.existsById(id)) { menuRepository.save(menu) } return \"redirect:/menus\" } // Eliminar un men\u00fa @GetMapping(\"/eliminar/{id}\") fun eliminarMenu(@PathVariable id: String): String { menuRepository.deleteById(id) return \"redirect:/menus\" } } PlatoController.kt import org.example.primerspringmongo.repository.MenuRepository import org.springframework.stereotype.Controller import org.springframework.ui.Model import org.springframework.web.bind.annotation.* @Controller @RequestMapping(\"/platos\") class PlatoController(private val menuRepository: MenuRepository) { // Listar todos los platos de un men\u00fa @GetMapping(\"/{menuId}\") fun listarPlatos(@PathVariable menuId: String, model: Model): String { val menu = menuRepository.findById(menuId) if (menu.isPresent) { model.addAttribute(\"menu\", menu.get()) model.addAttribute(\"platos\", menu.get().platos) return \"platos/listar\" } return \"redirect:/menus\" } @GetMapping(\"/categoria\") fun buscarPorCategoria(@RequestParam categoria: String, model: Model): String { val menus = menuRepository.findByPlatosCategoria(categoria) // Consulta en el repositorio model.addAttribute(\"menus\", menus) // Lista de men\u00fas encontrados model.addAttribute(\"categoriaBuscada\", categoria) // Categor\u00eda buscada return \"platos/buscarPorCategoria\" // Plantilla Thymeleaf } @GetMapping(\"/{menuId}/ingredientes/{platoNombre}\") fun verIngredientes( @PathVariable menuId: String, @PathVariable platoNombre: String, model: Model ): String { val menu = menuRepository.findById(menuId) if (menu.isPresent) { val plato = menu.get().platos.find { it.nombre == platoNombre } if (plato != null) { println(\"Plato encontrado: $plato\") println(\"Ingredientes: ${plato.ingredientes}\") model.addAttribute(\"menu\", menu.get()) model.addAttribute(\"plato\", plato) model.addAttribute(\"ingredientes\", plato.ingredientes ?: emptyList<String>()) return \"platos/ingredientes\" } } model.addAttribute(\"error\", \"El plato o el men\u00fa no existen.\") return \"error\" } } Vista Permiten visualizar los resultados con un formato personalizado. En la siguiente imagen ten\u00e9is la estructura de los archivos: Vistas para visualizar los menus: /menus listar.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Lista de Men\u00fas</title> </head> <body> <h1>Lista de Men\u00fas</h1> <a href=\"/menus/crear\">Crear Nuevo Men\u00fa</a> <table border=\"1\"> <thead> <tr> <th>Nombre</th> <th>Descripci\u00f3n</th> <th>Acciones</th> </tr> </thead> <tbody> <tr th:each=\"menu : ${menus}\"> <td th:text=\"${menu.nombre}\"></td> <td th:text=\"${menu.descripcion}\"></td> <td> <a th:href=\"@{'/menus/' + ${menu.id}}\">Detalles</a> <a th:href=\"@{'/menus/editar/' + ${menu.id}}\">Editar</a> <a th:href=\"@{'/menus/eliminar/' + ${menu.id}}\" onclick=\"return confirm('\u00bfSeguro que quieres eliminar este men\u00fa?')\">Eliminar</a> </td> </tr> </tbody> </table> </body> </html> crear.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Crear/Editar Men\u00fa</title> </head> <body> <h1 th:text=\"${#strings.equals(menu.id, '') ? 'Crear Nuevo Men\u00fa' : 'Editar Men\u00fa'}\"></h1> <form th:action=\"@{${#strings.equals(menu.id, '') ? '/menus/guardar' : '/menus/actualizar/' + menu.id}}\" th:object=\"${menu}\" method=\"post\"> <label for=\"nombre\">Nombre:</label> <input type=\"text\" id=\"nombre\" name=\"nombre\" th:value=\"${menu.nombre}\" required><br> <label for=\"descripcion\">Descripci\u00f3n:</label> <textarea id=\"descripcion\" name=\"descripcion\" th:text=\"${menu.descripcion}\" required></textarea><br> <label for=\"fecha\">Fecha:</label> <input type=\"date\" id=\"fecha\" name=\"fecha\" th:value=\"${menu.fecha}\" required><br> <label for=\"precioTotal\">Precio Total:</label> <input type=\"number\" id=\"precioTotal\" name=\"precioTotal\" th:value=\"${menu.precioTotal}\" step=\"0.01\" required><br> <button type=\"submit\">Guardar</button> <a href=\"/menus\">Cancelar</a> </form> </body> </html> detalles.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Detalles del Men\u00fa</title> </head> <body> <h1>Detalles del Men\u00fa</h1> <p><strong>Nombre:</strong> <span th:text=\"${menu.nombre}\"></span></p> <p><strong>Descripci\u00f3n:</strong> <span th:text=\"${menu.descripcion}\"></span></p> <p><strong>Fecha:</strong> <span th:text=\"${menu.fecha}\"></span></p> <p><strong>Precio Total:</strong> <span th:text=\"${menu.precioTotal}\"></span></p> <h2>Platos</h2> <ul> <li th:each=\"plato : ${menu.platos}\"> <strong th:text=\"${plato.nombre}\"></strong> - <span th:text=\"${plato.categoria}\"></span> (<span th:text=\"${plato.precio}\"></span> \u20ac) </li> </ul> <a href=\"/menus\">Volver</a> </body> </html> editar.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Crear/Editar Men\u00fa</title> </head> <body> <h1 th:text=\"${#strings.equals(menu.id, '') ? 'Crear Nuevo Men\u00fa' : 'Editar Men\u00fa'}\"></h1> <form th:action=\"@{${#strings.equals(menu.id, '') ? '/menus/guardar' : '/menus/actualizar/' + menu.id}}\" th:object=\"${menu}\" method=\"post\"> <label for=\"nombre\">Nombre:</label> <input type=\"text\" id=\"nombre\" name=\"nombre\" th:value=\"${menu.nombre}\" required><br> <label for=\"descripcion\">Descripci\u00f3n:</label> <textarea id=\"descripcion\" name=\"descripcion\" th:text=\"${menu.descripcion}\" required></textarea><br> <label for=\"fecha\">Fecha:</label> <input type=\"date\" id=\"fecha\" name=\"fecha\" th:value=\"${menu.fecha}\" required><br> <label for=\"precioTotal\">Precio Total:</label> <input type=\"number\" id=\"precioTotal\" name=\"precioTotal\" th:value=\"${menu.precioTotal}\" step=\"0.01\" required><br> <button type=\"submit\">Guardar</button> <a href=\"/menus\">Cancelar</a> </form> </body> </html> Vistas para visualizar los platos: /platos listar.kt <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Platos del Men\u00fa</title> </head> <body> <h1 th:text=\"'Platos del Men\u00fa: ' + ${menu.nombre}\"></h1> <a th:href=\"@{/menus}\">Volver a Men\u00fas</a> <table border=\"1\"> <thead> <tr> <th>Nombre</th> <th>Categor\u00eda</th> <th>Precio</th> <th>Ingredientes</th> </tr> </thead> <tbody> <tr th:each=\"plato : ${platos}\"> <td th:text=\"${plato.nombre}\"></td> <td th:text=\"${plato.categoria}\"></td> <td th:text=\"${plato.precio} + ' \u20ac'\"></td> <td> <a th:href=\"@{'/platos/' + ${menu.id} + '/ingredientes/' + ${plato.nombre}}\">Ver Ingredientes</a> </td> </tr> </tbody> </table> </body> </html> ingredientes.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Ingredientes</title> </head> <body> <h1 th:text=\"'Ingredientes del plato: ' + ${plato?.nombre}\"></h1> <div th:if=\"${error}\"> <p th:text=\"${error}\" style=\"color: red;\"></p> </div> <ul th:if=\"${ingredientes != null && !ingredientes.isEmpty()}\"> <li th:each=\"ingrediente : ${ingredientes}\" th:text=\"${ingrediente}\"></li> </ul> <p th:if=\"${ingredientes == null || ingredientes.isEmpty()}\" style=\"color: gray;\"> No hay ingredientes disponibles para este plato. </p> <a th:href=\"@{'/platos/' + ${menu.id}}\">Volver a los platos</a> </body> </html> buscarPorCategoria.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Buscar Men\u00fas por Categor\u00eda</title> </head> <body> <h1>Resultados para categor\u00eda: <span th:text=\"${categoriaBuscada}\"></span></h1> <table border=\"1\" th:if=\"${menus}\"> <thead> <tr> <th>ID</th> <th>Nombre</th> <th>Descripci\u00f3n</th> <th>Platos</th> </tr> </thead> <tbody> <tr th:each=\"menu : ${menus}\"> <td th:text=\"${menu.id}\"></td> <td th:text=\"${menu.nombre}\"></td> <td th:text=\"${menu.descripcion}\"></td> <td> <ul> <li th:each=\"plato : ${menu.platos}\" th:if=\"${plato.categoria == categoriaBuscada}\" th:text=\"${plato.nombre}\"></li> </ul> </td> </tr> </tbody> </table> <p th:if=\"${menus == null || menus.isEmpty()}\" style=\"color: gray;\"> No se encontraron men\u00fas con platos de la categor\u00eda <span th:text=\"${categoriaBuscada}\"></span>. </p> <a href=\"/menus\">Volver a la lista de men\u00fas</a> </body> </html> Con esta configuraci\u00f3n podemos listar los siguientes ejemplos: http://localhost:8888/menus : Lista todos los men\u00fas http://localhost:8888/menus/buscar?nombre=Men\u00fa Vegetariano: Busca un men\u00fa concreto. http://localhost:8888/platos/1: Lista los platos del men\u00fa 1. http://localhost:8888/platos/1/ingredientes/Ensalada Griega: Lista los ingredients del plato del men\u00fa 1. Nota Estos son alugunos ejemplos pero pod\u00e9is modificar el controlador y crear nuevas vistas para a\u00f1adir funcionalidad al programa y que muestre m\u00e1s resultados.","title":"\ud83d\udd39Aplicaci\u00f3n Spring Data MongoDB"},{"location":"SpringMVC/","text":"\ud83d\udd39Spring MVC \u00b6 Spring MVC es el m\u00f3dulo de Spring orientado al desarrollo de aplicaciones web siguiendo el patr\u00f3n Modelo\u2011Vista\u2011Controlador . El ejemplo visto en Spring Boot es tan sencillo que no necesita un patr\u00f3n de dise\u00f1o especial. Para aplicaciones m\u00e1s complejas necesitamos de un patr\u00f3n que nos permita crear aplicaciones con un c\u00f3digo bien estructurado y m\u00e1s f\u00e1cil de modificar, as\u00ed como reutilizar sus componentes en diferentes puntos de la aplicaci\u00f3n y que puedan evolucionar de manera independiente. Spring MVC forma parte del ecosistema Spring y proporciona toda la infraestructura necesaria para manejar peticiones HTTP, invocar controladores y devolver vistas (HTML, JSON, etc.). El Modelo-Vista-Controlador (MVC) El Modelo-Vista-Controlador (MVC) es un patr\u00f3n de dise\u00f1o que organiza una aplicaci\u00f3n en tres componentes principales : Modelo : Son los datos. Es responsable de: Gestionar el estado de la aplicaci\u00f3n. Interactuar con la base de datos u otros servicios para obtener y procesar datos. Proveer datos a la vista. Vista : Es lo que ve el usuario. Es responsable de: Renderizar informaci\u00f3n en un formato adecuado, como HTML. Mostrar al usuario los resultados de las acciones ejecutadas. Controlador : Act\u00faa como intermediario entre el modelo y la vista. Es responsable de: Procesar las solicitudes del usuario (peticiones HTTP). Interactuar con el modelo para obtener o modificar datos. Seleccionar y devolver la vista adecuada para responder al usuario. Flujo de trabajo en MVC 1) El usuario interact\u00faa con la interfaz (Vista), como enviar un formulario o hacer clic en un enlace. 2) La petici\u00f3n es enviada al Controlador. 3) El Controlador procesa la petici\u00f3n, interact\u00faa con el Modelo si es necesario, y selecciona la Vista que debe renderizar la respuesta. 4) La Vista presenta la respuesta al usuario. Arquitectura en capas en Spring Spring se organiza siguiendo una arquitectura en capas, cuyo objetivo principal es separar responsabilidades. Cada capa tiene una funci\u00f3n concreta y se comunica \u00fanicamente con las capas adyacentes, lo que permite aplicaciones m\u00e1s mantenibles, escalables y f\u00e1ciles de entender. Las capas m\u00e1s habituales en una aplicaci\u00f3n Spring son: Capa Controller (Web) Capa Service (Negocio) Capa Repository (Persistencia) Capa Model (Dominio / Entidades) Capa View (Representaci\u00f3n) \ud83d\udccc Esta arquitectura encaja perfectamente con el patr\u00f3n MVC (Model\u2013View\u2013Controller). Correspondencia Spring \u2194 MVC Capa Spring MVC Responsabilidad principal Detalles Controller Controller Gestiona las peticiones HTTP \u2022 Recibe peticiones HTTP \u2022 Extrae par\u00e1metros \u2022 Llama a la capa Service \u2022 Devuelve una vista o una respuesta (JSON) \ud83d\udccc No contiene l\u00f3gica de negocio ni acceso a datos Model (Entity) Model Representa los datos del dominio \u2022 Clases que modelan la informaci\u00f3n del negocio Service Model L\u00f3gica de negocio \u2022 Aplica reglas y validaciones \u2022 Realiza operaciones del negocio \u2022 Coordina repositorios Repository Model Persistencia de datos \u2022 Acceso a la base de datos \u2022 Operaciones CRUD \u2022 A\u00edsla la BD del resto de la aplicaci\u00f3n View View Representaci\u00f3n de los datos \u2022 HTML (Thymeleaf, JSP) en apps web tradicionales \u2022 JSON / XML en apps REST \ud83d\udccc En REST, el JSON act\u00faa como la vista Anotaciones habituales por capa Capa MVC Capas Spring incluidas Anotaciones habituales Funci\u00f3n Controller Controller @Controller @RestController @RequestMapping @GetMapping @RequestParam @PostMapping @PutMapping @DeleteMapping Recibe peticiones HTTP, gestiona rutas y par\u00e1metros, llama a Service y devuelve la respuesta Model Entity Service Repository @Entity , @Table , @Id @Service , @Transactional @Repository Contiene los datos del dominio, la l\u00f3gica de negocio y el acceso a la base de datos View HTML / JSON (sin anotaciones) Representa los datos al usuario (HTML o JSON) La capa Vista En Spring MVC, la vista puede ser una respuesta JSON en una API REST o un HTML generado con Thymeleaf ; en ambos casos, cumple la funci\u00f3n de View dentro del patr\u00f3n MVC. \ud83e\uddfe Vista sin Thymeleaf Si tu aplicaci\u00f3n no utiliza motores de plantillas y solo devuelve datos en formatos como JSON o XML , entonces las vistas suelen ser gestionadas directamente por el controlador. En este caso @RestController , en el controlador, garantiza que el contenido se devuelva en el formato adecuado, sin necesidad de vistas expl\u00edcitas. El contenido es generado din\u00e1micamente a trav\u00e9s de bibliotecas como Jackson (para JSON). Ejemplo Controlador REST @RestController @RequestMapping(\"/api\") class HolaRestController { @GetMapping(\"/hola\") fun hola(): Map<String, String> { return mapOf( \"mensaje\" to \"Hola Alicia\" ) } } URL http://localhost:8080/api/hola \ud83c\udf3f Vista con Thymeleaf Thymeleaf es un motor de plantillas para Java que permite mezclar HTML con datos que vienen del backend (Java/Kotlin) sin perder la estructura HTML. Ejemplo Controlador @Controller class HolaController { @GetMapping(\"/hola\") fun hola(model: Model): String { model.addAttribute(\"nombre\", \"Alicia\") return \"hola\" } } Vista <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <body> <h1 th:text=\"'Hola ' + ${nombre}\"></h1> </body> </html> Resultado en el navegador: Hola Alicia Si utilizas Thymeleaf para la vista, las anotaciones en los archivos de plantilla son prefijos para atributos de HTML. Estos prefijos permiten el manejo din\u00e1mico de datos en la vista. Atributos Thymeleaf m\u00e1s utilizados : th:text : Rellena el contenido de un elemento HTML con el valor din\u00e1mico. <p th:text=\"${mensaje}\">Mensaje por defecto</p> th:each : Itera sobre una colecci\u00f3n. <ul> <li th:each=\"item : ${items}\" th:text=\"${item}\"></li> </ul> Esto genera una lista basada en los elementos de la colecci\u00f3n items. th:if y th:unless : Renderiza un contenido condicionalmente. <p th:if=\"${condicion}\">Esto se muestra si la condici\u00f3n es verdadera</p> <p th:unless=\"${condicion}\">Esto se muestra si la condici\u00f3n es falsa</p> th:href y th:src : Construye enlaces din\u00e1micos para atributos como href o src. <a th:href=\"@{/ruta/{id}(id=${itemId})}\">Ver detalle</a> <img th:src=\"@{/imagenes/logo.png}\" alt=\"Logo\"> th:action : Define la URL para un formulario. <form th:action=\"@{/procesar}\" method=\"post\"> <input type=\"text\" name=\"nombre\"> <button type=\"submit\">Enviar</button> </form> th:value y th:field : Usado para rellenar valores din\u00e1micos en campos de formulario. <input type=\"text\" th:field=\"*{nombre}\" /> \ud83d\udd39Ejemplo con Spring MVC \u00b6 Al igual que se describe en el apartado de Spring Boot, podemos crear los proyectos Spring MVC de dos maneras: Mediante una herramienta web online ( https://start.spring.io/ ) denominada Spring Initializr , donde por medio de unos par\u00e1metros de configuraci\u00f3n, genera autom\u00e1ticamente un proyecto Maven o Gradle, seg\u00fan elijamos, en un archivo comprimido Zip, con la estructura de la aplicaci\u00f3n para ser importada directamente desde un IDE. Mediante un IDE, como Eclipse, IntelliJ...etc, teniendo instalados los plugins necesarios. En nuestro caso crearemos un proyecto Maven de Spring Boot en IntelliJ . La estructura general de un proyecto Spring MVC en IntelliJ ser\u00eda esta: Los pasos a seguir ser\u00edan: Configurar el proyecto A\u00f1adir las dependencias necesarias. Estructurar el proyecto en los componentes MVC. Configurar el fichero de propiedades. Ejecutar la aplicaci\u00f3n Enunciado de la aplicaci\u00f3n En este ejemplo vamos a crear una aplicaci\u00f3n sencilla que muestre una lista de nombres de personas, y tambi\u00e9n permita a\u00f1adir un nombre de persona nuevo. Todo mediantes Spring MVC y Thymeleaf . 1. Configurar el proyecto \ud83d\udd39 En IntelliJ creamos el proyecto y lo configuramos desde File-->New-->Project : Elige Spring Boot . Configura las siguientes opciones: Language: Kotlin Build System: Maven Especifica un nombre para el proyecto: PrimerSpringMVCsencillo \u00daltima versi\u00f3n de JDK \u00daltima versi\u00f3n de Java \ud83d\udd39 Posteriormente seleccionamos las dependencias necesarias: Spring Web (para el desarrollo de aplicaciones web) Thymeleaf (motor de plantillas para la vista) Spring Boot DevTools (opcional, para facilitar el desarrollo) Despu\u00e9s de aceptar, y si todo ha ido correctamente, ya tendremos nuestro proyecto creado y preparado para a\u00f1adir los elementos de programaci\u00f3n. Al iniciar nuestra aplicaci\u00f3n, lo primero que observamos es que se crea una clase PrimerSpringMVCsencilloApplication que sirve como contenedor para la configuraci\u00f3n de la aplicaci\u00f3n. No necesita implementar m\u00e9todos adicionales, ya que Spring Boot se encarga de todo gracias a la anotaci\u00f3n @SpringBootApplication . 2. Estructura del proyecto La estructura del proyecto podr\u00eda ser esta: En la carperta src/main/kotlin/org/example/primerspringmvcsencillo crearemos los paquetes: controller model service En la carperta src/main/resources/template crearemos la carpeta persona donde a\u00f1adiremos las vistas que muestren el resultado de la aplicaci\u00f3n. 3. Implementaci\u00f3n de la aplicaci\u00f3n Ahora ya podemos a\u00f1adir la programaci\u00f3n necesaria para nuestra aplicaci\u00f3n siguiendo la estructura MVC creada. Dentro de cada paquete crearemos los siguientes archivos: Model/Persona.kt : El modelo Persona es muy simple, solo tendr\u00e1 un nombre. package com.ejemplo.model data class Persona( val id: Int, val nombre: String ) Service/PersonaService.kt : El servicio se encargar\u00e1 de la l\u00f3gica de negocio. En este caso, solo vamos a mantener una lista de personas en memoria. package com.ejemplo.service import org.example.primerspringmvcsencllo.model.Persona import org.springframework.stereotype.Service @Service class PersonaService { private val personas = mutableListOf( Persona(1, \"Juan\"), Persona(2, \"Ana\"), Persona(3, \"Luis\") ) fun obtenerPersonas(): List<Persona> = personas fun agregarPersona(persona: Persona) { personas.add(persona) } } Controller/PersonaController.kt El controlador maneja las solicitudes de las vistas y realiza la interacci\u00f3n con el servicio. package com.ejemplo.controller import org.example.primerspringmvcsencllo.model.Persona import org.example.primerspringmvcsencllo.service.PersonaService import org.springframework.stereotype.Controller import org.springframework.ui.Model import org.springframework.web.bind.annotation.GetMapping import org.springframework.web.bind.annotation.PostMapping import org.springframework.web.bind.annotation.RequestParam @Controller class PersonaController(private val personaService: PersonaService) { @GetMapping(\"/personas\") fun listarPersonas(model: Model): String { model.addAttribute(\"personas\", personaService.obtenerPersonas()) return \"persona/listar\" } @GetMapping(\"/personas/agregar\") fun mostrarFormularioAgregar(): String { return \"persona/agregar\" } @PostMapping(\"/personas/agregar\") fun agregarPersona(@RequestParam nombre: String): String { val persona = Persona(0, nombre) // ID auto-generado personaService.agregarPersona(persona) return \"redirect:/personas\" } } Plantillas Thymeleaf Para la vista utilizaremos dos plantillas Thymeleaf, una para listar los nombres de la personas y otra para agregar una persona nueva. En la carpeta src/resources/templates/persona , crearemos los siguienes archivos html: a) Plantilla listar.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Lista de Personas</title> </head> <body> <h1>Lista de Personas</h1> <ul> <li th:each=\"persona : ${personas}\" th:text=\"${persona.nombre}\"></li> </ul> <a href=\"/personas/agregar\">Agregar Persona</a> </body> </html> b) Plantilla agregar.html Esta plantilla proporciona un formulario para agregar una nueva persona. <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Agregar Persona</title> </head> <body> <h1>Agregar Persona</h1> <form action=\"/personas/agregar\" method=\"post\"> <label for=\"nombre\">Nombre:</label> <input type=\"text\" id=\"nombre\" name=\"nombre\" required/> <button type=\"submit\">Agregar</button> </form> </body> </html> 4. Configurar el Archivo application.properties En el directorio src/main/resources, configura el archivo application.properties con las propiedades b\u00e1sicas: spring.thymeleaf.prefix=classpath:/templates/ spring.thymeleaf.suffix=.html server.port=8080 Recuerda que puedes cambiar el puerto si lo tienes ocupado. Puedes probar con el puerto 8888. 5. Ejecutar la aplicaci\u00f3n La aplicaci\u00f3n estar\u00e1 disponible en http://localhost:8080. Aqu\u00ed podr\u00e1s: Ver la lista de personas al acceder a /personas . Agregar una nueva persona a trav\u00e9s del formulario en /personas/agregar . Nota Gracias a Spring DevTools , cualquier cambio que realices en el c\u00f3digo (por ejemplo, en las plantillas o en los controladores) se reflejar\u00e1 autom\u00e1ticamente en la aplicaci\u00f3n sin tener que reiniciarla manualmente.","title":"\ud83d\udd39 Spring MVC"},{"location":"SpringMVC/#spring-mvc","text":"Spring MVC es el m\u00f3dulo de Spring orientado al desarrollo de aplicaciones web siguiendo el patr\u00f3n Modelo\u2011Vista\u2011Controlador . El ejemplo visto en Spring Boot es tan sencillo que no necesita un patr\u00f3n de dise\u00f1o especial. Para aplicaciones m\u00e1s complejas necesitamos de un patr\u00f3n que nos permita crear aplicaciones con un c\u00f3digo bien estructurado y m\u00e1s f\u00e1cil de modificar, as\u00ed como reutilizar sus componentes en diferentes puntos de la aplicaci\u00f3n y que puedan evolucionar de manera independiente. Spring MVC forma parte del ecosistema Spring y proporciona toda la infraestructura necesaria para manejar peticiones HTTP, invocar controladores y devolver vistas (HTML, JSON, etc.). El Modelo-Vista-Controlador (MVC) El Modelo-Vista-Controlador (MVC) es un patr\u00f3n de dise\u00f1o que organiza una aplicaci\u00f3n en tres componentes principales : Modelo : Son los datos. Es responsable de: Gestionar el estado de la aplicaci\u00f3n. Interactuar con la base de datos u otros servicios para obtener y procesar datos. Proveer datos a la vista. Vista : Es lo que ve el usuario. Es responsable de: Renderizar informaci\u00f3n en un formato adecuado, como HTML. Mostrar al usuario los resultados de las acciones ejecutadas. Controlador : Act\u00faa como intermediario entre el modelo y la vista. Es responsable de: Procesar las solicitudes del usuario (peticiones HTTP). Interactuar con el modelo para obtener o modificar datos. Seleccionar y devolver la vista adecuada para responder al usuario. Flujo de trabajo en MVC 1) El usuario interact\u00faa con la interfaz (Vista), como enviar un formulario o hacer clic en un enlace. 2) La petici\u00f3n es enviada al Controlador. 3) El Controlador procesa la petici\u00f3n, interact\u00faa con el Modelo si es necesario, y selecciona la Vista que debe renderizar la respuesta. 4) La Vista presenta la respuesta al usuario. Arquitectura en capas en Spring Spring se organiza siguiendo una arquitectura en capas, cuyo objetivo principal es separar responsabilidades. Cada capa tiene una funci\u00f3n concreta y se comunica \u00fanicamente con las capas adyacentes, lo que permite aplicaciones m\u00e1s mantenibles, escalables y f\u00e1ciles de entender. Las capas m\u00e1s habituales en una aplicaci\u00f3n Spring son: Capa Controller (Web) Capa Service (Negocio) Capa Repository (Persistencia) Capa Model (Dominio / Entidades) Capa View (Representaci\u00f3n) \ud83d\udccc Esta arquitectura encaja perfectamente con el patr\u00f3n MVC (Model\u2013View\u2013Controller). Correspondencia Spring \u2194 MVC Capa Spring MVC Responsabilidad principal Detalles Controller Controller Gestiona las peticiones HTTP \u2022 Recibe peticiones HTTP \u2022 Extrae par\u00e1metros \u2022 Llama a la capa Service \u2022 Devuelve una vista o una respuesta (JSON) \ud83d\udccc No contiene l\u00f3gica de negocio ni acceso a datos Model (Entity) Model Representa los datos del dominio \u2022 Clases que modelan la informaci\u00f3n del negocio Service Model L\u00f3gica de negocio \u2022 Aplica reglas y validaciones \u2022 Realiza operaciones del negocio \u2022 Coordina repositorios Repository Model Persistencia de datos \u2022 Acceso a la base de datos \u2022 Operaciones CRUD \u2022 A\u00edsla la BD del resto de la aplicaci\u00f3n View View Representaci\u00f3n de los datos \u2022 HTML (Thymeleaf, JSP) en apps web tradicionales \u2022 JSON / XML en apps REST \ud83d\udccc En REST, el JSON act\u00faa como la vista Anotaciones habituales por capa Capa MVC Capas Spring incluidas Anotaciones habituales Funci\u00f3n Controller Controller @Controller @RestController @RequestMapping @GetMapping @RequestParam @PostMapping @PutMapping @DeleteMapping Recibe peticiones HTTP, gestiona rutas y par\u00e1metros, llama a Service y devuelve la respuesta Model Entity Service Repository @Entity , @Table , @Id @Service , @Transactional @Repository Contiene los datos del dominio, la l\u00f3gica de negocio y el acceso a la base de datos View HTML / JSON (sin anotaciones) Representa los datos al usuario (HTML o JSON) La capa Vista En Spring MVC, la vista puede ser una respuesta JSON en una API REST o un HTML generado con Thymeleaf ; en ambos casos, cumple la funci\u00f3n de View dentro del patr\u00f3n MVC. \ud83e\uddfe Vista sin Thymeleaf Si tu aplicaci\u00f3n no utiliza motores de plantillas y solo devuelve datos en formatos como JSON o XML , entonces las vistas suelen ser gestionadas directamente por el controlador. En este caso @RestController , en el controlador, garantiza que el contenido se devuelva en el formato adecuado, sin necesidad de vistas expl\u00edcitas. El contenido es generado din\u00e1micamente a trav\u00e9s de bibliotecas como Jackson (para JSON). Ejemplo Controlador REST @RestController @RequestMapping(\"/api\") class HolaRestController { @GetMapping(\"/hola\") fun hola(): Map<String, String> { return mapOf( \"mensaje\" to \"Hola Alicia\" ) } } URL http://localhost:8080/api/hola \ud83c\udf3f Vista con Thymeleaf Thymeleaf es un motor de plantillas para Java que permite mezclar HTML con datos que vienen del backend (Java/Kotlin) sin perder la estructura HTML. Ejemplo Controlador @Controller class HolaController { @GetMapping(\"/hola\") fun hola(model: Model): String { model.addAttribute(\"nombre\", \"Alicia\") return \"hola\" } } Vista <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <body> <h1 th:text=\"'Hola ' + ${nombre}\"></h1> </body> </html> Resultado en el navegador: Hola Alicia Si utilizas Thymeleaf para la vista, las anotaciones en los archivos de plantilla son prefijos para atributos de HTML. Estos prefijos permiten el manejo din\u00e1mico de datos en la vista. Atributos Thymeleaf m\u00e1s utilizados : th:text : Rellena el contenido de un elemento HTML con el valor din\u00e1mico. <p th:text=\"${mensaje}\">Mensaje por defecto</p> th:each : Itera sobre una colecci\u00f3n. <ul> <li th:each=\"item : ${items}\" th:text=\"${item}\"></li> </ul> Esto genera una lista basada en los elementos de la colecci\u00f3n items. th:if y th:unless : Renderiza un contenido condicionalmente. <p th:if=\"${condicion}\">Esto se muestra si la condici\u00f3n es verdadera</p> <p th:unless=\"${condicion}\">Esto se muestra si la condici\u00f3n es falsa</p> th:href y th:src : Construye enlaces din\u00e1micos para atributos como href o src. <a th:href=\"@{/ruta/{id}(id=${itemId})}\">Ver detalle</a> <img th:src=\"@{/imagenes/logo.png}\" alt=\"Logo\"> th:action : Define la URL para un formulario. <form th:action=\"@{/procesar}\" method=\"post\"> <input type=\"text\" name=\"nombre\"> <button type=\"submit\">Enviar</button> </form> th:value y th:field : Usado para rellenar valores din\u00e1micos en campos de formulario. <input type=\"text\" th:field=\"*{nombre}\" />","title":"\ud83d\udd39Spring MVC"},{"location":"SpringMVC/#ejemplo-con-spring-mvc","text":"Al igual que se describe en el apartado de Spring Boot, podemos crear los proyectos Spring MVC de dos maneras: Mediante una herramienta web online ( https://start.spring.io/ ) denominada Spring Initializr , donde por medio de unos par\u00e1metros de configuraci\u00f3n, genera autom\u00e1ticamente un proyecto Maven o Gradle, seg\u00fan elijamos, en un archivo comprimido Zip, con la estructura de la aplicaci\u00f3n para ser importada directamente desde un IDE. Mediante un IDE, como Eclipse, IntelliJ...etc, teniendo instalados los plugins necesarios. En nuestro caso crearemos un proyecto Maven de Spring Boot en IntelliJ . La estructura general de un proyecto Spring MVC en IntelliJ ser\u00eda esta: Los pasos a seguir ser\u00edan: Configurar el proyecto A\u00f1adir las dependencias necesarias. Estructurar el proyecto en los componentes MVC. Configurar el fichero de propiedades. Ejecutar la aplicaci\u00f3n Enunciado de la aplicaci\u00f3n En este ejemplo vamos a crear una aplicaci\u00f3n sencilla que muestre una lista de nombres de personas, y tambi\u00e9n permita a\u00f1adir un nombre de persona nuevo. Todo mediantes Spring MVC y Thymeleaf . 1. Configurar el proyecto \ud83d\udd39 En IntelliJ creamos el proyecto y lo configuramos desde File-->New-->Project : Elige Spring Boot . Configura las siguientes opciones: Language: Kotlin Build System: Maven Especifica un nombre para el proyecto: PrimerSpringMVCsencillo \u00daltima versi\u00f3n de JDK \u00daltima versi\u00f3n de Java \ud83d\udd39 Posteriormente seleccionamos las dependencias necesarias: Spring Web (para el desarrollo de aplicaciones web) Thymeleaf (motor de plantillas para la vista) Spring Boot DevTools (opcional, para facilitar el desarrollo) Despu\u00e9s de aceptar, y si todo ha ido correctamente, ya tendremos nuestro proyecto creado y preparado para a\u00f1adir los elementos de programaci\u00f3n. Al iniciar nuestra aplicaci\u00f3n, lo primero que observamos es que se crea una clase PrimerSpringMVCsencilloApplication que sirve como contenedor para la configuraci\u00f3n de la aplicaci\u00f3n. No necesita implementar m\u00e9todos adicionales, ya que Spring Boot se encarga de todo gracias a la anotaci\u00f3n @SpringBootApplication . 2. Estructura del proyecto La estructura del proyecto podr\u00eda ser esta: En la carperta src/main/kotlin/org/example/primerspringmvcsencillo crearemos los paquetes: controller model service En la carperta src/main/resources/template crearemos la carpeta persona donde a\u00f1adiremos las vistas que muestren el resultado de la aplicaci\u00f3n. 3. Implementaci\u00f3n de la aplicaci\u00f3n Ahora ya podemos a\u00f1adir la programaci\u00f3n necesaria para nuestra aplicaci\u00f3n siguiendo la estructura MVC creada. Dentro de cada paquete crearemos los siguientes archivos: Model/Persona.kt : El modelo Persona es muy simple, solo tendr\u00e1 un nombre. package com.ejemplo.model data class Persona( val id: Int, val nombre: String ) Service/PersonaService.kt : El servicio se encargar\u00e1 de la l\u00f3gica de negocio. En este caso, solo vamos a mantener una lista de personas en memoria. package com.ejemplo.service import org.example.primerspringmvcsencllo.model.Persona import org.springframework.stereotype.Service @Service class PersonaService { private val personas = mutableListOf( Persona(1, \"Juan\"), Persona(2, \"Ana\"), Persona(3, \"Luis\") ) fun obtenerPersonas(): List<Persona> = personas fun agregarPersona(persona: Persona) { personas.add(persona) } } Controller/PersonaController.kt El controlador maneja las solicitudes de las vistas y realiza la interacci\u00f3n con el servicio. package com.ejemplo.controller import org.example.primerspringmvcsencllo.model.Persona import org.example.primerspringmvcsencllo.service.PersonaService import org.springframework.stereotype.Controller import org.springframework.ui.Model import org.springframework.web.bind.annotation.GetMapping import org.springframework.web.bind.annotation.PostMapping import org.springframework.web.bind.annotation.RequestParam @Controller class PersonaController(private val personaService: PersonaService) { @GetMapping(\"/personas\") fun listarPersonas(model: Model): String { model.addAttribute(\"personas\", personaService.obtenerPersonas()) return \"persona/listar\" } @GetMapping(\"/personas/agregar\") fun mostrarFormularioAgregar(): String { return \"persona/agregar\" } @PostMapping(\"/personas/agregar\") fun agregarPersona(@RequestParam nombre: String): String { val persona = Persona(0, nombre) // ID auto-generado personaService.agregarPersona(persona) return \"redirect:/personas\" } } Plantillas Thymeleaf Para la vista utilizaremos dos plantillas Thymeleaf, una para listar los nombres de la personas y otra para agregar una persona nueva. En la carpeta src/resources/templates/persona , crearemos los siguienes archivos html: a) Plantilla listar.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Lista de Personas</title> </head> <body> <h1>Lista de Personas</h1> <ul> <li th:each=\"persona : ${personas}\" th:text=\"${persona.nombre}\"></li> </ul> <a href=\"/personas/agregar\">Agregar Persona</a> </body> </html> b) Plantilla agregar.html Esta plantilla proporciona un formulario para agregar una nueva persona. <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Agregar Persona</title> </head> <body> <h1>Agregar Persona</h1> <form action=\"/personas/agregar\" method=\"post\"> <label for=\"nombre\">Nombre:</label> <input type=\"text\" id=\"nombre\" name=\"nombre\" required/> <button type=\"submit\">Agregar</button> </form> </body> </html> 4. Configurar el Archivo application.properties En el directorio src/main/resources, configura el archivo application.properties con las propiedades b\u00e1sicas: spring.thymeleaf.prefix=classpath:/templates/ spring.thymeleaf.suffix=.html server.port=8080 Recuerda que puedes cambiar el puerto si lo tienes ocupado. Puedes probar con el puerto 8888. 5. Ejecutar la aplicaci\u00f3n La aplicaci\u00f3n estar\u00e1 disponible en http://localhost:8080. Aqu\u00ed podr\u00e1s: Ver la lista de personas al acceder a /personas . Agregar una nueva persona a trav\u00e9s del formulario en /personas/agregar . Nota Gracias a Spring DevTools , cualquier cambio que realices en el c\u00f3digo (por ejemplo, en las plantillas o en los controladores) se reflejar\u00e1 autom\u00e1ticamente en la aplicaci\u00f3n sin tener que reiniciarla manualmente.","title":"\ud83d\udd39Ejemplo con Spring MVC"},{"location":"SpringMongo/","text":"Spring MongoDb \u00b6 Spring MongoDb Es un m\u00f3dulo de Spring Data que facilita la integraci\u00f3n de aplicaciones Spring con MongoDB. Adem\u00e1s proporciona una abstracci\u00f3n sobre las operaciones b\u00e1sicas de MongoDB como CRUD, consultas personalizadas, y soporte para agregaciones. Requisitos Tener MongoDB instalado o utilizar una instancia en la nube o en un contenedor Docker. Spring Boot configurado con Maven (en nuestro caso) o Gradle. Dependencias Maven <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-data-mongodb</artifactId> </dependency> application.properties spring.data.mongodb.host=localhost spring.data.mongodb.port=27017 spring.data.mongodb.database=nombre_base_de_datos Si est\u00e1s usando MongoDB con autenticaci\u00f3n, a\u00f1ade: spring.data.mongodb.username=usuario spring.data.mongodb.password=contrase\u00f1a Ejemplo: Men\u00fas \u00b6 En este ejemplo partiremos de un archivo json con 10 men\u00fas y sus correspondientes platos. Has de a\u00f1adir este documento como una colecci\u00f3n a tu BD Mongo. Archivo json con los menus: [ { \"_id\": \"1\", \"nombre\": \"Men\u00fa Mediterr\u00e1neo\", \"descripcion\": \"Un men\u00fa saludable inspirado en la dieta mediterr\u00e1nea.\", \"fecha\": \"2025-01-08\", \"platos\": [ { \"nombre\": \"Ensalada Griega\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Lechuga\", \"Tomate\", \"Pepino\", \"Aceitunas\", \"Queso Feta\"], \"precio\": 5.5 }, { \"nombre\": \"Moussaka\", \"categoria\": \"Principal\", \"ingredientes\": [\"Berenjena\", \"Carne de Cordero\", \"Tomate\", \"Bechamel\", \"Queso\"], \"precio\": 12.0 } ], \"precioTotal\": 17.5 }, { \"_id\": \"2\", \"nombre\": \"Men\u00fa Asi\u00e1tico\", \"descripcion\": \"Sabores frescos y aut\u00e9nticos de Asia.\", \"fecha\": \"2025-01-09\", \"platos\": [ { \"nombre\": \"Rollitos de Primavera\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Zanahoria\", \"Col\", \"Brotes de Soja\", \"Fideos de Arroz\"], \"precio\": 4.0 }, { \"nombre\": \"Pad Thai\", \"categoria\": \"Principal\", \"ingredientes\": [\"Fideos de Arroz\", \"Camarones\", \"Tofu\", \"Man\u00ed\"], \"precio\": 10.0 } ], \"precioTotal\": 14.0 }, { \"_id\": \"3\", \"nombre\": \"Men\u00fa Vegetariano\", \"descripcion\": \"Opciones deliciosas sin carne.\", \"fecha\": \"2025-01-10\", \"platos\": [ { \"nombre\": \"Hummus con Pan de Pita\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Garbanzos\", \"Tahini\", \"Lim\u00f3n\", \"Ajo\"], \"precio\": 4.5 }, { \"nombre\": \"Lasa\u00f1a Vegetariana\", \"categoria\": \"Principal\", \"ingredientes\": [\"Pasta\", \"Espinacas\", \"Ricotta\", \"Tomate\"], \"precio\": 9.0 } ], \"precioTotal\": 13.5 }, { \"_id\": \"4\", \"nombre\": \"Men\u00fa Italiano\", \"descripcion\": \"Especialidades cl\u00e1sicas de Italia.\", \"fecha\": \"2025-01-11\", \"platos\": [ { \"nombre\": \"Bruschetta\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Pan\", \"Tomate\", \"Albahaca\", \"Aceite de Oliva\"], \"precio\": 5.0 }, { \"nombre\": \"Pizza Margarita\", \"categoria\": \"Principal\", \"ingredientes\": [\"Masa de Pizza\", \"Tomate\", \"Mozzarella\", \"Albahaca\"], \"precio\": 10.0 } ], \"precioTotal\": 15.0 }, { \"_id\": \"5\", \"nombre\": \"Men\u00fa Mexicano\", \"descripcion\": \"Platos picantes y llenos de sabor.\", \"fecha\": \"2025-01-12\", \"platos\": [ { \"nombre\": \"Guacamole con Totopos\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Aguacate\", \"Lim\u00f3n\", \"Cilantro\", \"Totopos\"], \"precio\": 4.5 }, { \"nombre\": \"Tacos al Pastor\", \"categoria\": \"Principal\", \"ingredientes\": [\"Tortilla\", \"Carne de Cerdo\", \"Pi\u00f1a\", \"Cebolla\"], \"precio\": 9.0 } ], \"precioTotal\": 13.5 }, { \"_id\": \"6\", \"nombre\": \"Men\u00fa Americano\", \"descripcion\": \"Comida cl\u00e1sica de los Estados Unidos.\", \"fecha\": \"2025-01-13\", \"platos\": [ { \"nombre\": \"Alitas de Pollo\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Pollo\", \"Salsa BBQ\", \"Especias\"], \"precio\": 6.0 }, { \"nombre\": \"Hamburguesa con Queso\", \"categoria\": \"Principal\", \"ingredientes\": [\"Pan\", \"Carne de Res\", \"Queso\", \"Lechuga\"], \"precio\": 10.0 } ], \"precioTotal\": 16.0 }, { \"_id\": \"7\", \"nombre\": \"Men\u00fa de Mariscos\", \"descripcion\": \"Frescos sabores del oc\u00e9ano.\", \"fecha\": \"2025-01-14\", \"platos\": [ { \"nombre\": \"C\u00f3ctel de Camarones\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Camarones\", \"Salsa C\u00f3ctel\", \"Lim\u00f3n\"], \"precio\": 7.0 }, { \"nombre\": \"Paella de Mariscos\", \"categoria\": \"Principal\", \"ingredientes\": [\"Arroz\", \"Camarones\", \"Mejillones\", \"Calamares\"], \"precio\": 12.0 } ], \"precioTotal\": 19.0 }, { \"_id\": \"8\", \"nombre\": \"Men\u00fa Franc\u00e9s\", \"descripcion\": \"Platos refinados y elegantes.\", \"fecha\": \"2025-01-15\", \"platos\": [ { \"nombre\": \"Quiche Lorraine\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Huevo\", \"Nata\", \"Tocino\", \"Queso Gruy\u00e8re\"], \"precio\": 6.5 }, { \"nombre\": \"Ratatouille\", \"categoria\": \"Principal\", \"ingredientes\": [\"Berenjena\", \"Calabac\u00edn\", \"Tomate\", \"Pimiento\"], \"precio\": 9.5 } ], \"precioTotal\": 16.0 }, { \"_id\": \"9\", \"nombre\": \"Men\u00fa Indio\", \"descripcion\": \"Sabores especiados y ex\u00f3ticos.\", \"fecha\": \"2025-01-16\", \"platos\": [ { \"nombre\": \"Samosas\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Papas\", \"Especias\", \"Masa Frita\"], \"precio\": 4.0 }, { \"nombre\": \"Pollo Tikka Masala\", \"categoria\": \"Principal\", \"ingredientes\": [\"Pollo\", \"Salsa de Tomate\", \"Especias\", \"Crema\"], \"precio\": 11.0 } ], \"precioTotal\": 15.0 }, { \"_id\": \"10\", \"nombre\": \"Men\u00fa Japon\u00e9s\", \"descripcion\": \"Delicados sabores de Jap\u00f3n.\", \"fecha\": \"2025-01-17\", \"platos\": [ { \"nombre\": \"Sopa de Miso\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Miso\", \"Tofu\", \"Alga Wakame\"], \"precio\": 3.5 }, { \"nombre\": \"Sushi Variado\", \"categoria\": \"Principal\", \"ingredientes\": [\"Arroz\", \"Pescado\", \"Alga Nori\", \"Vegetales\"], \"precio\": 12.5 } ], \"precioTotal\": 16.0 } ] Modelo MVC Modelo Los modelos son las clases que representan las colecciones en MongoDB. Deben incluir la anotaci\u00f3n @Document . Menu.kt import org.springframework.data.annotation.Id import org.springframework.data.mongodb.core.mapping.Document @Document(collection = \"menus\") // Nombre de la colecci\u00f3n en MongoDB data class Menu( @Id val id: String, // Identificador \u00fanico del men\u00fa val nombre: String, // Nombre del men\u00fa val descripcion: String, // Descripci\u00f3n del men\u00fa val fecha: String, // Fecha asociada al men\u00fa val platos: List<Plato> = emptyList(), // Lista de platos val precioTotal: Double = 0.0 // Precio total del men\u00fa ) data class Plato( val nombre: String, val categoria: String, val ingredientes: List<String> = emptyList(), val precio: Double = 0.0 ) Repositorios proporciona una interfaz MongoRepository que simplifica las operaciones CRUD. MenuRepository.kt import org.springframework.data.mongodb.repository.MongoRepository import org.springframework.stereotype.Repository import org.example.primerspringmongo.model.* @Repository interface MenuRepository : MongoRepository<Menu, String> { fun findByNombre(nombre: String): List<Menu> fun findByPlatosCategoria(categoria: String): List<Menu> } Controlador MenuController.kt import org.example.primerspringmongo.model.Menu import org.example.primerspringmongo.repository.MenuRepository import org.springframework.stereotype.Controller import org.springframework.ui.Model import org.springframework.web.bind.annotation.* @Controller @RequestMapping(\"/menus\") class MenuController(private val menuRepository: MenuRepository) { // Listar todos los men\u00fas @GetMapping fun listarMenus(model: Model): String { val menus = menuRepository.findAll() model.addAttribute(\"menus\", menus) return \"menus/listar\" } @GetMapping(\"/buscar\") fun buscarPorNombre(@RequestParam nombre: String, model: Model): String { val menus = menuRepository.findByNombre(nombre) // Consulta en el repositorio model.addAttribute(\"menus\", menus) // Pasar los men\u00fas al modelo model.addAttribute(\"nombre\", nombre) // Pasar el nombre buscado return \"menus/listar\" // Nombre de la plantilla Thymeleaf } // Guardar un nuevo men\u00fa @PostMapping(\"/guardar\") fun guardarMenu(@ModelAttribute menu: Menu): String { menuRepository.save(menu) return \"redirect:/menus\" } // Ver detalles de un men\u00fa @GetMapping(\"/{id}\") fun verDetalles(@PathVariable id: String, model: Model): String { val menu = menuRepository.findById(id) if (menu.isPresent) { model.addAttribute(\"menu\", menu.get()) return \"menus/detalles\" } return \"redirect:/menus\" } // Mostrar formulario para editar un men\u00fa @GetMapping(\"/editar/{id}\") fun mostrarFormularioEditar(@PathVariable id: String, model: Model): String { val menu = menuRepository.findById(id) if (menu.isPresent) { model.addAttribute(\"menu\", menu.get()) return \"menus/editar\" } return \"redirect:/menus\" } // Actualizar un men\u00fa existente @PostMapping(\"/actualizar/{id}\") fun actualizarMenu(@PathVariable id: String, @ModelAttribute menu: Menu): String { if (menuRepository.existsById(id)) { menuRepository.save(menu) } return \"redirect:/menus\" } // Eliminar un men\u00fa @GetMapping(\"/eliminar/{id}\") fun eliminarMenu(@PathVariable id: String): String { menuRepository.deleteById(id) return \"redirect:/menus\" } } PlatoController.kt import org.example.primerspringmongo.repository.MenuRepository import org.springframework.stereotype.Controller import org.springframework.ui.Model import org.springframework.web.bind.annotation.* @Controller @RequestMapping(\"/platos\") class PlatoController(private val menuRepository: MenuRepository) { // Listar todos los platos de un men\u00fa @GetMapping(\"/{menuId}\") fun listarPlatos(@PathVariable menuId: String, model: Model): String { val menu = menuRepository.findById(menuId) if (menu.isPresent) { model.addAttribute(\"menu\", menu.get()) model.addAttribute(\"platos\", menu.get().platos) return \"platos/listar\" } return \"redirect:/menus\" } @GetMapping(\"/categoria\") fun buscarPorCategoria(@RequestParam categoria: String, model: Model): String { val menus = menuRepository.findByPlatosCategoria(categoria) // Consulta en el repositorio model.addAttribute(\"menus\", menus) // Lista de men\u00fas encontrados model.addAttribute(\"categoriaBuscada\", categoria) // Categor\u00eda buscada return \"platos/buscarPorCategoria\" // Plantilla Thymeleaf } @GetMapping(\"/{menuId}/ingredientes/{platoNombre}\") fun verIngredientes( @PathVariable menuId: String, @PathVariable platoNombre: String, model: Model ): String { val menu = menuRepository.findById(menuId) if (menu.isPresent) { val plato = menu.get().platos.find { it.nombre == platoNombre } if (plato != null) { println(\"Plato encontrado: $plato\") println(\"Ingredientes: ${plato.ingredientes}\") model.addAttribute(\"menu\", menu.get()) model.addAttribute(\"plato\", plato) model.addAttribute(\"ingredientes\", plato.ingredientes ?: emptyList<String>()) return \"platos/ingredientes\" } } model.addAttribute(\"error\", \"El plato o el men\u00fa no existen.\") return \"error\" } } Vista templates/menus/ listar.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Lista de Men\u00fas</title> </head> <body> <h1>Lista de Men\u00fas</h1> <a href=\"/menus/crear\">Crear Nuevo Men\u00fa</a> <table border=\"1\"> <thead> <tr> <th>Nombre</th> <th>Descripci\u00f3n</th> <th>Acciones</th> </tr> </thead> <tbody> <tr th:each=\"menu : ${menus}\"> <td th:text=\"${menu.nombre}\"></td> <td th:text=\"${menu.descripcion}\"></td> <td> <a th:href=\"@{'/menus/' + ${menu.id}}\">Detalles</a> <a th:href=\"@{'/menus/editar/' + ${menu.id}}\">Editar</a> <a th:href=\"@{'/menus/eliminar/' + ${menu.id}}\" onclick=\"return confirm('\u00bfSeguro que quieres eliminar este men\u00fa?')\">Eliminar</a> </td> </tr> </tbody> </table> </body> </html> crear.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Crear/Editar Men\u00fa</title> </head> <body> <h1 th:text=\"${#strings.equals(menu.id, '') ? 'Crear Nuevo Men\u00fa' : 'Editar Men\u00fa'}\"></h1> <form th:action=\"@{${#strings.equals(menu.id, '') ? '/menus/guardar' : '/menus/actualizar/' + menu.id}}\" th:object=\"${menu}\" method=\"post\"> <label for=\"nombre\">Nombre:</label> <input type=\"text\" id=\"nombre\" name=\"nombre\" th:value=\"${menu.nombre}\" required><br> <label for=\"descripcion\">Descripci\u00f3n:</label> <textarea id=\"descripcion\" name=\"descripcion\" th:text=\"${menu.descripcion}\" required></textarea><br> <label for=\"fecha\">Fecha:</label> <input type=\"date\" id=\"fecha\" name=\"fecha\" th:value=\"${menu.fecha}\" required><br> <label for=\"precioTotal\">Precio Total:</label> <input type=\"number\" id=\"precioTotal\" name=\"precioTotal\" th:value=\"${menu.precioTotal}\" step=\"0.01\" required><br> <button type=\"submit\">Guardar</button> <a href=\"/menus\">Cancelar</a> </form> </body> </html> detalles.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Detalles del Men\u00fa</title> </head> <body> <h1>Detalles del Men\u00fa</h1> <p><strong>Nombre:</strong> <span th:text=\"${menu.nombre}\"></span></p> <p><strong>Descripci\u00f3n:</strong> <span th:text=\"${menu.descripcion}\"></span></p> <p><strong>Fecha:</strong> <span th:text=\"${menu.fecha}\"></span></p> <p><strong>Precio Total:</strong> <span th:text=\"${menu.precioTotal}\"></span></p> <h2>Platos</h2> <ul> <li th:each=\"plato : ${menu.platos}\"> <strong th:text=\"${plato.nombre}\"></strong> - <span th:text=\"${plato.categoria}\"></span> (<span th:text=\"${plato.precio}\"></span> \u20ac) </li> </ul> <a href=\"/menus\">Volver</a> </body> </html> editar.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Crear/Editar Men\u00fa</title> </head> <body> <h1 th:text=\"${#strings.equals(menu.id, '') ? 'Crear Nuevo Men\u00fa' : 'Editar Men\u00fa'}\"></h1> <form th:action=\"@{${#strings.equals(menu.id, '') ? '/menus/guardar' : '/menus/actualizar/' + menu.id}}\" th:object=\"${menu}\" method=\"post\"> <label for=\"nombre\">Nombre:</label> <input type=\"text\" id=\"nombre\" name=\"nombre\" th:value=\"${menu.nombre}\" required><br> <label for=\"descripcion\">Descripci\u00f3n:</label> <textarea id=\"descripcion\" name=\"descripcion\" th:text=\"${menu.descripcion}\" required></textarea><br> <label for=\"fecha\">Fecha:</label> <input type=\"date\" id=\"fecha\" name=\"fecha\" th:value=\"${menu.fecha}\" required><br> <label for=\"precioTotal\">Precio Total:</label> <input type=\"number\" id=\"precioTotal\" name=\"precioTotal\" th:value=\"${menu.precioTotal}\" step=\"0.01\" required><br> <button type=\"submit\">Guardar</button> <a href=\"/menus\">Cancelar</a> </form> </body> </html> templates/platos/ listar.kt <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Platos del Men\u00fa</title> </head> <body> <h1 th:text=\"'Platos del Men\u00fa: ' + ${menu.nombre}\"></h1> <a th:href=\"@{/menus}\">Volver a Men\u00fas</a> <table border=\"1\"> <thead> <tr> <th>Nombre</th> <th>Categor\u00eda</th> <th>Precio</th> <th>Ingredientes</th> </tr> </thead> <tbody> <tr th:each=\"plato : ${platos}\"> <td th:text=\"${plato.nombre}\"></td> <td th:text=\"${plato.categoria}\"></td> <td th:text=\"${plato.precio} + ' \u20ac'\"></td> <td> <a th:href=\"@{'/platos/' + ${menu.id} + '/ingredientes/' + ${plato.nombre}}\">Ver Ingredientes</a> </td> </tr> </tbody> </table> </body> </html> ingredientes.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Ingredientes</title> </head> <body> <h1 th:text=\"'Ingredientes del plato: ' + ${plato?.nombre}\"></h1> <div th:if=\"${error}\"> <p th:text=\"${error}\" style=\"color: red;\"></p> </div> <ul th:if=\"${ingredientes != null && !ingredientes.isEmpty()}\"> <li th:each=\"ingrediente : ${ingredientes}\" th:text=\"${ingrediente}\"></li> </ul> <p th:if=\"${ingredientes == null || ingredientes.isEmpty()}\" style=\"color: gray;\"> No hay ingredientes disponibles para este plato. </p> <a th:href=\"@{'/platos/' + ${menu.id}}\">Volver a los platos</a> </body> </html> buscarPorCategoria.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Buscar Men\u00fas por Categor\u00eda</title> </head> <body> <h1>Resultados para categor\u00eda: <span th:text=\"${categoriaBuscada}\"></span></h1> <table border=\"1\" th:if=\"${menus}\"> <thead> <tr> <th>ID</th> <th>Nombre</th> <th>Descripci\u00f3n</th> <th>Platos</th> </tr> </thead> <tbody> <tr th:each=\"menu : ${menus}\"> <td th:text=\"${menu.id}\"></td> <td th:text=\"${menu.nombre}\"></td> <td th:text=\"${menu.descripcion}\"></td> <td> <ul> <li th:each=\"plato : ${menu.platos}\" th:if=\"${plato.categoria == categoriaBuscada}\" th:text=\"${plato.nombre}\"></li> </ul> </td> </tr> </tbody> </table> <p th:if=\"${menus == null || menus.isEmpty()}\" style=\"color: gray;\"> No se encontraron men\u00fas con platos de la categor\u00eda <span th:text=\"${categoriaBuscada}\"></span>. </p> <a href=\"/menus\">Volver a la lista de men\u00fas</a> </body> </html>","title":"Spring MongoDb"},{"location":"SpringMongo/#spring-mongodb","text":"Spring MongoDb Es un m\u00f3dulo de Spring Data que facilita la integraci\u00f3n de aplicaciones Spring con MongoDB. Adem\u00e1s proporciona una abstracci\u00f3n sobre las operaciones b\u00e1sicas de MongoDB como CRUD, consultas personalizadas, y soporte para agregaciones. Requisitos Tener MongoDB instalado o utilizar una instancia en la nube o en un contenedor Docker. Spring Boot configurado con Maven (en nuestro caso) o Gradle. Dependencias Maven <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-data-mongodb</artifactId> </dependency> application.properties spring.data.mongodb.host=localhost spring.data.mongodb.port=27017 spring.data.mongodb.database=nombre_base_de_datos Si est\u00e1s usando MongoDB con autenticaci\u00f3n, a\u00f1ade: spring.data.mongodb.username=usuario spring.data.mongodb.password=contrase\u00f1a","title":"Spring MongoDb"},{"location":"SpringMongo/#ejemplo-menus","text":"En este ejemplo partiremos de un archivo json con 10 men\u00fas y sus correspondientes platos. Has de a\u00f1adir este documento como una colecci\u00f3n a tu BD Mongo. Archivo json con los menus: [ { \"_id\": \"1\", \"nombre\": \"Men\u00fa Mediterr\u00e1neo\", \"descripcion\": \"Un men\u00fa saludable inspirado en la dieta mediterr\u00e1nea.\", \"fecha\": \"2025-01-08\", \"platos\": [ { \"nombre\": \"Ensalada Griega\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Lechuga\", \"Tomate\", \"Pepino\", \"Aceitunas\", \"Queso Feta\"], \"precio\": 5.5 }, { \"nombre\": \"Moussaka\", \"categoria\": \"Principal\", \"ingredientes\": [\"Berenjena\", \"Carne de Cordero\", \"Tomate\", \"Bechamel\", \"Queso\"], \"precio\": 12.0 } ], \"precioTotal\": 17.5 }, { \"_id\": \"2\", \"nombre\": \"Men\u00fa Asi\u00e1tico\", \"descripcion\": \"Sabores frescos y aut\u00e9nticos de Asia.\", \"fecha\": \"2025-01-09\", \"platos\": [ { \"nombre\": \"Rollitos de Primavera\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Zanahoria\", \"Col\", \"Brotes de Soja\", \"Fideos de Arroz\"], \"precio\": 4.0 }, { \"nombre\": \"Pad Thai\", \"categoria\": \"Principal\", \"ingredientes\": [\"Fideos de Arroz\", \"Camarones\", \"Tofu\", \"Man\u00ed\"], \"precio\": 10.0 } ], \"precioTotal\": 14.0 }, { \"_id\": \"3\", \"nombre\": \"Men\u00fa Vegetariano\", \"descripcion\": \"Opciones deliciosas sin carne.\", \"fecha\": \"2025-01-10\", \"platos\": [ { \"nombre\": \"Hummus con Pan de Pita\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Garbanzos\", \"Tahini\", \"Lim\u00f3n\", \"Ajo\"], \"precio\": 4.5 }, { \"nombre\": \"Lasa\u00f1a Vegetariana\", \"categoria\": \"Principal\", \"ingredientes\": [\"Pasta\", \"Espinacas\", \"Ricotta\", \"Tomate\"], \"precio\": 9.0 } ], \"precioTotal\": 13.5 }, { \"_id\": \"4\", \"nombre\": \"Men\u00fa Italiano\", \"descripcion\": \"Especialidades cl\u00e1sicas de Italia.\", \"fecha\": \"2025-01-11\", \"platos\": [ { \"nombre\": \"Bruschetta\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Pan\", \"Tomate\", \"Albahaca\", \"Aceite de Oliva\"], \"precio\": 5.0 }, { \"nombre\": \"Pizza Margarita\", \"categoria\": \"Principal\", \"ingredientes\": [\"Masa de Pizza\", \"Tomate\", \"Mozzarella\", \"Albahaca\"], \"precio\": 10.0 } ], \"precioTotal\": 15.0 }, { \"_id\": \"5\", \"nombre\": \"Men\u00fa Mexicano\", \"descripcion\": \"Platos picantes y llenos de sabor.\", \"fecha\": \"2025-01-12\", \"platos\": [ { \"nombre\": \"Guacamole con Totopos\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Aguacate\", \"Lim\u00f3n\", \"Cilantro\", \"Totopos\"], \"precio\": 4.5 }, { \"nombre\": \"Tacos al Pastor\", \"categoria\": \"Principal\", \"ingredientes\": [\"Tortilla\", \"Carne de Cerdo\", \"Pi\u00f1a\", \"Cebolla\"], \"precio\": 9.0 } ], \"precioTotal\": 13.5 }, { \"_id\": \"6\", \"nombre\": \"Men\u00fa Americano\", \"descripcion\": \"Comida cl\u00e1sica de los Estados Unidos.\", \"fecha\": \"2025-01-13\", \"platos\": [ { \"nombre\": \"Alitas de Pollo\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Pollo\", \"Salsa BBQ\", \"Especias\"], \"precio\": 6.0 }, { \"nombre\": \"Hamburguesa con Queso\", \"categoria\": \"Principal\", \"ingredientes\": [\"Pan\", \"Carne de Res\", \"Queso\", \"Lechuga\"], \"precio\": 10.0 } ], \"precioTotal\": 16.0 }, { \"_id\": \"7\", \"nombre\": \"Men\u00fa de Mariscos\", \"descripcion\": \"Frescos sabores del oc\u00e9ano.\", \"fecha\": \"2025-01-14\", \"platos\": [ { \"nombre\": \"C\u00f3ctel de Camarones\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Camarones\", \"Salsa C\u00f3ctel\", \"Lim\u00f3n\"], \"precio\": 7.0 }, { \"nombre\": \"Paella de Mariscos\", \"categoria\": \"Principal\", \"ingredientes\": [\"Arroz\", \"Camarones\", \"Mejillones\", \"Calamares\"], \"precio\": 12.0 } ], \"precioTotal\": 19.0 }, { \"_id\": \"8\", \"nombre\": \"Men\u00fa Franc\u00e9s\", \"descripcion\": \"Platos refinados y elegantes.\", \"fecha\": \"2025-01-15\", \"platos\": [ { \"nombre\": \"Quiche Lorraine\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Huevo\", \"Nata\", \"Tocino\", \"Queso Gruy\u00e8re\"], \"precio\": 6.5 }, { \"nombre\": \"Ratatouille\", \"categoria\": \"Principal\", \"ingredientes\": [\"Berenjena\", \"Calabac\u00edn\", \"Tomate\", \"Pimiento\"], \"precio\": 9.5 } ], \"precioTotal\": 16.0 }, { \"_id\": \"9\", \"nombre\": \"Men\u00fa Indio\", \"descripcion\": \"Sabores especiados y ex\u00f3ticos.\", \"fecha\": \"2025-01-16\", \"platos\": [ { \"nombre\": \"Samosas\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Papas\", \"Especias\", \"Masa Frita\"], \"precio\": 4.0 }, { \"nombre\": \"Pollo Tikka Masala\", \"categoria\": \"Principal\", \"ingredientes\": [\"Pollo\", \"Salsa de Tomate\", \"Especias\", \"Crema\"], \"precio\": 11.0 } ], \"precioTotal\": 15.0 }, { \"_id\": \"10\", \"nombre\": \"Men\u00fa Japon\u00e9s\", \"descripcion\": \"Delicados sabores de Jap\u00f3n.\", \"fecha\": \"2025-01-17\", \"platos\": [ { \"nombre\": \"Sopa de Miso\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Miso\", \"Tofu\", \"Alga Wakame\"], \"precio\": 3.5 }, { \"nombre\": \"Sushi Variado\", \"categoria\": \"Principal\", \"ingredientes\": [\"Arroz\", \"Pescado\", \"Alga Nori\", \"Vegetales\"], \"precio\": 12.5 } ], \"precioTotal\": 16.0 } ] Modelo MVC Modelo Los modelos son las clases que representan las colecciones en MongoDB. Deben incluir la anotaci\u00f3n @Document . Menu.kt import org.springframework.data.annotation.Id import org.springframework.data.mongodb.core.mapping.Document @Document(collection = \"menus\") // Nombre de la colecci\u00f3n en MongoDB data class Menu( @Id val id: String, // Identificador \u00fanico del men\u00fa val nombre: String, // Nombre del men\u00fa val descripcion: String, // Descripci\u00f3n del men\u00fa val fecha: String, // Fecha asociada al men\u00fa val platos: List<Plato> = emptyList(), // Lista de platos val precioTotal: Double = 0.0 // Precio total del men\u00fa ) data class Plato( val nombre: String, val categoria: String, val ingredientes: List<String> = emptyList(), val precio: Double = 0.0 ) Repositorios proporciona una interfaz MongoRepository que simplifica las operaciones CRUD. MenuRepository.kt import org.springframework.data.mongodb.repository.MongoRepository import org.springframework.stereotype.Repository import org.example.primerspringmongo.model.* @Repository interface MenuRepository : MongoRepository<Menu, String> { fun findByNombre(nombre: String): List<Menu> fun findByPlatosCategoria(categoria: String): List<Menu> } Controlador MenuController.kt import org.example.primerspringmongo.model.Menu import org.example.primerspringmongo.repository.MenuRepository import org.springframework.stereotype.Controller import org.springframework.ui.Model import org.springframework.web.bind.annotation.* @Controller @RequestMapping(\"/menus\") class MenuController(private val menuRepository: MenuRepository) { // Listar todos los men\u00fas @GetMapping fun listarMenus(model: Model): String { val menus = menuRepository.findAll() model.addAttribute(\"menus\", menus) return \"menus/listar\" } @GetMapping(\"/buscar\") fun buscarPorNombre(@RequestParam nombre: String, model: Model): String { val menus = menuRepository.findByNombre(nombre) // Consulta en el repositorio model.addAttribute(\"menus\", menus) // Pasar los men\u00fas al modelo model.addAttribute(\"nombre\", nombre) // Pasar el nombre buscado return \"menus/listar\" // Nombre de la plantilla Thymeleaf } // Guardar un nuevo men\u00fa @PostMapping(\"/guardar\") fun guardarMenu(@ModelAttribute menu: Menu): String { menuRepository.save(menu) return \"redirect:/menus\" } // Ver detalles de un men\u00fa @GetMapping(\"/{id}\") fun verDetalles(@PathVariable id: String, model: Model): String { val menu = menuRepository.findById(id) if (menu.isPresent) { model.addAttribute(\"menu\", menu.get()) return \"menus/detalles\" } return \"redirect:/menus\" } // Mostrar formulario para editar un men\u00fa @GetMapping(\"/editar/{id}\") fun mostrarFormularioEditar(@PathVariable id: String, model: Model): String { val menu = menuRepository.findById(id) if (menu.isPresent) { model.addAttribute(\"menu\", menu.get()) return \"menus/editar\" } return \"redirect:/menus\" } // Actualizar un men\u00fa existente @PostMapping(\"/actualizar/{id}\") fun actualizarMenu(@PathVariable id: String, @ModelAttribute menu: Menu): String { if (menuRepository.existsById(id)) { menuRepository.save(menu) } return \"redirect:/menus\" } // Eliminar un men\u00fa @GetMapping(\"/eliminar/{id}\") fun eliminarMenu(@PathVariable id: String): String { menuRepository.deleteById(id) return \"redirect:/menus\" } } PlatoController.kt import org.example.primerspringmongo.repository.MenuRepository import org.springframework.stereotype.Controller import org.springframework.ui.Model import org.springframework.web.bind.annotation.* @Controller @RequestMapping(\"/platos\") class PlatoController(private val menuRepository: MenuRepository) { // Listar todos los platos de un men\u00fa @GetMapping(\"/{menuId}\") fun listarPlatos(@PathVariable menuId: String, model: Model): String { val menu = menuRepository.findById(menuId) if (menu.isPresent) { model.addAttribute(\"menu\", menu.get()) model.addAttribute(\"platos\", menu.get().platos) return \"platos/listar\" } return \"redirect:/menus\" } @GetMapping(\"/categoria\") fun buscarPorCategoria(@RequestParam categoria: String, model: Model): String { val menus = menuRepository.findByPlatosCategoria(categoria) // Consulta en el repositorio model.addAttribute(\"menus\", menus) // Lista de men\u00fas encontrados model.addAttribute(\"categoriaBuscada\", categoria) // Categor\u00eda buscada return \"platos/buscarPorCategoria\" // Plantilla Thymeleaf } @GetMapping(\"/{menuId}/ingredientes/{platoNombre}\") fun verIngredientes( @PathVariable menuId: String, @PathVariable platoNombre: String, model: Model ): String { val menu = menuRepository.findById(menuId) if (menu.isPresent) { val plato = menu.get().platos.find { it.nombre == platoNombre } if (plato != null) { println(\"Plato encontrado: $plato\") println(\"Ingredientes: ${plato.ingredientes}\") model.addAttribute(\"menu\", menu.get()) model.addAttribute(\"plato\", plato) model.addAttribute(\"ingredientes\", plato.ingredientes ?: emptyList<String>()) return \"platos/ingredientes\" } } model.addAttribute(\"error\", \"El plato o el men\u00fa no existen.\") return \"error\" } } Vista templates/menus/ listar.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Lista de Men\u00fas</title> </head> <body> <h1>Lista de Men\u00fas</h1> <a href=\"/menus/crear\">Crear Nuevo Men\u00fa</a> <table border=\"1\"> <thead> <tr> <th>Nombre</th> <th>Descripci\u00f3n</th> <th>Acciones</th> </tr> </thead> <tbody> <tr th:each=\"menu : ${menus}\"> <td th:text=\"${menu.nombre}\"></td> <td th:text=\"${menu.descripcion}\"></td> <td> <a th:href=\"@{'/menus/' + ${menu.id}}\">Detalles</a> <a th:href=\"@{'/menus/editar/' + ${menu.id}}\">Editar</a> <a th:href=\"@{'/menus/eliminar/' + ${menu.id}}\" onclick=\"return confirm('\u00bfSeguro que quieres eliminar este men\u00fa?')\">Eliminar</a> </td> </tr> </tbody> </table> </body> </html> crear.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Crear/Editar Men\u00fa</title> </head> <body> <h1 th:text=\"${#strings.equals(menu.id, '') ? 'Crear Nuevo Men\u00fa' : 'Editar Men\u00fa'}\"></h1> <form th:action=\"@{${#strings.equals(menu.id, '') ? '/menus/guardar' : '/menus/actualizar/' + menu.id}}\" th:object=\"${menu}\" method=\"post\"> <label for=\"nombre\">Nombre:</label> <input type=\"text\" id=\"nombre\" name=\"nombre\" th:value=\"${menu.nombre}\" required><br> <label for=\"descripcion\">Descripci\u00f3n:</label> <textarea id=\"descripcion\" name=\"descripcion\" th:text=\"${menu.descripcion}\" required></textarea><br> <label for=\"fecha\">Fecha:</label> <input type=\"date\" id=\"fecha\" name=\"fecha\" th:value=\"${menu.fecha}\" required><br> <label for=\"precioTotal\">Precio Total:</label> <input type=\"number\" id=\"precioTotal\" name=\"precioTotal\" th:value=\"${menu.precioTotal}\" step=\"0.01\" required><br> <button type=\"submit\">Guardar</button> <a href=\"/menus\">Cancelar</a> </form> </body> </html> detalles.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Detalles del Men\u00fa</title> </head> <body> <h1>Detalles del Men\u00fa</h1> <p><strong>Nombre:</strong> <span th:text=\"${menu.nombre}\"></span></p> <p><strong>Descripci\u00f3n:</strong> <span th:text=\"${menu.descripcion}\"></span></p> <p><strong>Fecha:</strong> <span th:text=\"${menu.fecha}\"></span></p> <p><strong>Precio Total:</strong> <span th:text=\"${menu.precioTotal}\"></span></p> <h2>Platos</h2> <ul> <li th:each=\"plato : ${menu.platos}\"> <strong th:text=\"${plato.nombre}\"></strong> - <span th:text=\"${plato.categoria}\"></span> (<span th:text=\"${plato.precio}\"></span> \u20ac) </li> </ul> <a href=\"/menus\">Volver</a> </body> </html> editar.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Crear/Editar Men\u00fa</title> </head> <body> <h1 th:text=\"${#strings.equals(menu.id, '') ? 'Crear Nuevo Men\u00fa' : 'Editar Men\u00fa'}\"></h1> <form th:action=\"@{${#strings.equals(menu.id, '') ? '/menus/guardar' : '/menus/actualizar/' + menu.id}}\" th:object=\"${menu}\" method=\"post\"> <label for=\"nombre\">Nombre:</label> <input type=\"text\" id=\"nombre\" name=\"nombre\" th:value=\"${menu.nombre}\" required><br> <label for=\"descripcion\">Descripci\u00f3n:</label> <textarea id=\"descripcion\" name=\"descripcion\" th:text=\"${menu.descripcion}\" required></textarea><br> <label for=\"fecha\">Fecha:</label> <input type=\"date\" id=\"fecha\" name=\"fecha\" th:value=\"${menu.fecha}\" required><br> <label for=\"precioTotal\">Precio Total:</label> <input type=\"number\" id=\"precioTotal\" name=\"precioTotal\" th:value=\"${menu.precioTotal}\" step=\"0.01\" required><br> <button type=\"submit\">Guardar</button> <a href=\"/menus\">Cancelar</a> </form> </body> </html> templates/platos/ listar.kt <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Platos del Men\u00fa</title> </head> <body> <h1 th:text=\"'Platos del Men\u00fa: ' + ${menu.nombre}\"></h1> <a th:href=\"@{/menus}\">Volver a Men\u00fas</a> <table border=\"1\"> <thead> <tr> <th>Nombre</th> <th>Categor\u00eda</th> <th>Precio</th> <th>Ingredientes</th> </tr> </thead> <tbody> <tr th:each=\"plato : ${platos}\"> <td th:text=\"${plato.nombre}\"></td> <td th:text=\"${plato.categoria}\"></td> <td th:text=\"${plato.precio} + ' \u20ac'\"></td> <td> <a th:href=\"@{'/platos/' + ${menu.id} + '/ingredientes/' + ${plato.nombre}}\">Ver Ingredientes</a> </td> </tr> </tbody> </table> </body> </html> ingredientes.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Ingredientes</title> </head> <body> <h1 th:text=\"'Ingredientes del plato: ' + ${plato?.nombre}\"></h1> <div th:if=\"${error}\"> <p th:text=\"${error}\" style=\"color: red;\"></p> </div> <ul th:if=\"${ingredientes != null && !ingredientes.isEmpty()}\"> <li th:each=\"ingrediente : ${ingredientes}\" th:text=\"${ingrediente}\"></li> </ul> <p th:if=\"${ingredientes == null || ingredientes.isEmpty()}\" style=\"color: gray;\"> No hay ingredientes disponibles para este plato. </p> <a th:href=\"@{'/platos/' + ${menu.id}}\">Volver a los platos</a> </body> </html> buscarPorCategoria.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Buscar Men\u00fas por Categor\u00eda</title> </head> <body> <h1>Resultados para categor\u00eda: <span th:text=\"${categoriaBuscada}\"></span></h1> <table border=\"1\" th:if=\"${menus}\"> <thead> <tr> <th>ID</th> <th>Nombre</th> <th>Descripci\u00f3n</th> <th>Platos</th> </tr> </thead> <tbody> <tr th:each=\"menu : ${menus}\"> <td th:text=\"${menu.id}\"></td> <td th:text=\"${menu.nombre}\"></td> <td th:text=\"${menu.descripcion}\"></td> <td> <ul> <li th:each=\"plato : ${menu.platos}\" th:if=\"${plato.categoria == categoriaBuscada}\" th:text=\"${plato.nombre}\"></li> </ul> </td> </tr> </tbody> </table> <p th:if=\"${menus == null || menus.isEmpty()}\" style=\"color: gray;\"> No se encontraron men\u00fas con platos de la categor\u00eda <span th:text=\"${categoriaBuscada}\"></span>. </p> <a href=\"/menus\">Volver a la lista de men\u00fas</a> </body> </html>","title":"Ejemplo: Men\u00fas"}]}