{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement CompartirIgual 2.5 Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 2.5","title":"Acc\u00e9s a Dades - Componentes"},{"location":"Anotaciones/","text":"Anotaciones Las anotaciones en Spring simplifican enormemente la configuraci\u00f3n y el manejo de los componentes de una aplicaci\u00f3n. Estas anotaciones eliminan la necesidad de configuraciones extensas en archivos XML y hacen que el c\u00f3digo sea m\u00e1s legible y f\u00e1cil de mantener. La clave es aprender a usarlas en el contexto adecuado para lograr aplicaciones modulares, escalables y f\u00e1cilmente configurables. Principales prop\u00f3sitos de las anotaciones en Spring: 1) Inyecci\u00f3n de dependencias Permiten declarar y gestionar las relaciones entre los diferentes componentes de una aplicaci\u00f3n. Ejemplos: @Autowired : Para inyectar autom\u00e1ticamente dependencias. @Qualifier : Para resolver ambig\u00fcedades cuando hay m\u00faltiples beans del mismo tipo. @Value : Inyecta valores desde propiedades (application.properties) o expresiones. 2) Definici\u00f3n de componentes Marcan clases como componentes gestionados por el contenedor de Spring, para que puedan ser inyectados y utilizados en otras partes de la aplicaci\u00f3n. Ejemplos: @Component : Marca una clase gen\u00e9rica como un componente gestionado por Spring. @Service : Especializaci\u00f3n de @Component para servicios. @Repository : Especializaci\u00f3n para la capa de acceso a datos. Cuando la clase interact\u00faa directamente con la base de datos (por ejemplo, con Spring Data JPA o JDBC). @Configuration : Indica que una clase contiene definiciones de beans (equivalente a un archivo XML de configuraci\u00f3n). @Bean : Define un bean manualmente dentro de una clase de configuraci\u00f3n. @Controller : Marca una clase como un controlador para manejar peticiones HTTP. Cuando necesitas manejar peticiones web en una aplicaci\u00f3n tradicional. @RestController : Combina @Controller y @ResponseBody para APIs RESTful. Cuando est\u00e1s desarrollando una API REST y necesitas devolver objetos serializados directamente en la respuesta. En Spring Boot, las anotaciones son fundamentales porque definen el comportamiento y la configuraci\u00f3n de los componentes de la aplicaci\u00f3n. A continuaci\u00f3n, se muestran ejemplos de las anotaciones m\u00e1s utilizadas, organizadas por categor\u00edas: Anotaciones de configuraci\u00f3n @SpringBootApplication @SpringBootApplication public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } Marca la clase principal de la aplicaci\u00f3n. Es una combinaci\u00f3n de: 1. @Configuration: Habilita la configuraci\u00f3n autom\u00e1tica. 2. @EnableAutoConfiguration: Hace que Spring escanee las dependencias incluidas en el classpath y configure autom\u00e1ticamente Beans relacionados. Por ejemplo: Si tienes Spring Web en el proyecto, configurar\u00e1 un servidor web. Si tienes una dependencia de JPA, configurar\u00e1 un gestor de entidades. 3. @ComponentScan: Indica a Spring que debe escanear los paquetes a partir del paquete donde est\u00e1 definida la clase con @SpringBootApplication, buscando clases anotadas con: @Component @Service @Repository @Controller @Configuration Indica que una clase contiene definiciones de beans. @Configuration public class AppConfig { @Bean public MyService myService() { return new MyService(); } } @PropertySource Carga un archivo de propiedades externo. @PropertySource(\"classpath:application.properties\") public class AppConfig {} Anotaciones de componentes y Beans @Component Marca una clase como un Bean para que Spring la detecte autom\u00e1ticamente durante el escaneo de componentes. Uso t\u00edpico: cualquier clase que no encaje espec\u00edficamente como servicio, repositorio o controlador. @Component public class MyComponent { public void doSomething() { System.out.println(\"Hello from MyComponent!\"); } } @Service Es una especializaci\u00f3n de @Component. Indica que la clase contiene l\u00f3gica de negocio. Uso t\u00edpico: servicios de negocio. @Service public class MyService { public String process() { return \"Processing...\"; } } @Repository Especializaci\u00f3n de @Component. Indica que la clase es responsable de la interacci\u00f3n con la base de datos. Habilita el manejo autom\u00e1tico de excepciones relacionadas con la persistencia. @Repository public interface MyRepository extends JpaRepository<MyEntity, Long> { } @Bean Declara un bean dentro de una clase anotada con @Configuration. @Configuration public class AppConfig { @Bean public MyService myService() { return new MyService(); } } Anotaciones de controladores (MVC) @Controller Especializaci\u00f3n de @Component. Indica que la clase es un controlador que maneja solicitudes HTTP en aplicaciones web MVC. Uso t\u00edpico: manejar la l\u00f3gica de las solicitudes y devolver vistas. @Controller public class MyController { @GetMapping(\"/home\") public String home() { return \"home\"; } } @RestController Combina @Controller y @ResponseBody. Indica que la clase es un controlador REST que devuelve directamente datos (normalmente en formato JSON o XML) en lugar de vistas. @RestController public class MyRestController { @GetMapping(\"/api/greet\") public String greet() { return \"Hello, World!\"; } } @RequestMapping Mapea solicitudes HTTP a m\u00e9todos espec\u00edficos en un controlador. @Controller public class MyController { @RequestMapping(\"/home\") public String home() { return \"home\"; } } @GetMapping, @PostMapping, @PutMapping, @DeleteMapping Son variantes especializadas de @RequestMapping para solicitudes HTTP espec\u00edficas. @RestController public class MyController { @GetMapping(\"/users\") public List<User> getUsers() { return userService.getAllUsers(); } } @PathVariable Vincula un par\u00e1metro en la URL a un argumento en el controlador. @GetMapping(\"/users/{id}\") public User getUser(@PathVariable Long id) { return userService.getUserById(id); } @RequestParam Vincula un par\u00e1metro de consulta (query parameter) a un argumento del controlador. @GetMapping(\"/search\") public String search(@RequestParam String keyword) { return \"Searching for \" + keyword; } @RequestBody Vincula el cuerpo de la solicitud HTTP a un objeto Java. @PostMapping(\"/users\") public User createUser(@RequestBody User user) { return userService.save(user); } @ResponseBody Indica que el resultado del m\u00e9todo debe enviarse como la respuesta HTTP (generalmente en formato JSON o XML). @ResponseBody @GetMapping(\"/hello\") public String hello() { return \"Hello!\"; } Anotaciones para Inyecci\u00f3n de Dependencias @Autowired Inyecta autom\u00e1ticamente un Bean en una clase. Se puede usar en: Constructor Campo M\u00e9todo @Service public class MyService { @Autowired private MyRepository myRepository; } @Qualifier Se usa junto con @Autowired para especificar qu\u00e9 Bean debe inyectarse si hay m\u00faltiples candidatos. @Service public class MyService { @Autowired @Qualifier(\"mySpecificBean\") private MyComponent myComponent; } @Inject Alternativa a @Autowired (de Java CDI), realiza la misma funci\u00f3n. @Inject private MyComponent myComponent; @Value Inyecta valores directamente desde el archivo de configuraci\u00f3n (application.properties) o valores literales. @Value(\"${app.name}\") private String appName; Anotaciones para Spring Data","title":"2 - Anotaciones"},{"location":"Anotaciones/#anotaciones","text":"Las anotaciones en Spring simplifican enormemente la configuraci\u00f3n y el manejo de los componentes de una aplicaci\u00f3n. Estas anotaciones eliminan la necesidad de configuraciones extensas en archivos XML y hacen que el c\u00f3digo sea m\u00e1s legible y f\u00e1cil de mantener. La clave es aprender a usarlas en el contexto adecuado para lograr aplicaciones modulares, escalables y f\u00e1cilmente configurables. Principales prop\u00f3sitos de las anotaciones en Spring: 1) Inyecci\u00f3n de dependencias Permiten declarar y gestionar las relaciones entre los diferentes componentes de una aplicaci\u00f3n. Ejemplos: @Autowired : Para inyectar autom\u00e1ticamente dependencias. @Qualifier : Para resolver ambig\u00fcedades cuando hay m\u00faltiples beans del mismo tipo. @Value : Inyecta valores desde propiedades (application.properties) o expresiones. 2) Definici\u00f3n de componentes Marcan clases como componentes gestionados por el contenedor de Spring, para que puedan ser inyectados y utilizados en otras partes de la aplicaci\u00f3n. Ejemplos: @Component : Marca una clase gen\u00e9rica como un componente gestionado por Spring. @Service : Especializaci\u00f3n de @Component para servicios. @Repository : Especializaci\u00f3n para la capa de acceso a datos. Cuando la clase interact\u00faa directamente con la base de datos (por ejemplo, con Spring Data JPA o JDBC). @Configuration : Indica que una clase contiene definiciones de beans (equivalente a un archivo XML de configuraci\u00f3n). @Bean : Define un bean manualmente dentro de una clase de configuraci\u00f3n. @Controller : Marca una clase como un controlador para manejar peticiones HTTP. Cuando necesitas manejar peticiones web en una aplicaci\u00f3n tradicional. @RestController : Combina @Controller y @ResponseBody para APIs RESTful. Cuando est\u00e1s desarrollando una API REST y necesitas devolver objetos serializados directamente en la respuesta. En Spring Boot, las anotaciones son fundamentales porque definen el comportamiento y la configuraci\u00f3n de los componentes de la aplicaci\u00f3n. A continuaci\u00f3n, se muestran ejemplos de las anotaciones m\u00e1s utilizadas, organizadas por categor\u00edas:","title":"Anotaciones"},{"location":"Anotaciones/#anotaciones-de-configuracion","text":"@SpringBootApplication @SpringBootApplication public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } Marca la clase principal de la aplicaci\u00f3n. Es una combinaci\u00f3n de: 1. @Configuration: Habilita la configuraci\u00f3n autom\u00e1tica. 2. @EnableAutoConfiguration: Hace que Spring escanee las dependencias incluidas en el classpath y configure autom\u00e1ticamente Beans relacionados. Por ejemplo: Si tienes Spring Web en el proyecto, configurar\u00e1 un servidor web. Si tienes una dependencia de JPA, configurar\u00e1 un gestor de entidades. 3. @ComponentScan: Indica a Spring que debe escanear los paquetes a partir del paquete donde est\u00e1 definida la clase con @SpringBootApplication, buscando clases anotadas con: @Component @Service @Repository @Controller @Configuration Indica que una clase contiene definiciones de beans. @Configuration public class AppConfig { @Bean public MyService myService() { return new MyService(); } } @PropertySource Carga un archivo de propiedades externo. @PropertySource(\"classpath:application.properties\") public class AppConfig {}","title":"Anotaciones de configuraci\u00f3n"},{"location":"Anotaciones/#anotaciones-de-componentes-y-beans","text":"@Component Marca una clase como un Bean para que Spring la detecte autom\u00e1ticamente durante el escaneo de componentes. Uso t\u00edpico: cualquier clase que no encaje espec\u00edficamente como servicio, repositorio o controlador. @Component public class MyComponent { public void doSomething() { System.out.println(\"Hello from MyComponent!\"); } } @Service Es una especializaci\u00f3n de @Component. Indica que la clase contiene l\u00f3gica de negocio. Uso t\u00edpico: servicios de negocio. @Service public class MyService { public String process() { return \"Processing...\"; } } @Repository Especializaci\u00f3n de @Component. Indica que la clase es responsable de la interacci\u00f3n con la base de datos. Habilita el manejo autom\u00e1tico de excepciones relacionadas con la persistencia. @Repository public interface MyRepository extends JpaRepository<MyEntity, Long> { } @Bean Declara un bean dentro de una clase anotada con @Configuration. @Configuration public class AppConfig { @Bean public MyService myService() { return new MyService(); } }","title":"Anotaciones de componentes y Beans"},{"location":"Anotaciones/#anotaciones-de-controladores-mvc","text":"@Controller Especializaci\u00f3n de @Component. Indica que la clase es un controlador que maneja solicitudes HTTP en aplicaciones web MVC. Uso t\u00edpico: manejar la l\u00f3gica de las solicitudes y devolver vistas. @Controller public class MyController { @GetMapping(\"/home\") public String home() { return \"home\"; } } @RestController Combina @Controller y @ResponseBody. Indica que la clase es un controlador REST que devuelve directamente datos (normalmente en formato JSON o XML) en lugar de vistas. @RestController public class MyRestController { @GetMapping(\"/api/greet\") public String greet() { return \"Hello, World!\"; } } @RequestMapping Mapea solicitudes HTTP a m\u00e9todos espec\u00edficos en un controlador. @Controller public class MyController { @RequestMapping(\"/home\") public String home() { return \"home\"; } } @GetMapping, @PostMapping, @PutMapping, @DeleteMapping Son variantes especializadas de @RequestMapping para solicitudes HTTP espec\u00edficas. @RestController public class MyController { @GetMapping(\"/users\") public List<User> getUsers() { return userService.getAllUsers(); } } @PathVariable Vincula un par\u00e1metro en la URL a un argumento en el controlador. @GetMapping(\"/users/{id}\") public User getUser(@PathVariable Long id) { return userService.getUserById(id); } @RequestParam Vincula un par\u00e1metro de consulta (query parameter) a un argumento del controlador. @GetMapping(\"/search\") public String search(@RequestParam String keyword) { return \"Searching for \" + keyword; } @RequestBody Vincula el cuerpo de la solicitud HTTP a un objeto Java. @PostMapping(\"/users\") public User createUser(@RequestBody User user) { return userService.save(user); } @ResponseBody Indica que el resultado del m\u00e9todo debe enviarse como la respuesta HTTP (generalmente en formato JSON o XML). @ResponseBody @GetMapping(\"/hello\") public String hello() { return \"Hello!\"; }","title":"Anotaciones de controladores (MVC)"},{"location":"Anotaciones/#anotaciones-para-inyeccion-de-dependencias","text":"@Autowired Inyecta autom\u00e1ticamente un Bean en una clase. Se puede usar en: Constructor Campo M\u00e9todo @Service public class MyService { @Autowired private MyRepository myRepository; } @Qualifier Se usa junto con @Autowired para especificar qu\u00e9 Bean debe inyectarse si hay m\u00faltiples candidatos. @Service public class MyService { @Autowired @Qualifier(\"mySpecificBean\") private MyComponent myComponent; } @Inject Alternativa a @Autowired (de Java CDI), realiza la misma funci\u00f3n. @Inject private MyComponent myComponent; @Value Inyecta valores directamente desde el archivo de configuraci\u00f3n (application.properties) o valores literales. @Value(\"${app.name}\") private String appName; Anotaciones para Spring Data","title":"Anotaciones para Inyecci\u00f3n de Dependencias"},{"location":"Docker/","text":"Docker Docker es una herramienta que utiliza la tecnolog\u00eda de contenedores para empaquetar aplicaciones y sus dependencias en unidades port\u00e1tiles y ligeras. Esto garantiza que una aplicaci\u00f3n se ejecute de la misma manera en cualquier entorno, ya sea en una computadora local, un servidor de desarrollo, o en la nube. Conceptos clave de Docker Contenedores : Son entornos aislados que contienen todo lo necesario para ejecutar una aplicaci\u00f3n: c\u00f3digo, bibliotecas, dependencias, y configuraciones. A diferencia de las m\u00e1quinas virtuales, los contenedores comparten el mismo n\u00facleo del sistema operativo, lo que los hace m\u00e1s ligeros y eficientes. Im\u00e1genes : Son plantillas inmutables utilizadas para crear contenedores. Las im\u00e1genes son versiones preconfiguradas de un software o aplicaci\u00f3n que incluyen todo lo necesario para ejecutarse. Docker Engine : Es el motor que ejecuta y gestiona los contenedores. Permite construir im\u00e1genes, iniciar contenedores y comunicarse con el hardware del sistema. Docker Hub : Es un repositorio en l\u00ednea donde se pueden almacenar y compartir im\u00e1genes de Docker. Ofrece una amplia variedad de im\u00e1genes predefinidas listas para usar. \u00bfC\u00f3mo funciona Docker? Construcci\u00f3n de una imagen : Los desarrolladores crean un archivo llamado Dockerfile, donde se especifican los pasos para construir la imagen de una aplicaci\u00f3n. A partir del Dockerfile, Docker genera una imagen. Ejecuci\u00f3n de un contenedor : Usando una imagen, Docker inicia un contenedor que ejecuta la aplicaci\u00f3n empaquetada. Distribuci\u00f3n de im\u00e1genes : Las im\u00e1genes pueden ser subidas a Docker Hub u otros registros privados para compartirlas y utilizarlas en diferentes sistemas. Para saber m\u00e1s pod\u00e9is consultar su p\u00e1gina Web: https://www.docker.com/ Instalaci\u00f3n de Docker en Ubuntu https://docs.docker.com/desktop/setup/install/linux/ubuntu/ Requisitos previos Aseg\u00farate de que tu sistema est\u00e1 actualizado: sudo apt update && sudo apt upgrade -y Desinstala versiones antiguas de Docker si est\u00e1n instaladas: sudo apt remove docker docker-engine docker.io containerd runc Pasos para instalar Docker 1) Instalar paquetes necesarios: sudo apt install apt-transport-https ca-certificates curl software-properties-common 2) Agregar la clave GPG de Docker: curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg 3) Agregar el repositorio de Docker: echo \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null 4) Actualizar el \u00edndice de paquetes e instalar Docker: sudo apt update sudo apt install docker-ce docker-ce-cli containerd.io 5) Verificar la instalaci\u00f3n: docker --version 6) Habilitar Docker para que inicie con el sistema: sudo systemctl enable docker 7) Opcional: Permitir ejecutar Docker sin sudo : sudo usermod -aG docker $USER # Sal y vuelve a iniciar sesi\u00f3n para aplicar los cambios Probar Docker Ejecuta el siguiente comando para probar si Docker est\u00e1 funcionando correctamente: docker run hello-world Instalaci\u00f3n de Docker en Windows https://docs.docker.com/desktop/setup/install/windows-install/ Requisitos previos Windows 10 o superior con soporte para WSL 2. Habilitar virtualizaci\u00f3n en el BIOS. Pasos para instalar Docker 1) Descargar Docker Desktop: Ve al sitio oficial de Docker y descarga Docker Desktop: https://www.docker.com/products/docker-desktop 2) Ejecutar el instalador: Sigue las instrucciones del asistente de instalaci\u00f3n. 3) Habilitar WSL 2: Aseg\u00farate de que WSL 2 est\u00e1 habilitado en tu sistema: dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart wsl --set-default-version 2 4) Configurar Docker Desktop: Abre Docker Desktop y sigue las instrucciones para configurar WSL 2. 5) Verificar la instalaci\u00f3n: Abre una terminal y ejecuta: docker --version 6) Probar Docker: Ejecuta el comando: docker run hello-world Opcional: Configuraci\u00f3n adicional Habilitar compartir recursos (discos, memoria, CPU) en la configuraci\u00f3n de Docker Desktop. Instalar herramientas complementarias como Docker Compose. Con estos pasos, Docker deber\u00eda estar instalado y funcionando correctamente tanto en Ubuntu como en Windows.","title":"6 - Docker"},{"location":"Docker/#docker","text":"Docker es una herramienta que utiliza la tecnolog\u00eda de contenedores para empaquetar aplicaciones y sus dependencias en unidades port\u00e1tiles y ligeras. Esto garantiza que una aplicaci\u00f3n se ejecute de la misma manera en cualquier entorno, ya sea en una computadora local, un servidor de desarrollo, o en la nube. Conceptos clave de Docker Contenedores : Son entornos aislados que contienen todo lo necesario para ejecutar una aplicaci\u00f3n: c\u00f3digo, bibliotecas, dependencias, y configuraciones. A diferencia de las m\u00e1quinas virtuales, los contenedores comparten el mismo n\u00facleo del sistema operativo, lo que los hace m\u00e1s ligeros y eficientes. Im\u00e1genes : Son plantillas inmutables utilizadas para crear contenedores. Las im\u00e1genes son versiones preconfiguradas de un software o aplicaci\u00f3n que incluyen todo lo necesario para ejecutarse. Docker Engine : Es el motor que ejecuta y gestiona los contenedores. Permite construir im\u00e1genes, iniciar contenedores y comunicarse con el hardware del sistema. Docker Hub : Es un repositorio en l\u00ednea donde se pueden almacenar y compartir im\u00e1genes de Docker. Ofrece una amplia variedad de im\u00e1genes predefinidas listas para usar. \u00bfC\u00f3mo funciona Docker? Construcci\u00f3n de una imagen : Los desarrolladores crean un archivo llamado Dockerfile, donde se especifican los pasos para construir la imagen de una aplicaci\u00f3n. A partir del Dockerfile, Docker genera una imagen. Ejecuci\u00f3n de un contenedor : Usando una imagen, Docker inicia un contenedor que ejecuta la aplicaci\u00f3n empaquetada. Distribuci\u00f3n de im\u00e1genes : Las im\u00e1genes pueden ser subidas a Docker Hub u otros registros privados para compartirlas y utilizarlas en diferentes sistemas. Para saber m\u00e1s pod\u00e9is consultar su p\u00e1gina Web: https://www.docker.com/","title":"Docker"},{"location":"Docker/#instalacion-de-docker-en-ubuntu","text":"https://docs.docker.com/desktop/setup/install/linux/ubuntu/","title":"Instalaci\u00f3n de Docker en Ubuntu"},{"location":"Docker/#requisitos-previos","text":"Aseg\u00farate de que tu sistema est\u00e1 actualizado: sudo apt update && sudo apt upgrade -y Desinstala versiones antiguas de Docker si est\u00e1n instaladas: sudo apt remove docker docker-engine docker.io containerd runc","title":"Requisitos previos"},{"location":"Docker/#pasos-para-instalar-docker","text":"1) Instalar paquetes necesarios: sudo apt install apt-transport-https ca-certificates curl software-properties-common 2) Agregar la clave GPG de Docker: curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg 3) Agregar el repositorio de Docker: echo \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null 4) Actualizar el \u00edndice de paquetes e instalar Docker: sudo apt update sudo apt install docker-ce docker-ce-cli containerd.io 5) Verificar la instalaci\u00f3n: docker --version 6) Habilitar Docker para que inicie con el sistema: sudo systemctl enable docker 7) Opcional: Permitir ejecutar Docker sin sudo : sudo usermod -aG docker $USER # Sal y vuelve a iniciar sesi\u00f3n para aplicar los cambios","title":"Pasos para instalar Docker"},{"location":"Docker/#probar-docker","text":"Ejecuta el siguiente comando para probar si Docker est\u00e1 funcionando correctamente: docker run hello-world","title":"Probar Docker"},{"location":"Docker/#instalacion-de-docker-en-windows","text":"https://docs.docker.com/desktop/setup/install/windows-install/","title":"Instalaci\u00f3n de Docker en Windows"},{"location":"Docker/#requisitos-previos_1","text":"Windows 10 o superior con soporte para WSL 2. Habilitar virtualizaci\u00f3n en el BIOS.","title":"Requisitos previos"},{"location":"Docker/#pasos-para-instalar-docker_1","text":"1) Descargar Docker Desktop: Ve al sitio oficial de Docker y descarga Docker Desktop: https://www.docker.com/products/docker-desktop 2) Ejecutar el instalador: Sigue las instrucciones del asistente de instalaci\u00f3n. 3) Habilitar WSL 2: Aseg\u00farate de que WSL 2 est\u00e1 habilitado en tu sistema: dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart wsl --set-default-version 2 4) Configurar Docker Desktop: Abre Docker Desktop y sigue las instrucciones para configurar WSL 2. 5) Verificar la instalaci\u00f3n: Abre una terminal y ejecuta: docker --version 6) Probar Docker: Ejecuta el comando: docker run hello-world","title":"Pasos para instalar Docker"},{"location":"Docker/#opcional-configuracion-adicional","text":"Habilitar compartir recursos (discos, memoria, CPU) en la configuraci\u00f3n de Docker Desktop. Instalar herramientas complementarias como Docker Compose. Con estos pasos, Docker deber\u00eda estar instalado y funcionando correctamente tanto en Ubuntu como en Windows.","title":"Opcional: Configuraci\u00f3n adicional"},{"location":"Spring/","text":"Spring Spring es un framework de c\u00f3digo abierto para el desarrollo de aplicaciones Java. Su objetivo principal es facilitar la creaci\u00f3n de aplicaciones robustas, flexibles y mantenibles mediante el uso de principios como la Inversi\u00f3n de Control (IoC) y la Programaci\u00f3n Orientada a Aspectos (AOP). Filosof\u00eda de Spring Inversi\u00f3n de Control (IoC): El framework se encarga de gestionar las dependencias entre los componentes de la aplicaci\u00f3n. Programaci\u00f3n Orientada a Aspectos (AOP): Permite separar preocupaciones transversales, como la seguridad o el manejo de logs, del n\u00facleo de la l\u00f3gica de la aplicaci\u00f3n. Un framework es un conjunto de componentes que proporciona abstracciones e implementaciones, ya hechas, de las tareas b\u00e1sicas que todo el sistema de informaci\u00f3n realiza. Componentes principales: Spring Core : El n\u00facleo del framework, encargado de la inyecci\u00f3n de dependencias. Spring MVC : Permite el desarrollo de aplicaciones web utilizando el patr\u00f3n Modelo-Vista-Controlador. Spring Boot : Facilita la creaci\u00f3n de aplicaciones basadas en Spring con una configuraci\u00f3n m\u00ednima. Spring Data : Simplifica el acceso a datos con soporte para JPA, MongoDB, Redis, entre otros. Spring Security : Proporciona herramientas para implementar seguridad en aplicaciones. Spring Cloud : Ayuda en la construcci\u00f3n de aplicaciones distribuidas y microservicios. Requisitos previos JDK: Aseg\u00farate de tener Java Development Kit instalado. Maven o Gradle: Para gestionar dependencias. IDE: IntelliJ IDEA, Eclipse u otro entorno de desarrollo. Spring Core Es el n\u00facleo del framework, encargado de la inyecci\u00f3n de dependencias (DI). Inyecci\u00f3n de Dependencias (DI) La Inyecci\u00f3n de Dependencias es un patr\u00f3n fundamental en Spring que permite a las clases declarar las dependencias que necesitan, dejando que el contenedor de Spring las proporcione autom\u00e1ticamente. Esto se logra mediante el uso de anotaciones o configuraci\u00f3n expl\u00edcita. Tipos de inyecci\u00f3n de dependencias: Constructor, Setter o Campo. Inyecci\u00f3n por constructor (recomendada): Se realiza pasando las dependencias necesarias como par\u00e1metros al constructor de la clase. import org.springframework.stereotype.Service @Service class MiServicio(private val repositorio: MiRepositorio){ fun realizarAccion() { println(\"Usando el repositorio: $miRepositorio\") } } Spring detecta el constructor y resuelve autom\u00e1ticamente las dependencias necesarias. En Kotlin, el modificador private en el constructor asegura que la dependencia no se exponga como una propiedad p\u00fablica. Inyecci\u00f3n por setter: Se realiza proporcionando m\u00e9todos setter para establecer las dependencias despu\u00e9s de crear el objeto. import org.springframework.beans.factory.annotation.Autowired import org.springframework.stereotype.Service @Service class MiServicio { private lateinit var miRepositorio: MiRepositorio fun setMiRepositorio(miRepositorio: MiRepositorio) { this.miRepositorio = miRepositorio } fun realizarAccion() { println(\"Usando el repositorio: $miRepositorio\") } } Spring llama al m\u00e9todo setMiRepositorio y pasa la dependencia configurada. Inyecci\u00f3n directa en campos: Se realiza directamente en las propiedades de la clase, usando anotaciones como @Autowired o inyect\u00e1ndolas mediante el constructor en Kotlin. import org.springframework.stereotype.Service class MiServicio { @Autowired private lateinit var miRepositorio: MiRepositorio fun realizarAccion() { println(\"Usando el repositorio: $miRepositorio\") } } Spring inyecta directamente la dependencia en el campo marcado con @Autowired. Contenedor Spring En Spring, los conceptos IoC y DI se implementan a trav\u00e9s del contenedor Spring, que crea y gestiona los objetos de la aplicaci\u00f3n, que se conocen como beans . Los beans y sus dependencias se configuran en archivos de configuraci\u00f3n de Spring o mediante anotaciones en el c\u00f3digo. Beans En el contexto de Spring, un Bean es un objeto que es gestionado por el contenedor de Spring. Estos beans son los componentes esenciales de una aplicaci\u00f3n Spring y su ciclo de vida es manejado por el framework, permitiendo una inyecci\u00f3n de dependencias eficiente y una configuraci\u00f3n centralizada, y que puede utilizarse para proporcionar servicios o funcionalidades a otras partes de la aplicaci\u00f3n. Hay varias formas de definir beans en Spring Boot, y la m\u00e1s com\u00fan es a trav\u00e9s de anotaciones . Anotaciones Las anotaciones son herramientas utilizadas para indicar a Spring c\u00f3mo manejar un Bean o c\u00f3mo configurar ciertos aspectos de la aplicaci\u00f3n. Por ejemplo, @Bean le dice a Spring que cree y gestione un Bean, mientras que @Component marca una clase para ser detectada autom\u00e1ticamente como Bean. @Configuration: Define una clase de configuraci\u00f3n. @Bean: Declara un Bean manualmente. Alternativamente, los Beans pueden configurarse mediante un archivo XML (menos com\u00fan hoy en d\u00eda). Ejemplos de configuraci\u00f3n con anotaciones: Definir un Bean con @Component import org.springframework.stereotype.Component; @Component public class MiComponente { public String saludar() { return \"Hola desde MiComponente\"; } } Crear un servicio con @Service import org.springframework.stereotype.Service; @Service public class MiServicio { public String obtenerMensaje() { return \"Mensaje desde MiServicio\"; } } Configurar un Bean manualmente con @Bean import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class MiConfiguracion { @Bean public MiComponente miComponente() { return new MiComponente(); } }","title":"1 - Spring"},{"location":"Spring/#spring","text":"Spring es un framework de c\u00f3digo abierto para el desarrollo de aplicaciones Java. Su objetivo principal es facilitar la creaci\u00f3n de aplicaciones robustas, flexibles y mantenibles mediante el uso de principios como la Inversi\u00f3n de Control (IoC) y la Programaci\u00f3n Orientada a Aspectos (AOP). Filosof\u00eda de Spring Inversi\u00f3n de Control (IoC): El framework se encarga de gestionar las dependencias entre los componentes de la aplicaci\u00f3n. Programaci\u00f3n Orientada a Aspectos (AOP): Permite separar preocupaciones transversales, como la seguridad o el manejo de logs, del n\u00facleo de la l\u00f3gica de la aplicaci\u00f3n. Un framework es un conjunto de componentes que proporciona abstracciones e implementaciones, ya hechas, de las tareas b\u00e1sicas que todo el sistema de informaci\u00f3n realiza. Componentes principales: Spring Core : El n\u00facleo del framework, encargado de la inyecci\u00f3n de dependencias. Spring MVC : Permite el desarrollo de aplicaciones web utilizando el patr\u00f3n Modelo-Vista-Controlador. Spring Boot : Facilita la creaci\u00f3n de aplicaciones basadas en Spring con una configuraci\u00f3n m\u00ednima. Spring Data : Simplifica el acceso a datos con soporte para JPA, MongoDB, Redis, entre otros. Spring Security : Proporciona herramientas para implementar seguridad en aplicaciones. Spring Cloud : Ayuda en la construcci\u00f3n de aplicaciones distribuidas y microservicios. Requisitos previos JDK: Aseg\u00farate de tener Java Development Kit instalado. Maven o Gradle: Para gestionar dependencias. IDE: IntelliJ IDEA, Eclipse u otro entorno de desarrollo. Spring Core Es el n\u00facleo del framework, encargado de la inyecci\u00f3n de dependencias (DI). Inyecci\u00f3n de Dependencias (DI) La Inyecci\u00f3n de Dependencias es un patr\u00f3n fundamental en Spring que permite a las clases declarar las dependencias que necesitan, dejando que el contenedor de Spring las proporcione autom\u00e1ticamente. Esto se logra mediante el uso de anotaciones o configuraci\u00f3n expl\u00edcita. Tipos de inyecci\u00f3n de dependencias: Constructor, Setter o Campo. Inyecci\u00f3n por constructor (recomendada): Se realiza pasando las dependencias necesarias como par\u00e1metros al constructor de la clase. import org.springframework.stereotype.Service @Service class MiServicio(private val repositorio: MiRepositorio){ fun realizarAccion() { println(\"Usando el repositorio: $miRepositorio\") } } Spring detecta el constructor y resuelve autom\u00e1ticamente las dependencias necesarias. En Kotlin, el modificador private en el constructor asegura que la dependencia no se exponga como una propiedad p\u00fablica. Inyecci\u00f3n por setter: Se realiza proporcionando m\u00e9todos setter para establecer las dependencias despu\u00e9s de crear el objeto. import org.springframework.beans.factory.annotation.Autowired import org.springframework.stereotype.Service @Service class MiServicio { private lateinit var miRepositorio: MiRepositorio fun setMiRepositorio(miRepositorio: MiRepositorio) { this.miRepositorio = miRepositorio } fun realizarAccion() { println(\"Usando el repositorio: $miRepositorio\") } } Spring llama al m\u00e9todo setMiRepositorio y pasa la dependencia configurada. Inyecci\u00f3n directa en campos: Se realiza directamente en las propiedades de la clase, usando anotaciones como @Autowired o inyect\u00e1ndolas mediante el constructor en Kotlin. import org.springframework.stereotype.Service class MiServicio { @Autowired private lateinit var miRepositorio: MiRepositorio fun realizarAccion() { println(\"Usando el repositorio: $miRepositorio\") } } Spring inyecta directamente la dependencia en el campo marcado con @Autowired. Contenedor Spring En Spring, los conceptos IoC y DI se implementan a trav\u00e9s del contenedor Spring, que crea y gestiona los objetos de la aplicaci\u00f3n, que se conocen como beans . Los beans y sus dependencias se configuran en archivos de configuraci\u00f3n de Spring o mediante anotaciones en el c\u00f3digo. Beans En el contexto de Spring, un Bean es un objeto que es gestionado por el contenedor de Spring. Estos beans son los componentes esenciales de una aplicaci\u00f3n Spring y su ciclo de vida es manejado por el framework, permitiendo una inyecci\u00f3n de dependencias eficiente y una configuraci\u00f3n centralizada, y que puede utilizarse para proporcionar servicios o funcionalidades a otras partes de la aplicaci\u00f3n. Hay varias formas de definir beans en Spring Boot, y la m\u00e1s com\u00fan es a trav\u00e9s de anotaciones . Anotaciones Las anotaciones son herramientas utilizadas para indicar a Spring c\u00f3mo manejar un Bean o c\u00f3mo configurar ciertos aspectos de la aplicaci\u00f3n. Por ejemplo, @Bean le dice a Spring que cree y gestione un Bean, mientras que @Component marca una clase para ser detectada autom\u00e1ticamente como Bean. @Configuration: Define una clase de configuraci\u00f3n. @Bean: Declara un Bean manualmente. Alternativamente, los Beans pueden configurarse mediante un archivo XML (menos com\u00fan hoy en d\u00eda). Ejemplos de configuraci\u00f3n con anotaciones: Definir un Bean con @Component import org.springframework.stereotype.Component; @Component public class MiComponente { public String saludar() { return \"Hola desde MiComponente\"; } } Crear un servicio con @Service import org.springframework.stereotype.Service; @Service public class MiServicio { public String obtenerMensaje() { return \"Mensaje desde MiServicio\"; } } Configurar un Bean manualmente con @Bean import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class MiConfiguracion { @Bean public MiComponente miComponente() { return new MiComponente(); } }","title":"Spring"},{"location":"SpringBoot/","text":"Spring Boot \u00bfQu\u00e9 es Spring Boot? Spring Boot es una herramienta de desarrollo que se basa en Spring Framework. Se enfoca en simplificar y acelerar el desarrollo de aplicaciones web y microservicios, ofreciendo una configuraci\u00f3n autom\u00e1tica y la capacidad de crear aplicaciones que se ejecutan de forma independiente sin necesidad de un servidor web externo. Para entender el concepto, primero debemos reflexionar sobre c\u00f3mo construimos aplicaciones con Spring Fundamentalmente existen tres pasos a realizar . El primero es crear un proyecto Maven/Gradle y descargar las dependencias necesarias. En segundo lugar desarrollamos la aplicaci\u00f3n y en tercer lugar la desplegamos en un servidor. Si nos ponemos a pensar un poco a detalle en el tema, \u00fanicamente el paso dos es una tarea de desarrollo. Los otros pasos est\u00e1n m\u00e1s orientados a infraestructura. SpringBoot nace con la intenci\u00f3n de simplificar los pasos 1 y 3 y que nos podamos centrar en el desarrollo de nuestra aplicaci\u00f3n. \u00bfC\u00f3mo funciona? El enfoque es sencillo y lo entenderemos realizando un ejemplo. Tambi\u00e9n tendr\u00e1 especial importancia el archivo applicantion.properties que ser\u00e1 donde configuraremos aspectos relativos con nuestra aplicaci\u00f3n, tales como las conexiones a base de datos o el puerto por donde acceder a nuestra aplicaci\u00f3n por ejemplo. Tambi\u00e9n podemos ver todas las dependencias que se han a\u00f1adido gracias al archivo pom.xml Primera aplicaci\u00f3n SpringBoot Para entender la filosf\u00eda de Spring lo mejor es hacer una primera aplicaci\u00f3n sencilla. Esta aplicaci\u00f3n consistir\u00e1 en devolver un saludo al usuario a trav\u00e9s de un navegador web. Acontinuaci\u00f3n se detallan los pasos a seguir. Podemos crear los proyectos Spring Boot de dos maneras: Mediante una herramienta web online ( https://start.spring.io/ ) denominada Spring Initializr , donde por medio de unos par\u00e1metros de configuraci\u00f3n, genera autom\u00e1ticamente un proyecto Maven o Gradle, seg\u00fan elijamos, en un archivo comprimido Zip, con la estructura de la aplicaci\u00f3n y que puede ser importada directamente desde un IDE. Mediante un IDE, como Eclipse, IntelliJ...etc, teniendo instalados los plugins necesarios. En nuestro caso crearemos un proyecto Maven de Spring Boot en IntelliJ : Crear la aplicaci\u00f3n y a\u00f1adir dependencias 1) Creamos el proyecto y lo configuramos desde File-->New-->Project : Elige Spring Boot . Configura las siguientes opciones: Language: Kotlin Build System: Maven Especifica un nombre para el proyecto: PrimerSpringBoot \u00daltima versi\u00f3n de JDK \u00daltima versi\u00f3n de Java 2) Posteriormente seleccionamos las dependencias necesarias: Spring Web (para el desarrollo de aplicaciones web) 3) Despu\u00e9s de aceptar, y si todo ha ido correctamente, ya tendremos nuestro proyecto creado. Nota Para este proyecto solo necesitaremos la dependenica Spring Web : Se utiliza para desarrollar aplicaciones web, ya sea basadas en REST o tradicionales con HTML din\u00e1mico. Incluye un servidor web embebido (por defecto, Tomcat) para ejecutar la aplicaci\u00f3n sin necesidad de configurarlo manualmente. Facilita el manejo de rutas HTTP (GET, POST, PUT, DELETE, etc.) y par\u00e1metros de solicitud a trav\u00e9s de m\u00e9todos en los controladores. Usa la biblioteca Jackson (incluida por defecto) para convertir autom\u00e1ticamente objetos Kotlin/Java a JSON y viceversa. Ofrece herramientas para manejar errores y excepciones de forma global mediante @ControllerAdvice o controladores personalizados. Al iniciar nuestra aplicaci\u00f3n, lo primero que observamos es que se crea una clase PrimerSpringBootApplication que sirve como contenedor para la configuraci\u00f3n de la aplicaci\u00f3n. No necesitas implementar m\u00e9todos adicionales, ya que Spring Boot se encarga de todo gracias a la anotaci\u00f3n @SpringBootApplication . La clase est\u00e1 anotada con @SpringBootApplication y, runApplication , es una funci\u00f3n de extensi\u00f3n proporcionada por Spring Boot para lanzar la aplicaci\u00f3n. @SpringBootApplication class PrimerSpringBootApplication fun main(args: Array<String>) { runApplication<PrimerSpringBootApplication>(*args) } El tipo gen\u00e9rico < PrimerSpringBootApplication > indica que \u00e9sta es la clase principal de la aplicaci\u00f3n que contiene la anotaci\u00f3n @SpringBootApplication . *args pasa los argumentos de la l\u00ednea de comandos a la aplicaci\u00f3n. Se utiliza para descomponer un array (como Array < String > ) en argumentos individuales, lo que es necesario para pasar los par\u00e1metros de la l\u00ednea de comandos al m\u00e9todo runApplication. Agregar un m\u00e9todo que env\u00ede un saludo Agregaremos el m\u00e9todo sayHello() directamente a la clase principal, PrimerSpringBootApplication , con todas las anotaciones e importaciones necesarias:: package com.example.primerspringboot import org.springframework.boot.autoconfigure.SpringBootApplication import org.springframework.boot.runApplication import org.springframework.web.bind.annotation.GetMapping import org.springframework.web.bind.annotation.RequestParam import org.springframework.web.bind.annotation.RestController @SpringBootApplication @RestController class PrimerSpringBootApplication{ @GetMapping(\"/hello\") fun sayHello( @RequestParam(value = \"myName\", defaultValue = \"World\") name: String): String { return \"Hello $name!\" } } fun main(args: Array<String>) { runApplication<PrimerSpringBootApplication>(*args) } @RestController : se utiliza para que Spring reconozca la clase como un controlador que maneja solicitudes HTTP. Combina: @Controller: Define la clase como un controlador web. @ResponseBody: Indica que los m\u00e9todos devolver\u00e1n directamente el cuerpo de la respuesta (en este caso, texto plano en lugar de una vista HTML). @GetMapping(\"/hello\") : Es una anotaci\u00f3n de Spring que indica que este m\u00e9todo debe manejar las solicitudes HTTP GET que lleguen a la URL /hello. Enlaza la URL /hello con el m\u00e9todo sayHello. Cada vez que se acceda a esa ruta en un navegador con un m\u00e9todo GET, Spring ejecutar\u00e1 el m\u00e9todo sayHello. Por ejemplo, al visitar http://localhost:8080/hello (asumiendo el puerto predeterminado 8080), este m\u00e9todo ser\u00e1 invocado. @RequestParam : se usa para extraer un par\u00e1metro de la consulta (query parameter) enviado en la URL. El m\u00e9todo espera un par\u00e1metro de consulta llamado myName. Si el cliente no incluye myName en la solicitud, el valor predeterminado ser\u00e1 \"World\", gracias a defaultValue = \"World\". Ejecuta la aplicaci\u00f3n Spring Al ejecutar la aplicaci\u00f3n, la pesta\u00f1a Consola muestra la salida de los mensajes de registro de Spring. De manera predeterminada, el servidor Apache Tomcat integrado escucha en el puerto 8080 . Nota Si tienes el puerto 8080 ocupado, te aparecer\u00e1 el siguiete error: Puedes cambiar el puerto en el archivo application.properties que se encuentra en la carpeta resources de tu proyecto. Por ejemplo estaleciendo el puerto a 8888: Ahora abre el navegador web a la direcci\u00f3n http://localhost:8080/hello , o con el puerto que hayas seleccionado. Deber\u00edas ver que tu aplicaci\u00f3n responde con Hello World! . Nota Esta es la respuesta gen\u00e9rica predeterminada. Puedes proporcionar un par\u00e1metro en tu solicitud web para que la aplicaci\u00f3n sepa c\u00f3mo saludarte correctamente. Por ejemplo, prueba http://localhost:8080/hello?myName=Alicia . Para entender el funcionamiento de la aplicaci\u00f3n, aqu\u00ed tienes resumido su flujo de ejecuci\u00f3n: Flujo de ejecuci\u00f3n Inicio de la aplicaci\u00f3n: Se ejecuta el m\u00e9todo main, lo que inicia un servidor web embebido (por defecto, Tomcat ) en el puerto 8080 . Solicitudes HTTP: Cuando un cliente env\u00eda una solicitud GET a /hello con o sin el par\u00e1metro myName , el m\u00e9todo sayHello maneja la solicitud. Respuesta: La aplicaci\u00f3n devuelve un mensaje personalizado en texto plano seg\u00fan el par\u00e1metro myName . A\u00f1adir una p\u00e1gina de inicio La aplicaci\u00f3n Spring Boot creada tiene un punto final disponible en /hello. Sin embargo, si abres el contexto ra\u00edz de tu aplicaci\u00f3n en http://localhost:8080/ , obtendr\u00e1s un error porque no hay ning\u00fan recurso ra\u00edz definido. A\u00f1ade una p\u00e1gina de inicio HTML est\u00e1tica con enlaces a su punto final. Crea el archivo index.html en /src /main /resources /static/ . Modifica la plantilla predeterminada o reempl\u00e1zala con el siguiente c\u00f3digo HTML: <!DOCTYPE HTML> <html> <head> <title>Your first Spring application</title> <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" /> </head> <body> <p><a href=\"/hello\">Greet the world!</a></p> <form action=\"/hello\" method=\"GET\" id=\"nameForm\"> <div> <label for=\"nameField\">How should the app call you?</label> <input name=\"myName\" id=\"nameField\"> <button>Greet me!</button> </div> </form> </body> </html> Ejecuta la aplicaci\u00f3n de nuevo. Ahora tu aplicaci\u00f3n servir\u00e1 index.html como recurso ra\u00edz en http://localhost:8080/ .","title":"3 - SpringBoot"},{"location":"SpringBoot/#spring-boot","text":"\u00bfQu\u00e9 es Spring Boot? Spring Boot es una herramienta de desarrollo que se basa en Spring Framework. Se enfoca en simplificar y acelerar el desarrollo de aplicaciones web y microservicios, ofreciendo una configuraci\u00f3n autom\u00e1tica y la capacidad de crear aplicaciones que se ejecutan de forma independiente sin necesidad de un servidor web externo. Para entender el concepto, primero debemos reflexionar sobre c\u00f3mo construimos aplicaciones con Spring Fundamentalmente existen tres pasos a realizar . El primero es crear un proyecto Maven/Gradle y descargar las dependencias necesarias. En segundo lugar desarrollamos la aplicaci\u00f3n y en tercer lugar la desplegamos en un servidor. Si nos ponemos a pensar un poco a detalle en el tema, \u00fanicamente el paso dos es una tarea de desarrollo. Los otros pasos est\u00e1n m\u00e1s orientados a infraestructura. SpringBoot nace con la intenci\u00f3n de simplificar los pasos 1 y 3 y que nos podamos centrar en el desarrollo de nuestra aplicaci\u00f3n. \u00bfC\u00f3mo funciona? El enfoque es sencillo y lo entenderemos realizando un ejemplo. Tambi\u00e9n tendr\u00e1 especial importancia el archivo applicantion.properties que ser\u00e1 donde configuraremos aspectos relativos con nuestra aplicaci\u00f3n, tales como las conexiones a base de datos o el puerto por donde acceder a nuestra aplicaci\u00f3n por ejemplo. Tambi\u00e9n podemos ver todas las dependencias que se han a\u00f1adido gracias al archivo pom.xml","title":"Spring Boot"},{"location":"SpringBoot/#primera-aplicacion-springboot","text":"Para entender la filosf\u00eda de Spring lo mejor es hacer una primera aplicaci\u00f3n sencilla. Esta aplicaci\u00f3n consistir\u00e1 en devolver un saludo al usuario a trav\u00e9s de un navegador web. Acontinuaci\u00f3n se detallan los pasos a seguir. Podemos crear los proyectos Spring Boot de dos maneras: Mediante una herramienta web online ( https://start.spring.io/ ) denominada Spring Initializr , donde por medio de unos par\u00e1metros de configuraci\u00f3n, genera autom\u00e1ticamente un proyecto Maven o Gradle, seg\u00fan elijamos, en un archivo comprimido Zip, con la estructura de la aplicaci\u00f3n y que puede ser importada directamente desde un IDE. Mediante un IDE, como Eclipse, IntelliJ...etc, teniendo instalados los plugins necesarios. En nuestro caso crearemos un proyecto Maven de Spring Boot en IntelliJ : Crear la aplicaci\u00f3n y a\u00f1adir dependencias 1) Creamos el proyecto y lo configuramos desde File-->New-->Project : Elige Spring Boot . Configura las siguientes opciones: Language: Kotlin Build System: Maven Especifica un nombre para el proyecto: PrimerSpringBoot \u00daltima versi\u00f3n de JDK \u00daltima versi\u00f3n de Java 2) Posteriormente seleccionamos las dependencias necesarias: Spring Web (para el desarrollo de aplicaciones web) 3) Despu\u00e9s de aceptar, y si todo ha ido correctamente, ya tendremos nuestro proyecto creado. Nota Para este proyecto solo necesitaremos la dependenica Spring Web : Se utiliza para desarrollar aplicaciones web, ya sea basadas en REST o tradicionales con HTML din\u00e1mico. Incluye un servidor web embebido (por defecto, Tomcat) para ejecutar la aplicaci\u00f3n sin necesidad de configurarlo manualmente. Facilita el manejo de rutas HTTP (GET, POST, PUT, DELETE, etc.) y par\u00e1metros de solicitud a trav\u00e9s de m\u00e9todos en los controladores. Usa la biblioteca Jackson (incluida por defecto) para convertir autom\u00e1ticamente objetos Kotlin/Java a JSON y viceversa. Ofrece herramientas para manejar errores y excepciones de forma global mediante @ControllerAdvice o controladores personalizados. Al iniciar nuestra aplicaci\u00f3n, lo primero que observamos es que se crea una clase PrimerSpringBootApplication que sirve como contenedor para la configuraci\u00f3n de la aplicaci\u00f3n. No necesitas implementar m\u00e9todos adicionales, ya que Spring Boot se encarga de todo gracias a la anotaci\u00f3n @SpringBootApplication . La clase est\u00e1 anotada con @SpringBootApplication y, runApplication , es una funci\u00f3n de extensi\u00f3n proporcionada por Spring Boot para lanzar la aplicaci\u00f3n. @SpringBootApplication class PrimerSpringBootApplication fun main(args: Array<String>) { runApplication<PrimerSpringBootApplication>(*args) } El tipo gen\u00e9rico < PrimerSpringBootApplication > indica que \u00e9sta es la clase principal de la aplicaci\u00f3n que contiene la anotaci\u00f3n @SpringBootApplication . *args pasa los argumentos de la l\u00ednea de comandos a la aplicaci\u00f3n. Se utiliza para descomponer un array (como Array < String > ) en argumentos individuales, lo que es necesario para pasar los par\u00e1metros de la l\u00ednea de comandos al m\u00e9todo runApplication. Agregar un m\u00e9todo que env\u00ede un saludo Agregaremos el m\u00e9todo sayHello() directamente a la clase principal, PrimerSpringBootApplication , con todas las anotaciones e importaciones necesarias:: package com.example.primerspringboot import org.springframework.boot.autoconfigure.SpringBootApplication import org.springframework.boot.runApplication import org.springframework.web.bind.annotation.GetMapping import org.springframework.web.bind.annotation.RequestParam import org.springframework.web.bind.annotation.RestController @SpringBootApplication @RestController class PrimerSpringBootApplication{ @GetMapping(\"/hello\") fun sayHello( @RequestParam(value = \"myName\", defaultValue = \"World\") name: String): String { return \"Hello $name!\" } } fun main(args: Array<String>) { runApplication<PrimerSpringBootApplication>(*args) } @RestController : se utiliza para que Spring reconozca la clase como un controlador que maneja solicitudes HTTP. Combina: @Controller: Define la clase como un controlador web. @ResponseBody: Indica que los m\u00e9todos devolver\u00e1n directamente el cuerpo de la respuesta (en este caso, texto plano en lugar de una vista HTML). @GetMapping(\"/hello\") : Es una anotaci\u00f3n de Spring que indica que este m\u00e9todo debe manejar las solicitudes HTTP GET que lleguen a la URL /hello. Enlaza la URL /hello con el m\u00e9todo sayHello. Cada vez que se acceda a esa ruta en un navegador con un m\u00e9todo GET, Spring ejecutar\u00e1 el m\u00e9todo sayHello. Por ejemplo, al visitar http://localhost:8080/hello (asumiendo el puerto predeterminado 8080), este m\u00e9todo ser\u00e1 invocado. @RequestParam : se usa para extraer un par\u00e1metro de la consulta (query parameter) enviado en la URL. El m\u00e9todo espera un par\u00e1metro de consulta llamado myName. Si el cliente no incluye myName en la solicitud, el valor predeterminado ser\u00e1 \"World\", gracias a defaultValue = \"World\". Ejecuta la aplicaci\u00f3n Spring Al ejecutar la aplicaci\u00f3n, la pesta\u00f1a Consola muestra la salida de los mensajes de registro de Spring. De manera predeterminada, el servidor Apache Tomcat integrado escucha en el puerto 8080 . Nota Si tienes el puerto 8080 ocupado, te aparecer\u00e1 el siguiete error: Puedes cambiar el puerto en el archivo application.properties que se encuentra en la carpeta resources de tu proyecto. Por ejemplo estaleciendo el puerto a 8888: Ahora abre el navegador web a la direcci\u00f3n http://localhost:8080/hello , o con el puerto que hayas seleccionado. Deber\u00edas ver que tu aplicaci\u00f3n responde con Hello World! . Nota Esta es la respuesta gen\u00e9rica predeterminada. Puedes proporcionar un par\u00e1metro en tu solicitud web para que la aplicaci\u00f3n sepa c\u00f3mo saludarte correctamente. Por ejemplo, prueba http://localhost:8080/hello?myName=Alicia . Para entender el funcionamiento de la aplicaci\u00f3n, aqu\u00ed tienes resumido su flujo de ejecuci\u00f3n: Flujo de ejecuci\u00f3n Inicio de la aplicaci\u00f3n: Se ejecuta el m\u00e9todo main, lo que inicia un servidor web embebido (por defecto, Tomcat ) en el puerto 8080 . Solicitudes HTTP: Cuando un cliente env\u00eda una solicitud GET a /hello con o sin el par\u00e1metro myName , el m\u00e9todo sayHello maneja la solicitud. Respuesta: La aplicaci\u00f3n devuelve un mensaje personalizado en texto plano seg\u00fan el par\u00e1metro myName . A\u00f1adir una p\u00e1gina de inicio La aplicaci\u00f3n Spring Boot creada tiene un punto final disponible en /hello. Sin embargo, si abres el contexto ra\u00edz de tu aplicaci\u00f3n en http://localhost:8080/ , obtendr\u00e1s un error porque no hay ning\u00fan recurso ra\u00edz definido. A\u00f1ade una p\u00e1gina de inicio HTML est\u00e1tica con enlaces a su punto final. Crea el archivo index.html en /src /main /resources /static/ . Modifica la plantilla predeterminada o reempl\u00e1zala con el siguiente c\u00f3digo HTML: <!DOCTYPE HTML> <html> <head> <title>Your first Spring application</title> <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" /> </head> <body> <p><a href=\"/hello\">Greet the world!</a></p> <form action=\"/hello\" method=\"GET\" id=\"nameForm\"> <div> <label for=\"nameField\">How should the app call you?</label> <input name=\"myName\" id=\"nameField\"> <button>Greet me!</button> </div> </form> </body> </html> Ejecuta la aplicaci\u00f3n de nuevo. Ahora tu aplicaci\u00f3n servir\u00e1 index.html como recurso ra\u00edz en http://localhost:8080/ .","title":"Primera aplicaci\u00f3n SpringBoot"},{"location":"SpringData/","text":"Spring Data Spring Data es un proyecto dentro del ecosistema Spring que proporciona herramientas y abstracciones para facilitar el acceso a bases de datos y otras fuentes de datos de manera eficiente y consistente. Su objetivo principal es simplificar la interacci\u00f3n con diferentes tipos de bases de datos, desde bases de datos relacionales (como PostgreSQL, MySQL) hasta bases de datos NoSQL (como MongoDB, Cassandra). \u00bfPara qu\u00e9 se utiliza? 1) Acceso Simplificado a Datos: Reduce la necesidad de escribir consultas SQL complejas o c\u00f3digo JDBC al exponer m\u00e9todos predefinidos para operaciones comunes. Permite realizar operaciones CRUD (Crear, Leer, Actualizar, Eliminar) con facilidad. 2) Abstracci\u00f3n de Repositorios: Ofrece la interfaz Repository y subinterfaces como CrudRepository y JpaRepository que proporcionan m\u00e9todos est\u00e1ndar para la gesti\u00f3n de entidades en bases de datos relacionales. 3) Consultas Personalizadas: Permite escribir consultas personalizadas mediante anotaciones como @Query . Tambi\u00e9n admite la creaci\u00f3n de m\u00e9todos de consulta basados en el nombre del m\u00e9todo, como findByNombre(String nombre) . 4) Compatibilidad con M\u00faltiples Tecnolog\u00edas de Bases de Datos: Relacionales: Mediante JPA (Java Persistence API). NoSQL: MongoDB, Redis, Neo4j, Cassandra, etc. Buscadores: Elasticsearch, Solr. 5) Configuraci\u00f3n Declarativa: Al integrar Spring Data con Spring Boot, se pueden configurar muchas opciones mediante propiedades en application.properties , evitando configuraciones manuales detalladas. 6) Integraci\u00f3n con Spring Boot: Con dependencias espec\u00edficas como spring-boot-starter-data-jpa o spring-boot-starter-data-mongodb , Spring Data se integra perfectamente con el resto del ecosistema de Spring. Principales M\u00f3dulos de Spring Data Spring Data JPA: : Proporciona una integraci\u00f3n con JPA para bases de datos relacionales. Es ideal para trabajar con entidades Java mapeadas a tablas de bases de datos. JPA es la especificaci\u00f3n para persistir, leer y gestionar data desde los objetos Java a la base de datos. Spring Data MongoDB: : Facilita el acceso a bases de datos MongoDB, una base de datos NoSQL orientada a documentos. Spring Data Redis: : Para aplicaciones que necesitan interactuar con Redis, una base de datos en memoria. Spring Data Cassandra: : Proporciona soporte para bases de datos distribuidas como Cassandra. Spring Data Elasticsearch: : Simplifica las interacciones con Elasticsearch, un motor de b\u00fasqueda y an\u00e1lisis. Spring Data JPA Spring Data JPA es parte de Spring Framework. No es una implementaci\u00f3n de JPA como Hibernate, sino una abstracci\u00f3n para reducir la complejidad de la integraci\u00f3n con bases de datos relacionales desde aplicaciones Java. Spring Data JPA puede utilizar Hibernate, Eclipse Link u otra implementaci\u00f3n. Anotaciones Comunes 1. Mapeo de Entidades (JPA Est\u00e1ndar) Estas anotaciones son parte de JPA y permiten mapear clases y relaciones a tablas en la base de datos. @Entity - Marca una clase como una entidad JPA, mapeada a una tabla en la base de datos. @Entity data class User( @Id val id: Long, val name: String ) @Table - Especifica el nombre de la tabla que corresponde a la entidad. @Entity @Table(name = \"users\") data class User( @Id val id: Long, val name: String ) @Id - Indica que un campo es la clave primaria de la tabla. @Id val id: Long @GeneratedValue - Define c\u00f3mo se genera el valor de la clave primaria. Estrategias comunes: GenerationType.IDENTITY , GenerationType.SEQUENCE , etc. @Id @GeneratedValue(strategy = GenerationType.IDENTITY) val id: Long @Column - Configura una columna de la tabla, como nombre, si es nula o \u00fanica. @Column(name = \"user_name\", nullable = false, unique = true) val name: String @ManyToOne , @OneToMany , @OneToOne , @ManyToMany Define relaciones entre entidades. @ManyToOne val department: Department @JoinColumn - Especifica la columna que act\u00faa como clave for\u00e1nea. @ManyToOne @JoinColumn(name = \"department_id\") val department: Department @Lob - Indica que un campo es un objeto grande (texto o binario). @Lob val description: String @Transient - Excluye un campo del mapeo de base de datos (no se almacena). @Transient val calculatedField: String 2. Espec\u00edficas de Spring Data JPA Estas anotaciones son propias de Spring Data JPA y extienden la funcionalidad de JPA. @Repository - Marca una interfaz o clase como repositorio Spring. @Repository interface UserRepository : JpaRepository<User, Long> @Query - Define una consulta personalizada usando JPQL o SQL nativo. Ejemplo (JPQL): @Query(\"SELECT u FROM User u WHERE u.name = :name\") fun findByName(@Param(\"name\") name: String): List<User> Ejemplo (SQL nativo): @Query(value = \"SELECT * FROM users WHERE user_name = :name\", nativeQuery = true) fun findByNameNative(@Param(\"name\") name: String): List<User> @Param - Define par\u00e1metros nombrados para consultas con @Query . @Query(\"SELECT u FROM User u WHERE u.name = :name\") fun findByName(@Param(\"name\") name: String): List<User> @Modifying - Se utiliza con consultas @Query para operaciones de actualizaci\u00f3n o eliminaci\u00f3n. @Modifying @Query(\"UPDATE User u SET u.name = :name WHERE u.id = :id\") fun updateName(@Param(\"id\") id: Long, @Param(\"name\") name: String) @EnableJpaRepositories - Habilita la funcionalidad de Spring Data JPA y escanea paquetes para detectar repositorios. @EnableJpaRepositories(basePackages = [\"com.example.repository\"]) @EntityGraph - Especifica c\u00f3mo cargar las relaciones en una consulta, evitando lazy loading. @EntityGraph(attributePaths = [\"roles\"]) fun findByName(name: String): User 3. Transacciones @Transactional - Marca un m\u00e9todo o clase para ejecutar dentro de una transacci\u00f3n. @Transactional fun updateUserDetails(user: User) { ... } @Rollback - Utilizada en pruebas para forzar la reversi\u00f3n de una transacci\u00f3n. @Transactional @Rollback fun testSaveUser() { ... } Consultas a la Base de Datos Las consultas a la Base de datos las podemos hacer de dos maneras, utilizando la convenci\u00f3n de nombres en funciones de Spring Data JPA o con la anotaci\u00f3n @Query . La convenci\u00f3n de nombres se utiliza: En consultas sencillas y que no requieren l\u00f3gica compleja ni m\u00faltiples combinaciones. Cuando quieres mantener un c\u00f3digo m\u00e1s limpio y directo. La anotaci\u00f3n @Query se utiliza: En consultas complejas que involucren m\u00faltiples tablas, condiciones avanzadas o subconsultas. Si prefieres optimizar manualmente las consultas. Cuando la convenci\u00f3n de nombres generar\u00eda un nombre de m\u00e9todo excesivamente largo. @Query Estructura b\u00e1sica: @Query(\"SELECT e FROM EntityName e WHERE e.property = :value\") fun findByProperty(@Param(\"value\") value: String): List<EntityName> Se utilizan nombres de entidades y propiedades de las clases en lugar de nombres de tablas y columnas. Se puede navegar por relaciones entre entidades. :nombreParametro para par\u00e1metros din\u00e1micos. Ejemplo simple: @Query(\"SELECT c FROM Comarca c WHERE c.provincia = :provincia\") fun findByProvincia(@Param(\"provincia\") provincia: String): List<Comarca> Ejemplo con relaciones: Siguiendo con nuestro ejemplo de geo_ad, la consulta par buscar Institutos en una Provincia por Poblaci\u00f3n M\u00ednima quedar\u00eda as\u00ed: @Query(\"\"\" SELECT i FROM Institut i JOIN i.poblacio p JOIN p.comarca c WHERE c.provincia = :provincia AND p.poblacion >= :minPoblacion \"\"\") fun findByProvinciaAndPoblacion( @Param(\"provincia\") provincia: String, @Param(\"minPoblacion\") minPoblacion: Int ): List<Institut> Este mismo ejemplo utilizando convenci\u00f3n de nombres quedar\u00eda as\u00ed: @Repository interface InstitutRepository : JpaRepository<Institut, String> { fun findByPoblacioComarcaProvinciaAndPoblacioPoblacionGreaterThanEqual( provincia: String, minPoblacion: Int ): List<Institut> } findBy : Indica que es un m\u00e9todo de consulta. PoblacioComarcaProvincia : Navega por las relaciones de las entidades Institut Poblacio -> Comarca para filtrar por la provincia. AndPoblacioPoblacionGreaterThanEqual : Navega por Institut -> Poblacio y aplica el filtro de poblaci\u00f3n m\u00ednima. A medida que las relaciones aumentan en complejidad, los nombres de los m\u00e9todos pueden volverse dif\u00edciles de leer y mantener. Convenci\u00f3n de Nombres en Spring JPA Spring Data JPA permite definir m\u00e9todos en repositorios siguiendo una convenci\u00f3n de nombres espec\u00edfica. Esto simplifica la escritura de consultas comunes sin necesidad de usar JPQL o SQL. Para ello analiza el nombre de los m\u00e9todos en el repositorio e interpreta su significado para generar consultas autom\u00e1ticamente. La estructura b\u00e1sica es: findBy + NombreDeCampo + Condici\u00f3n 1) findBy : Indica que se busca una entidad en la base de datos. Alternativas: readBy (lectura de datos) queryBy (consulta de datos) getBy (obtener datos) 2) NombreDeCampo : Debe coincidir exactamente con el nombre del atributo en la entidad. Se puede incluir navegaci\u00f3n de atributos para relaciones (EntidadRelacionada.Atributo). 3) Condici\u00f3n (opcional): Permite a\u00f1adir operadores l\u00f3gicos como And, Or, etc. Ejemplo: findByNombreAndEdad. Ejemplos de m\u00e9todos seg\u00fan la convenci\u00f3n Consultas simples M\u00e9todo: findByNombre(String nombre) Consulta generada: SELECT * FROM entidad WHERE nombre = ? Consultas con condiciones M\u00e9todo: findByNombreAndEdad(String nombre, Integer edad) Consulta generada: SELECT * FROM entidad WHERE nombre = ? AND edad = ? Consultas con orden M\u00e9todo: findByNombreOrderByEdadDesc(String nombre) Consulta generada: SELECT * FROM entidad WHERE nombre = ? ORDER BY edad DESC Consultas con relaciones. Si hay una relaci\u00f3n entre entidades, se puede navegar por los campos relacionados: M\u00e9todo: findByComarcaNomC(String nomC) Consulta generada: SELECT * FROM entidad e JOIN comarca c ON e.comarca_id = c.id WHERE c.nomC = ? Palabras clave en la convenci\u00f3n Consideraciones Coincidencia exacta del nombre del campo : Los nombres deben coincidir con los atributos definidos en la entidad. Relaciones : Usa la notaci\u00f3n EntidadRelacionada.Atributo para navegar entre tablas relacionadas. Orden : Los m\u00e9todos pueden incluir palabras clave de ordenaci\u00f3n, como OrderBy. Par\u00e1metros : Los m\u00e9todos generados reciben par\u00e1metros en el mismo orden en que se declaran en el nombre del m\u00e9todo. Ejemplo ampliado de Spring MVC Para practicar la funcionalidad de Spring Data JPA vamos a seguir con el ejemplo visto en el apartado de Spring MVC PrimerSpringMVC . Recordemos que la aplicaci\u00f3n accede a la base de datos local en Docker. En este ejemplo vamos a mapear las 3 tablas de la base de datos: comarca, poblacio e institut y a realizar los cambios necesarios para crear algunas consultas y operaciones CRUD. Modelo (Entidad JPA) Entidad Comarca . La \u00fanica diferencia con el ejemplo que tenemos es que mapea el nombre de la columna nom_c por nomC para evitar problemas de convenci\u00f3 de nombres. import jakarta.persistence.* @Entity @Table(name = \"comarca\") data class comarca( @Id @Column(name = \"nom_c\") val nomC: String = \"\", @Column(name = \"provincia\") val provincia: String? = null ) Entidad Poblacio import jakarta.persistence.* @Entity @Table(name = \"poblacio\") data class poblacio( @Id @Column(name = \"cod_m\") val codM: Int = 0, @Column(name = \"nom\") val nom: String = \"\", @Column(name = \"poblacio\") val poblacio: Int? = null, @Column(name = \"extensio\") val extensio: Double? = null, @Column(name = \"altura\") val altura: Int? = null, @Column(name = \"longitud\") val longitud: String? = null, @Column(name = \"latitud\") val latitud: String? = null, @Column(name = \"llengua\") val llengua: String? = null, @ManyToOne //clave ajena a comarca @JoinColumn(name = \"nom_c\", referencedColumnName = \"nom_c\") val comarca: comarca? = null ) Entidad Institut import jakarta.persistence.* @Entity @Table(name = \"institut\") data class institut( @Id @Column(name = \"codi\") val codi: String = \"\", @Column(name = \"adreca\") val adreca: String? = null, @Column(name = \"codpostal\") val codPostal: Int? = null, @Column(name = \"nom\") val nom: String? = null, @Column(name = \"numero\") val numero: String? = null, @ManyToOne //clave ajena a poblacio @JoinColumn(name = \"cod_m\", referencedColumnName = \"cod_m\") val poblacio: poblacio? = null ) Repositorio Repositorio para Comarca: ComarcaRepository . import org.example.primerspringmvc.model.comarca import org.springframework.data.jpa.repository.JpaRepository import org.springframework.stereotype.Repository @Repository interface ComarcaRepository : JpaRepository<comarca, String> { // Obtener comarcas de una provincia fun findByProvincia(provincia: String): List<comarca> } Repositorio para Institut: InstitutRepository package org.example.primerspringmvc.repository import org.example.primerspringmvc.model.institut import org.springframework.data.jpa.repository.JpaRepository interface InstitutRepository : JpaRepository<institut, String> { // Obtener institutos de una poblaci\u00f3n fun findByPoblacioNom(nom: String): List<institut> // Obtener institutos de una comarca fun findByPoblacioComarcaNomC(nomC: String): List<institut> // Obtener institutos de una provincia fun findByPoblacioComarcaProvincia(provincia: String): List<institut> // Obtener institutos cuya poblaci\u00f3n es mayor a fun findByPoblacioPoblacioGreaterThan(poblacio: Int): List<institut> } Repositorio para Poblacio: PoblacioRepository import org.example.primerspringmvc.model.poblacio import org.springframework.data.jpa.repository.JpaRepository interface PoblacioRepository : JpaRepository<poblacio, String> { // Obtener poblaciones de una comarca fun findByComarcaNomC(nomC: String): List<poblacio> // Obtener poblaciones de una provincia fun findByComarcaProvincia(provincia: String): List<poblacio> } Controlador ComarcaController import org.example.primerspringmvc.model.comarca import org.springframework.stereotype.Controller import org.example.primerspringmvc.repository.* import org.springframework.ui.Model import org.springframework.web.bind.annotation.* // Muestra todas las poblaciones @GetMapping fun listarTodasPoblacions(model: Model): String { val poblacions = poblacioRepository.findAll() model.addAttribute(\"poblacions\", poblacions) return \"poblacions\" // Vista Thymeleaf para mostrar todas las poblaciones } // Muestra las poblaciones por comarca @GetMapping(\"/por-comarca\") fun listarPoblacionsPorComarca(@RequestParam comarca: String, model: Model): String { val poblacions = poblacioRepository.findByComarcaNomC(comarca) model.addAttribute(\"poblacions\", poblacions) return \"poblacions\" // Vista Thymeleaf para mostrar las poblaciones por comarca } InstitutController import org.example.primerspringmvc.model.institut import org.example.primerspringmvc.repository.InstitutRepository import org.springframework.stereotype.Controller import org.springframework.ui.Model import org.springframework.web.bind.annotation.* @Controller @RequestMapping(\"/instituts\") class InstitutController(private val institutRepository: InstitutRepository) { //Muestra todos los intitutos @GetMapping fun listarInstituts(model: Model): String { val instituts = institutRepository.findAll() model.addAttribute(\"instituts\", instituts) return \"instituts\" } // Muestra institutos de una poblaci\u00f3n @GetMapping(\"/por-poblacio\") fun obtenerInstitutsPoblacio(@RequestParam poblacio: String, model: Model): String { val institutsPoblacio = institutRepository.findByPoblacioNom(poblacio) model.addAttribute(\"instituts\", institutsPoblacio) return \"instituts\" // Plantilla para mostrar la lista de institutos } // Muestra institutos de una comarca @GetMapping(\"/por-comarca\") fun obtenerInstitutsComarca(@RequestParam comarca: String, model: Model): String { val institutsComarca = institutRepository.findByPoblacioComarcaNomC(comarca) model.addAttribute(\"instituts\", institutsComarca) return \"instituts\" // Plantilla para mostrar la lista de institutos } // Muestra institutos de una provincia @GetMapping(\"/por-provincia\") fun obtenerInstitutsProvincia(@RequestParam provincia: String, model: Model): String { val institutsProvincia = institutRepository.findByPoblacioComarcaProvincia(provincia) model.addAttribute(\"instituts\", institutsProvincia) return \"instituts\" // Plantilla para mostrar la lista de institutos } // Muestra institutos con poblaci\u00f3n superior a un valor @GetMapping(\"/poblacion-superior\") fun obtenerInstitutsPoblacionSuperior(@RequestParam poblacio: Int, model: Model): String { val institutsConPoblacionSuperiorA = institutRepository.findByPoblacioPoblacioGreaterThan(poblacio) model.addAttribute(\"instituts\", institutsConPoblacionSuperiorA) return \"instituts\" // Plantilla para mostrar la lista de institutos } } PoblacioController import org.example.primerspringmvc.repository.PoblacioRepository import org.springframework.stereotype.Controller import org.springframework.ui.Model import org.springframework.web.bind.annotation.* @Controller @RequestMapping(\"/poblacions\") class PoblacioController(private val poblacioRepository: PoblacioRepository) { // Muestra todas las poblaciones @GetMapping fun listarTodasPoblacions(model: Model): String { val poblacions = poblacioRepository.findAll() model.addAttribute(\"poblacions\", poblacions) return \"poblacions\" // Vista Thymeleaf para mostrar todas las poblaciones } // Muestra las poblaciones por comarca @GetMapping(\"/por-comarca\") fun listarPoblacionsPorComarca(@RequestParam comarca: String, model: Model): String { val poblacions = poblacioRepository.findByComarcaNomC(comarca) model.addAttribute(\"poblacions\", poblacions) return \"poblacions\" // Vista Thymeleaf para mostrar las poblaciones por comarca } @GetMapping(\"/por-provincia\") fun listarPoblacionsPorProvincia(@RequestParam provincia: String, model: Model): String { val poblacions = poblacioRepository.findByComarcaProvincia(provincia) model.addAttribute(\"poblacions\", poblacions) return \"poblacions\" // Vista Thymeleaf para mostrar las poblaciones por comarca } } Vistas Thymeleaf Vista comarcas.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Lista de Comarcas</title> </head> <body> <h1>Lista de Comarcas</h1> <table border=\"1\"> <tr> <th>Comarca</th> <th>Provincia</th> </tr> <tr th:each=\"comarca : ${comarcas}\"> <td th:text=\"${comarca.nomC}\">Comarca</td> <td th:text=\"${comarca.provincia}\">Provincia</td> </tr> </table> </body> </html> Vista nueva-comarca.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Nueva Comarca</title> </head> <body> <h1>Nueva Comarca</h1> <form th:action=\"@{/comarcas/nueva}\" th:object=\"${comarca}\" method=\"post\"> <label for=\"nomC\">Comarca:</label> <input type=\"text\" id=\"nomC\" name=\"nomC\" th:value=\"*{nomC}\" required><br> <label for=\"provincia\">Provincia:</label> <input type=\"text\" id=\"provincia\" name=\"provincia\" th:value=\"*{provincia}\" required><br> <button type=\"submit\">Guardar</button> </form> </body> </html> Vista instituts.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Instituts</title> </head> <body> <h1>Llista d'Instituts</h1> <table border=\"1\"> <tr> <th>Codi</th> <th>Nom</th> <th>Adre\u00e7a</th> <th>Poblaci\u00f3</th> <th>Habitants</th> <th>Comarca</th> <th>Provincia</th> </tr> <tr th:each=\"institut : ${instituts}\"> <td th:text=\"${institut.codi}\">Codi</td> <td th:text=\"${institut.nom}\">Nom</td> <td th:text=\"${institut.adreca}\">Adre\u00e7a</td> <td th:text=\"${institut.poblacio?.nom}\">Poblaci\u00f3</td> <td th:text=\"${institut.poblacio?.poblacio}\">Habitants</td> <td th:text=\"${institut.poblacio?.comarca?.nomC}\">Comarca</td> <td th:text=\"${institut.poblacio?.comarca?.provincia}\">Provincia</td> </tr> </table> </body> </html> Vista poblacions.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Poblacions</title> </head> <body> <h1>Llista de Poblacions per Comarca</h1> <table border=\"1\"> <tr> <th>Codi</th> <th>Nom</th> <th>Comarca</th> <th>Provincia</th> </tr> <tr th:each=\"poblacio : ${poblacions}\"> <td th:text=\"${poblacio.codM}\">Codi</td> <td th:text=\"${poblacio.nom}\">Nom</td> <td th:text=\"${poblacio.comarca?.nomC}\">Comarca</td> <td th:text=\"${poblacio.comarca?.provincia}\">Provincia</td> </tr> </table> </body> </html> Con esta configuraci\u00f3n podemos listar los siguientes ejemplos : Todos los institutos: http://localhost:8888/instituts Todas las poblaciones: http://localhost:8888/poblacions Todas las comarcas: http://localhost:8888/comarcas Listar institutos de una poblaci\u00f3n: http://localhost:8888/instituts/por-poblacio?poblacio=Gandia Listar institutos de una comarca: http://localhost:8888/instituts/por-comarca?comarca=Safor Listar institutos de una provincia: http://localhost:8888/instituts/por-provincia?provincia=Alacant Listar comarcas de una provincia: http://localhost:8888/comarcas/por-provincia?provincia=Alacant Listar poblaciones de una comarca http://localhost:8888/poblacions/por-comarca?comarca=Safor Listar poblaciones de una provincia: http://localhost:8888/poblacions/por-provincia?provincia=Alacant Listar institutos con poblaci\u00f3n superior a un valor: http://localhost:8888/instituts/poblacion-superior?poblacio=20000 Spring Data MongoDB El componente Spring MongoDB Es un m\u00f3dulo de Spring Data que facilita la integraci\u00f3n de aplicaciones Spring con MongoDB . Adem\u00e1s proporciona una abstracci\u00f3n sobre las operaciones b\u00e1sicas de MongoDB como CRUD, consultas personalizadas, y soporte para agregaciones. Requisitos Tener MongoDB instalado o utilizar una instancia en la nube o en un contenedor Docker. Spring Boot configurado con Maven (en nuestro caso) o Gradle. Dependencias Maven <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-data-mongodb</artifactId> </dependency> Configuraci\u00f3n de las propiedades application.properties spring.data.mongodb.host=localhost spring.data.mongodb.port=27017 spring.data.mongodb.database=nombre_base_de_datos Si est\u00e1s usando MongoDB con autenticaci\u00f3n, a\u00f1ade: spring.data.mongodb.username=usuario spring.data.mongodb.password=contrase\u00f1a Anotaciones comunes Estas anotaciones permiten mapear documentos, gestionar colecciones y realizar operaciones de manera sencilla. Las principales anotaciones utilizadas en Spring Data MongoDB son: @Document Se utiliza para marcar una clase como un documento MongoDB que ser\u00e1 persistido en una colecci\u00f3n. @Document(collection = \"coleccion\") * collection : Especifica el nombre de la colecci\u00f3n. Si no se define, se usa el nombre de la clase en min\u00fasculas. @Id Marca un campo como identificador \u00fanico del documento. Este campo se mapea al campo _id en MongoDB. @Field Se utiliza para mapear un campo de la clase a un campo espec\u00edfico en el documento MongoDB. @Field(\"descripcion\") val descripcionProducto: String @Transient Indica que un campo no debe ser persistido en la base de datos. @Transient val temporal: String = \"No se guarda en MongoDB\" @DBRef Se utiliza para definir una relaci\u00f3n entre documentos, similar a una clave for\u00e1nea. El atributo se mapea a una referencia en MongoDB. @DBRef val categoria: Categoria @CompoundIndex Define \u00edndices compuestos en la colecci\u00f3n para optimizar consultas. @CompoundIndex(def = \"{'nombre': 1, 'precio': -1}\", unique = true) * def: Define los campos que forman el \u00edndice. * unique: Indica si el \u00edndice debe ser \u00fanico. Aplicaci\u00f3n Spring Data MongoDB En este apartado del tema ya tenemos que saber como crear una aplicaic\u00f3n Spring Boot desde IntelliJ, solo necesitas saber las dependencias necesarias y las anotaciones para incorporar Spring Data MongoDB y poco m\u00e1s. El resto ya depende de lo que quieras construir con la base de datos. Para este ejemplo partiremos de un archivo json que contiene 10 men\u00fas con sus correspondientes platos. Has de a\u00f1adir este documento como una colecci\u00f3n a tu BD Mongo. Lo tienes disponible en la carpeta recursos y tambi\u00e9n lo puedes copiar directamente. Lo primero que debes hacer es insertar este archivo en tu MongoDB local, como una colecci\u00f3n (InsertMany) Archivo json con los menus: [ { \"_id\": \"1\", \"nombre\": \"Men\u00fa Mediterr\u00e1neo\", \"descripcion\": \"Un men\u00fa saludable inspirado en la dieta mediterr\u00e1nea.\", \"fecha\": \"2025-01-08\", \"platos\": [ { \"nombre\": \"Ensalada Griega\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Lechuga\", \"Tomate\", \"Pepino\", \"Aceitunas\", \"Queso Feta\"], \"precio\": 5.5 }, { \"nombre\": \"Moussaka\", \"categoria\": \"Principal\", \"ingredientes\": [\"Berenjena\", \"Carne de Cordero\", \"Tomate\", \"Bechamel\", \"Queso\"], \"precio\": 12.0 } ], \"precioTotal\": 17.5 }, { \"_id\": \"2\", \"nombre\": \"Men\u00fa Asi\u00e1tico\", \"descripcion\": \"Sabores frescos y aut\u00e9nticos de Asia.\", \"fecha\": \"2025-01-09\", \"platos\": [ { \"nombre\": \"Rollitos de Primavera\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Zanahoria\", \"Col\", \"Brotes de Soja\", \"Fideos de Arroz\"], \"precio\": 4.0 }, { \"nombre\": \"Pad Thai\", \"categoria\": \"Principal\", \"ingredientes\": [\"Fideos de Arroz\", \"Camarones\", \"Tofu\", \"Man\u00ed\"], \"precio\": 10.0 } ], \"precioTotal\": 14.0 }, { \"_id\": \"3\", \"nombre\": \"Men\u00fa Vegetariano\", \"descripcion\": \"Opciones deliciosas sin carne.\", \"fecha\": \"2025-01-10\", \"platos\": [ { \"nombre\": \"Hummus con Pan de Pita\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Garbanzos\", \"Tahini\", \"Lim\u00f3n\", \"Ajo\"], \"precio\": 4.5 }, { \"nombre\": \"Lasa\u00f1a Vegetariana\", \"categoria\": \"Principal\", \"ingredientes\": [\"Pasta\", \"Espinacas\", \"Ricotta\", \"Tomate\"], \"precio\": 9.0 } ], \"precioTotal\": 13.5 }, { \"_id\": \"4\", \"nombre\": \"Men\u00fa Italiano\", \"descripcion\": \"Especialidades cl\u00e1sicas de Italia.\", \"fecha\": \"2025-01-11\", \"platos\": [ { \"nombre\": \"Bruschetta\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Pan\", \"Tomate\", \"Albahaca\", \"Aceite de Oliva\"], \"precio\": 5.0 }, { \"nombre\": \"Pizza Margarita\", \"categoria\": \"Principal\", \"ingredientes\": [\"Masa de Pizza\", \"Tomate\", \"Mozzarella\", \"Albahaca\"], \"precio\": 10.0 } ], \"precioTotal\": 15.0 }, { \"_id\": \"5\", \"nombre\": \"Men\u00fa Mexicano\", \"descripcion\": \"Platos picantes y llenos de sabor.\", \"fecha\": \"2025-01-12\", \"platos\": [ { \"nombre\": \"Guacamole con Totopos\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Aguacate\", \"Lim\u00f3n\", \"Cilantro\", \"Totopos\"], \"precio\": 4.5 }, { \"nombre\": \"Tacos al Pastor\", \"categoria\": \"Principal\", \"ingredientes\": [\"Tortilla\", \"Carne de Cerdo\", \"Pi\u00f1a\", \"Cebolla\"], \"precio\": 9.0 } ], \"precioTotal\": 13.5 }, { \"_id\": \"6\", \"nombre\": \"Men\u00fa Americano\", \"descripcion\": \"Comida cl\u00e1sica de los Estados Unidos.\", \"fecha\": \"2025-01-13\", \"platos\": [ { \"nombre\": \"Alitas de Pollo\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Pollo\", \"Salsa BBQ\", \"Especias\"], \"precio\": 6.0 }, { \"nombre\": \"Hamburguesa con Queso\", \"categoria\": \"Principal\", \"ingredientes\": [\"Pan\", \"Carne de Res\", \"Queso\", \"Lechuga\"], \"precio\": 10.0 } ], \"precioTotal\": 16.0 }, { \"_id\": \"7\", \"nombre\": \"Men\u00fa de Mariscos\", \"descripcion\": \"Frescos sabores del oc\u00e9ano.\", \"fecha\": \"2025-01-14\", \"platos\": [ { \"nombre\": \"C\u00f3ctel de Camarones\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Camarones\", \"Salsa C\u00f3ctel\", \"Lim\u00f3n\"], \"precio\": 7.0 }, { \"nombre\": \"Paella de Mariscos\", \"categoria\": \"Principal\", \"ingredientes\": [\"Arroz\", \"Camarones\", \"Mejillones\", \"Calamares\"], \"precio\": 12.0 } ], \"precioTotal\": 19.0 }, { \"_id\": \"8\", \"nombre\": \"Men\u00fa Franc\u00e9s\", \"descripcion\": \"Platos refinados y elegantes.\", \"fecha\": \"2025-01-15\", \"platos\": [ { \"nombre\": \"Quiche Lorraine\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Huevo\", \"Nata\", \"Tocino\", \"Queso Gruy\u00e8re\"], \"precio\": 6.5 }, { \"nombre\": \"Ratatouille\", \"categoria\": \"Principal\", \"ingredientes\": [\"Berenjena\", \"Calabac\u00edn\", \"Tomate\", \"Pimiento\"], \"precio\": 9.5 } ], \"precioTotal\": 16.0 }, { \"_id\": \"9\", \"nombre\": \"Men\u00fa Indio\", \"descripcion\": \"Sabores especiados y ex\u00f3ticos.\", \"fecha\": \"2025-01-16\", \"platos\": [ { \"nombre\": \"Samosas\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Papas\", \"Especias\", \"Masa Frita\"], \"precio\": 4.0 }, { \"nombre\": \"Pollo Tikka Masala\", \"categoria\": \"Principal\", \"ingredientes\": [\"Pollo\", \"Salsa de Tomate\", \"Especias\", \"Crema\"], \"precio\": 11.0 } ], \"precioTotal\": 15.0 }, { \"_id\": \"10\", \"nombre\": \"Men\u00fa Japon\u00e9s\", \"descripcion\": \"Delicados sabores de Jap\u00f3n.\", \"fecha\": \"2025-01-17\", \"platos\": [ { \"nombre\": \"Sopa de Miso\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Miso\", \"Tofu\", \"Alga Wakame\"], \"precio\": 3.5 }, { \"nombre\": \"Sushi Variado\", \"categoria\": \"Principal\", \"ingredientes\": [\"Arroz\", \"Pescado\", \"Alga Nori\", \"Vegetales\"], \"precio\": 12.5 } ], \"precioTotal\": 16.0 } ] Modelo MVC Lo siguiente ser\u00e1 crear la estructura del modelo MVC con los archivos necesarios. En la siguiene imagen podeis ver como quedar\u00e1: Modelo Los modelos son las clases que representan las colecciones en MongoDB. Menu.kt import org.springframework.data.annotation.Id import org.springframework.data.mongodb.core.mapping.Document @Document(collection = \"menus\") // Nombre de la colecci\u00f3n en MongoDB data class Menu( @Id val id: String, // Identificador \u00fanico del men\u00fa val nombre: String, // Nombre del men\u00fa val descripcion: String, // Descripci\u00f3n del men\u00fa val fecha: String, // Fecha asociada al men\u00fa val platos: List<Plato> = emptyList(), // Lista de platos val precioTotal: Double = 0.0 // Precio total del men\u00fa ) data class Plato( val nombre: String, val categoria: String, val ingredientes: List<String> = emptyList(), val precio: Double = 0.0 ) Repositorios Proporciona una interfaz MongoRepository que simplifica las operaciones CRUD. MenuRepository.kt import org.springframework.data.mongodb.repository.MongoRepository import org.springframework.stereotype.Repository import org.example.primerspringmongo.model.* @Repository interface MenuRepository : MongoRepository<Menu, String> { fun findByNombre(nombre: String): List<Menu> fun findByPlatosCategoria(categoria: String): List<Menu> } Controlador Gestiona las solicitudes entrantes, procesa datos y determina las respuestas adecuadas. MenuController.kt import org.example.primerspringmongo.model.Menu import org.example.primerspringmongo.repository.MenuRepository import org.springframework.stereotype.Controller import org.springframework.ui.Model import org.springframework.web.bind.annotation.* @Controller @RequestMapping(\"/menus\") class MenuController(private val menuRepository: MenuRepository) { // Listar todos los men\u00fas @GetMapping fun listarMenus(model: Model): String { val menus = menuRepository.findAll() model.addAttribute(\"menus\", menus) return \"menus/listar\" } @GetMapping(\"/buscar\") fun buscarPorNombre(@RequestParam nombre: String, model: Model): String { val menus = menuRepository.findByNombre(nombre) // Consulta en el repositorio model.addAttribute(\"menus\", menus) // Pasar los men\u00fas al modelo model.addAttribute(\"nombre\", nombre) // Pasar el nombre buscado return \"menus/listar\" // Nombre de la plantilla Thymeleaf } // Guardar un nuevo men\u00fa @PostMapping(\"/guardar\") fun guardarMenu(@ModelAttribute menu: Menu): String { menuRepository.save(menu) return \"redirect:/menus\" } // Ver detalles de un men\u00fa @GetMapping(\"/{id}\") fun verDetalles(@PathVariable id: String, model: Model): String { val menu = menuRepository.findById(id) if (menu.isPresent) { model.addAttribute(\"menu\", menu.get()) return \"menus/detalles\" } return \"redirect:/menus\" } // Mostrar formulario para editar un men\u00fa @GetMapping(\"/editar/{id}\") fun mostrarFormularioEditar(@PathVariable id: String, model: Model): String { val menu = menuRepository.findById(id) if (menu.isPresent) { model.addAttribute(\"menu\", menu.get()) return \"menus/editar\" } return \"redirect:/menus\" } // Actualizar un men\u00fa existente @PostMapping(\"/actualizar/{id}\") fun actualizarMenu(@PathVariable id: String, @ModelAttribute menu: Menu): String { if (menuRepository.existsById(id)) { menuRepository.save(menu) } return \"redirect:/menus\" } // Eliminar un men\u00fa @GetMapping(\"/eliminar/{id}\") fun eliminarMenu(@PathVariable id: String): String { menuRepository.deleteById(id) return \"redirect:/menus\" } } PlatoController.kt import org.example.primerspringmongo.repository.MenuRepository import org.springframework.stereotype.Controller import org.springframework.ui.Model import org.springframework.web.bind.annotation.* @Controller @RequestMapping(\"/platos\") class PlatoController(private val menuRepository: MenuRepository) { // Listar todos los platos de un men\u00fa @GetMapping(\"/{menuId}\") fun listarPlatos(@PathVariable menuId: String, model: Model): String { val menu = menuRepository.findById(menuId) if (menu.isPresent) { model.addAttribute(\"menu\", menu.get()) model.addAttribute(\"platos\", menu.get().platos) return \"platos/listar\" } return \"redirect:/menus\" } @GetMapping(\"/categoria\") fun buscarPorCategoria(@RequestParam categoria: String, model: Model): String { val menus = menuRepository.findByPlatosCategoria(categoria) // Consulta en el repositorio model.addAttribute(\"menus\", menus) // Lista de men\u00fas encontrados model.addAttribute(\"categoriaBuscada\", categoria) // Categor\u00eda buscada return \"platos/buscarPorCategoria\" // Plantilla Thymeleaf } @GetMapping(\"/{menuId}/ingredientes/{platoNombre}\") fun verIngredientes( @PathVariable menuId: String, @PathVariable platoNombre: String, model: Model ): String { val menu = menuRepository.findById(menuId) if (menu.isPresent) { val plato = menu.get().platos.find { it.nombre == platoNombre } if (plato != null) { println(\"Plato encontrado: $plato\") println(\"Ingredientes: ${plato.ingredientes}\") model.addAttribute(\"menu\", menu.get()) model.addAttribute(\"plato\", plato) model.addAttribute(\"ingredientes\", plato.ingredientes ?: emptyList<String>()) return \"platos/ingredientes\" } } model.addAttribute(\"error\", \"El plato o el men\u00fa no existen.\") return \"error\" } } Vista Permiten visualizar los resultados con un formato personalizado. En la siguiente imagen ten\u00e9is la estructura de los archivos: Vistas para visualizar los menus: /menus listar.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Lista de Men\u00fas</title> </head> <body> <h1>Lista de Men\u00fas</h1> <a href=\"/menus/crear\">Crear Nuevo Men\u00fa</a> <table border=\"1\"> <thead> <tr> <th>Nombre</th> <th>Descripci\u00f3n</th> <th>Acciones</th> </tr> </thead> <tbody> <tr th:each=\"menu : ${menus}\"> <td th:text=\"${menu.nombre}\"></td> <td th:text=\"${menu.descripcion}\"></td> <td> <a th:href=\"@{'/menus/' + ${menu.id}}\">Detalles</a> <a th:href=\"@{'/menus/editar/' + ${menu.id}}\">Editar</a> <a th:href=\"@{'/menus/eliminar/' + ${menu.id}}\" onclick=\"return confirm('\u00bfSeguro que quieres eliminar este men\u00fa?')\">Eliminar</a> </td> </tr> </tbody> </table> </body> </html> crear.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Crear/Editar Men\u00fa</title> </head> <body> <h1 th:text=\"${#strings.equals(menu.id, '') ? 'Crear Nuevo Men\u00fa' : 'Editar Men\u00fa'}\"></h1> <form th:action=\"@{${#strings.equals(menu.id, '') ? '/menus/guardar' : '/menus/actualizar/' + menu.id}}\" th:object=\"${menu}\" method=\"post\"> <label for=\"nombre\">Nombre:</label> <input type=\"text\" id=\"nombre\" name=\"nombre\" th:value=\"${menu.nombre}\" required><br> <label for=\"descripcion\">Descripci\u00f3n:</label> <textarea id=\"descripcion\" name=\"descripcion\" th:text=\"${menu.descripcion}\" required></textarea><br> <label for=\"fecha\">Fecha:</label> <input type=\"date\" id=\"fecha\" name=\"fecha\" th:value=\"${menu.fecha}\" required><br> <label for=\"precioTotal\">Precio Total:</label> <input type=\"number\" id=\"precioTotal\" name=\"precioTotal\" th:value=\"${menu.precioTotal}\" step=\"0.01\" required><br> <button type=\"submit\">Guardar</button> <a href=\"/menus\">Cancelar</a> </form> </body> </html> detalles.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Detalles del Men\u00fa</title> </head> <body> <h1>Detalles del Men\u00fa</h1> <p><strong>Nombre:</strong> <span th:text=\"${menu.nombre}\"></span></p> <p><strong>Descripci\u00f3n:</strong> <span th:text=\"${menu.descripcion}\"></span></p> <p><strong>Fecha:</strong> <span th:text=\"${menu.fecha}\"></span></p> <p><strong>Precio Total:</strong> <span th:text=\"${menu.precioTotal}\"></span></p> <h2>Platos</h2> <ul> <li th:each=\"plato : ${menu.platos}\"> <strong th:text=\"${plato.nombre}\"></strong> - <span th:text=\"${plato.categoria}\"></span> (<span th:text=\"${plato.precio}\"></span> \u20ac) </li> </ul> <a href=\"/menus\">Volver</a> </body> </html> editar.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Crear/Editar Men\u00fa</title> </head> <body> <h1 th:text=\"${#strings.equals(menu.id, '') ? 'Crear Nuevo Men\u00fa' : 'Editar Men\u00fa'}\"></h1> <form th:action=\"@{${#strings.equals(menu.id, '') ? '/menus/guardar' : '/menus/actualizar/' + menu.id}}\" th:object=\"${menu}\" method=\"post\"> <label for=\"nombre\">Nombre:</label> <input type=\"text\" id=\"nombre\" name=\"nombre\" th:value=\"${menu.nombre}\" required><br> <label for=\"descripcion\">Descripci\u00f3n:</label> <textarea id=\"descripcion\" name=\"descripcion\" th:text=\"${menu.descripcion}\" required></textarea><br> <label for=\"fecha\">Fecha:</label> <input type=\"date\" id=\"fecha\" name=\"fecha\" th:value=\"${menu.fecha}\" required><br> <label for=\"precioTotal\">Precio Total:</label> <input type=\"number\" id=\"precioTotal\" name=\"precioTotal\" th:value=\"${menu.precioTotal}\" step=\"0.01\" required><br> <button type=\"submit\">Guardar</button> <a href=\"/menus\">Cancelar</a> </form> </body> </html> Vistas para visualizar los platos: /platos listar.kt <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Platos del Men\u00fa</title> </head> <body> <h1 th:text=\"'Platos del Men\u00fa: ' + ${menu.nombre}\"></h1> <a th:href=\"@{/menus}\">Volver a Men\u00fas</a> <table border=\"1\"> <thead> <tr> <th>Nombre</th> <th>Categor\u00eda</th> <th>Precio</th> <th>Ingredientes</th> </tr> </thead> <tbody> <tr th:each=\"plato : ${platos}\"> <td th:text=\"${plato.nombre}\"></td> <td th:text=\"${plato.categoria}\"></td> <td th:text=\"${plato.precio} + ' \u20ac'\"></td> <td> <a th:href=\"@{'/platos/' + ${menu.id} + '/ingredientes/' + ${plato.nombre}}\">Ver Ingredientes</a> </td> </tr> </tbody> </table> </body> </html> ingredientes.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Ingredientes</title> </head> <body> <h1 th:text=\"'Ingredientes del plato: ' + ${plato?.nombre}\"></h1> <div th:if=\"${error}\"> <p th:text=\"${error}\" style=\"color: red;\"></p> </div> <ul th:if=\"${ingredientes != null && !ingredientes.isEmpty()}\"> <li th:each=\"ingrediente : ${ingredientes}\" th:text=\"${ingrediente}\"></li> </ul> <p th:if=\"${ingredientes == null || ingredientes.isEmpty()}\" style=\"color: gray;\"> No hay ingredientes disponibles para este plato. </p> <a th:href=\"@{'/platos/' + ${menu.id}}\">Volver a los platos</a> </body> </html> buscarPorCategoria.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Buscar Men\u00fas por Categor\u00eda</title> </head> <body> <h1>Resultados para categor\u00eda: <span th:text=\"${categoriaBuscada}\"></span></h1> <table border=\"1\" th:if=\"${menus}\"> <thead> <tr> <th>ID</th> <th>Nombre</th> <th>Descripci\u00f3n</th> <th>Platos</th> </tr> </thead> <tbody> <tr th:each=\"menu : ${menus}\"> <td th:text=\"${menu.id}\"></td> <td th:text=\"${menu.nombre}\"></td> <td th:text=\"${menu.descripcion}\"></td> <td> <ul> <li th:each=\"plato : ${menu.platos}\" th:if=\"${plato.categoria == categoriaBuscada}\" th:text=\"${plato.nombre}\"></li> </ul> </td> </tr> </tbody> </table> <p th:if=\"${menus == null || menus.isEmpty()}\" style=\"color: gray;\"> No se encontraron men\u00fas con platos de la categor\u00eda <span th:text=\"${categoriaBuscada}\"></span>. </p> <a href=\"/menus\">Volver a la lista de men\u00fas</a> </body> </html> Con esta configuraci\u00f3n podemos listar los siguientes ejemplos: http://localhost:8888/menus : Lista todos los men\u00fas http://localhost:8888/menus/buscar?nombre=Men\u00fa Vegetariano: Busca un men\u00fa concreto. http://localhost:8888/platos/1: Lista los platos del men\u00fa 1. http://localhost:8888/platos/1/ingredientes/Ensalada Griega: Lista los ingredients del plato del men\u00fa 1. Nota Estos son alugunos ejemplos pero pod\u00e9is modificar el controlador y crear nuevas vistas para a\u00f1adir funcionalidad al programa y que muestre m\u00e1s resultados.","title":"5 - Spring Data"},{"location":"SpringData/#spring-data","text":"Spring Data es un proyecto dentro del ecosistema Spring que proporciona herramientas y abstracciones para facilitar el acceso a bases de datos y otras fuentes de datos de manera eficiente y consistente. Su objetivo principal es simplificar la interacci\u00f3n con diferentes tipos de bases de datos, desde bases de datos relacionales (como PostgreSQL, MySQL) hasta bases de datos NoSQL (como MongoDB, Cassandra). \u00bfPara qu\u00e9 se utiliza? 1) Acceso Simplificado a Datos: Reduce la necesidad de escribir consultas SQL complejas o c\u00f3digo JDBC al exponer m\u00e9todos predefinidos para operaciones comunes. Permite realizar operaciones CRUD (Crear, Leer, Actualizar, Eliminar) con facilidad. 2) Abstracci\u00f3n de Repositorios: Ofrece la interfaz Repository y subinterfaces como CrudRepository y JpaRepository que proporcionan m\u00e9todos est\u00e1ndar para la gesti\u00f3n de entidades en bases de datos relacionales. 3) Consultas Personalizadas: Permite escribir consultas personalizadas mediante anotaciones como @Query . Tambi\u00e9n admite la creaci\u00f3n de m\u00e9todos de consulta basados en el nombre del m\u00e9todo, como findByNombre(String nombre) . 4) Compatibilidad con M\u00faltiples Tecnolog\u00edas de Bases de Datos: Relacionales: Mediante JPA (Java Persistence API). NoSQL: MongoDB, Redis, Neo4j, Cassandra, etc. Buscadores: Elasticsearch, Solr. 5) Configuraci\u00f3n Declarativa: Al integrar Spring Data con Spring Boot, se pueden configurar muchas opciones mediante propiedades en application.properties , evitando configuraciones manuales detalladas. 6) Integraci\u00f3n con Spring Boot: Con dependencias espec\u00edficas como spring-boot-starter-data-jpa o spring-boot-starter-data-mongodb , Spring Data se integra perfectamente con el resto del ecosistema de Spring. Principales M\u00f3dulos de Spring Data Spring Data JPA: : Proporciona una integraci\u00f3n con JPA para bases de datos relacionales. Es ideal para trabajar con entidades Java mapeadas a tablas de bases de datos. JPA es la especificaci\u00f3n para persistir, leer y gestionar data desde los objetos Java a la base de datos. Spring Data MongoDB: : Facilita el acceso a bases de datos MongoDB, una base de datos NoSQL orientada a documentos. Spring Data Redis: : Para aplicaciones que necesitan interactuar con Redis, una base de datos en memoria. Spring Data Cassandra: : Proporciona soporte para bases de datos distribuidas como Cassandra. Spring Data Elasticsearch: : Simplifica las interacciones con Elasticsearch, un motor de b\u00fasqueda y an\u00e1lisis.","title":"Spring Data"},{"location":"SpringData/#spring-data-jpa","text":"Spring Data JPA es parte de Spring Framework. No es una implementaci\u00f3n de JPA como Hibernate, sino una abstracci\u00f3n para reducir la complejidad de la integraci\u00f3n con bases de datos relacionales desde aplicaciones Java. Spring Data JPA puede utilizar Hibernate, Eclipse Link u otra implementaci\u00f3n.","title":"Spring Data JPA"},{"location":"SpringData/#anotaciones-comunes","text":"","title":"Anotaciones Comunes"},{"location":"SpringData/#1-mapeo-de-entidades-jpa-estandar","text":"Estas anotaciones son parte de JPA y permiten mapear clases y relaciones a tablas en la base de datos. @Entity - Marca una clase como una entidad JPA, mapeada a una tabla en la base de datos. @Entity data class User( @Id val id: Long, val name: String ) @Table - Especifica el nombre de la tabla que corresponde a la entidad. @Entity @Table(name = \"users\") data class User( @Id val id: Long, val name: String ) @Id - Indica que un campo es la clave primaria de la tabla. @Id val id: Long @GeneratedValue - Define c\u00f3mo se genera el valor de la clave primaria. Estrategias comunes: GenerationType.IDENTITY , GenerationType.SEQUENCE , etc. @Id @GeneratedValue(strategy = GenerationType.IDENTITY) val id: Long @Column - Configura una columna de la tabla, como nombre, si es nula o \u00fanica. @Column(name = \"user_name\", nullable = false, unique = true) val name: String @ManyToOne , @OneToMany , @OneToOne , @ManyToMany Define relaciones entre entidades. @ManyToOne val department: Department @JoinColumn - Especifica la columna que act\u00faa como clave for\u00e1nea. @ManyToOne @JoinColumn(name = \"department_id\") val department: Department @Lob - Indica que un campo es un objeto grande (texto o binario). @Lob val description: String @Transient - Excluye un campo del mapeo de base de datos (no se almacena). @Transient val calculatedField: String","title":"1. Mapeo de Entidades (JPA Est\u00e1ndar)"},{"location":"SpringData/#2-especificas-de-spring-data-jpa","text":"Estas anotaciones son propias de Spring Data JPA y extienden la funcionalidad de JPA. @Repository - Marca una interfaz o clase como repositorio Spring. @Repository interface UserRepository : JpaRepository<User, Long> @Query - Define una consulta personalizada usando JPQL o SQL nativo. Ejemplo (JPQL): @Query(\"SELECT u FROM User u WHERE u.name = :name\") fun findByName(@Param(\"name\") name: String): List<User> Ejemplo (SQL nativo): @Query(value = \"SELECT * FROM users WHERE user_name = :name\", nativeQuery = true) fun findByNameNative(@Param(\"name\") name: String): List<User> @Param - Define par\u00e1metros nombrados para consultas con @Query . @Query(\"SELECT u FROM User u WHERE u.name = :name\") fun findByName(@Param(\"name\") name: String): List<User> @Modifying - Se utiliza con consultas @Query para operaciones de actualizaci\u00f3n o eliminaci\u00f3n. @Modifying @Query(\"UPDATE User u SET u.name = :name WHERE u.id = :id\") fun updateName(@Param(\"id\") id: Long, @Param(\"name\") name: String) @EnableJpaRepositories - Habilita la funcionalidad de Spring Data JPA y escanea paquetes para detectar repositorios. @EnableJpaRepositories(basePackages = [\"com.example.repository\"]) @EntityGraph - Especifica c\u00f3mo cargar las relaciones en una consulta, evitando lazy loading. @EntityGraph(attributePaths = [\"roles\"]) fun findByName(name: String): User","title":"2. Espec\u00edficas de Spring Data JPA"},{"location":"SpringData/#3-transacciones","text":"@Transactional - Marca un m\u00e9todo o clase para ejecutar dentro de una transacci\u00f3n. @Transactional fun updateUserDetails(user: User) { ... } @Rollback - Utilizada en pruebas para forzar la reversi\u00f3n de una transacci\u00f3n. @Transactional @Rollback fun testSaveUser() { ... }","title":"3. Transacciones"},{"location":"SpringData/#consultas-a-la-base-de-datos","text":"Las consultas a la Base de datos las podemos hacer de dos maneras, utilizando la convenci\u00f3n de nombres en funciones de Spring Data JPA o con la anotaci\u00f3n @Query . La convenci\u00f3n de nombres se utiliza: En consultas sencillas y que no requieren l\u00f3gica compleja ni m\u00faltiples combinaciones. Cuando quieres mantener un c\u00f3digo m\u00e1s limpio y directo. La anotaci\u00f3n @Query se utiliza: En consultas complejas que involucren m\u00faltiples tablas, condiciones avanzadas o subconsultas. Si prefieres optimizar manualmente las consultas. Cuando la convenci\u00f3n de nombres generar\u00eda un nombre de m\u00e9todo excesivamente largo.","title":"Consultas a la Base de Datos"},{"location":"SpringData/#query","text":"Estructura b\u00e1sica: @Query(\"SELECT e FROM EntityName e WHERE e.property = :value\") fun findByProperty(@Param(\"value\") value: String): List<EntityName> Se utilizan nombres de entidades y propiedades de las clases en lugar de nombres de tablas y columnas. Se puede navegar por relaciones entre entidades. :nombreParametro para par\u00e1metros din\u00e1micos. Ejemplo simple: @Query(\"SELECT c FROM Comarca c WHERE c.provincia = :provincia\") fun findByProvincia(@Param(\"provincia\") provincia: String): List<Comarca> Ejemplo con relaciones: Siguiendo con nuestro ejemplo de geo_ad, la consulta par buscar Institutos en una Provincia por Poblaci\u00f3n M\u00ednima quedar\u00eda as\u00ed: @Query(\"\"\" SELECT i FROM Institut i JOIN i.poblacio p JOIN p.comarca c WHERE c.provincia = :provincia AND p.poblacion >= :minPoblacion \"\"\") fun findByProvinciaAndPoblacion( @Param(\"provincia\") provincia: String, @Param(\"minPoblacion\") minPoblacion: Int ): List<Institut> Este mismo ejemplo utilizando convenci\u00f3n de nombres quedar\u00eda as\u00ed: @Repository interface InstitutRepository : JpaRepository<Institut, String> { fun findByPoblacioComarcaProvinciaAndPoblacioPoblacionGreaterThanEqual( provincia: String, minPoblacion: Int ): List<Institut> } findBy : Indica que es un m\u00e9todo de consulta. PoblacioComarcaProvincia : Navega por las relaciones de las entidades Institut Poblacio -> Comarca para filtrar por la provincia. AndPoblacioPoblacionGreaterThanEqual : Navega por Institut -> Poblacio y aplica el filtro de poblaci\u00f3n m\u00ednima. A medida que las relaciones aumentan en complejidad, los nombres de los m\u00e9todos pueden volverse dif\u00edciles de leer y mantener.","title":"@Query"},{"location":"SpringData/#convencion-de-nombres-en-spring-jpa","text":"Spring Data JPA permite definir m\u00e9todos en repositorios siguiendo una convenci\u00f3n de nombres espec\u00edfica. Esto simplifica la escritura de consultas comunes sin necesidad de usar JPQL o SQL. Para ello analiza el nombre de los m\u00e9todos en el repositorio e interpreta su significado para generar consultas autom\u00e1ticamente. La estructura b\u00e1sica es: findBy + NombreDeCampo + Condici\u00f3n 1) findBy : Indica que se busca una entidad en la base de datos. Alternativas: readBy (lectura de datos) queryBy (consulta de datos) getBy (obtener datos) 2) NombreDeCampo : Debe coincidir exactamente con el nombre del atributo en la entidad. Se puede incluir navegaci\u00f3n de atributos para relaciones (EntidadRelacionada.Atributo). 3) Condici\u00f3n (opcional): Permite a\u00f1adir operadores l\u00f3gicos como And, Or, etc. Ejemplo: findByNombreAndEdad. Ejemplos de m\u00e9todos seg\u00fan la convenci\u00f3n Consultas simples M\u00e9todo: findByNombre(String nombre) Consulta generada: SELECT * FROM entidad WHERE nombre = ? Consultas con condiciones M\u00e9todo: findByNombreAndEdad(String nombre, Integer edad) Consulta generada: SELECT * FROM entidad WHERE nombre = ? AND edad = ? Consultas con orden M\u00e9todo: findByNombreOrderByEdadDesc(String nombre) Consulta generada: SELECT * FROM entidad WHERE nombre = ? ORDER BY edad DESC Consultas con relaciones. Si hay una relaci\u00f3n entre entidades, se puede navegar por los campos relacionados: M\u00e9todo: findByComarcaNomC(String nomC) Consulta generada: SELECT * FROM entidad e JOIN comarca c ON e.comarca_id = c.id WHERE c.nomC = ? Palabras clave en la convenci\u00f3n Consideraciones Coincidencia exacta del nombre del campo : Los nombres deben coincidir con los atributos definidos en la entidad. Relaciones : Usa la notaci\u00f3n EntidadRelacionada.Atributo para navegar entre tablas relacionadas. Orden : Los m\u00e9todos pueden incluir palabras clave de ordenaci\u00f3n, como OrderBy. Par\u00e1metros : Los m\u00e9todos generados reciben par\u00e1metros en el mismo orden en que se declaran en el nombre del m\u00e9todo.","title":"Convenci\u00f3n de Nombres en Spring JPA"},{"location":"SpringData/#ejemplo-ampliado-de-spring-mvc","text":"Para practicar la funcionalidad de Spring Data JPA vamos a seguir con el ejemplo visto en el apartado de Spring MVC PrimerSpringMVC . Recordemos que la aplicaci\u00f3n accede a la base de datos local en Docker. En este ejemplo vamos a mapear las 3 tablas de la base de datos: comarca, poblacio e institut y a realizar los cambios necesarios para crear algunas consultas y operaciones CRUD. Modelo (Entidad JPA) Entidad Comarca . La \u00fanica diferencia con el ejemplo que tenemos es que mapea el nombre de la columna nom_c por nomC para evitar problemas de convenci\u00f3 de nombres. import jakarta.persistence.* @Entity @Table(name = \"comarca\") data class comarca( @Id @Column(name = \"nom_c\") val nomC: String = \"\", @Column(name = \"provincia\") val provincia: String? = null ) Entidad Poblacio import jakarta.persistence.* @Entity @Table(name = \"poblacio\") data class poblacio( @Id @Column(name = \"cod_m\") val codM: Int = 0, @Column(name = \"nom\") val nom: String = \"\", @Column(name = \"poblacio\") val poblacio: Int? = null, @Column(name = \"extensio\") val extensio: Double? = null, @Column(name = \"altura\") val altura: Int? = null, @Column(name = \"longitud\") val longitud: String? = null, @Column(name = \"latitud\") val latitud: String? = null, @Column(name = \"llengua\") val llengua: String? = null, @ManyToOne //clave ajena a comarca @JoinColumn(name = \"nom_c\", referencedColumnName = \"nom_c\") val comarca: comarca? = null ) Entidad Institut import jakarta.persistence.* @Entity @Table(name = \"institut\") data class institut( @Id @Column(name = \"codi\") val codi: String = \"\", @Column(name = \"adreca\") val adreca: String? = null, @Column(name = \"codpostal\") val codPostal: Int? = null, @Column(name = \"nom\") val nom: String? = null, @Column(name = \"numero\") val numero: String? = null, @ManyToOne //clave ajena a poblacio @JoinColumn(name = \"cod_m\", referencedColumnName = \"cod_m\") val poblacio: poblacio? = null ) Repositorio Repositorio para Comarca: ComarcaRepository . import org.example.primerspringmvc.model.comarca import org.springframework.data.jpa.repository.JpaRepository import org.springframework.stereotype.Repository @Repository interface ComarcaRepository : JpaRepository<comarca, String> { // Obtener comarcas de una provincia fun findByProvincia(provincia: String): List<comarca> } Repositorio para Institut: InstitutRepository package org.example.primerspringmvc.repository import org.example.primerspringmvc.model.institut import org.springframework.data.jpa.repository.JpaRepository interface InstitutRepository : JpaRepository<institut, String> { // Obtener institutos de una poblaci\u00f3n fun findByPoblacioNom(nom: String): List<institut> // Obtener institutos de una comarca fun findByPoblacioComarcaNomC(nomC: String): List<institut> // Obtener institutos de una provincia fun findByPoblacioComarcaProvincia(provincia: String): List<institut> // Obtener institutos cuya poblaci\u00f3n es mayor a fun findByPoblacioPoblacioGreaterThan(poblacio: Int): List<institut> } Repositorio para Poblacio: PoblacioRepository import org.example.primerspringmvc.model.poblacio import org.springframework.data.jpa.repository.JpaRepository interface PoblacioRepository : JpaRepository<poblacio, String> { // Obtener poblaciones de una comarca fun findByComarcaNomC(nomC: String): List<poblacio> // Obtener poblaciones de una provincia fun findByComarcaProvincia(provincia: String): List<poblacio> } Controlador ComarcaController import org.example.primerspringmvc.model.comarca import org.springframework.stereotype.Controller import org.example.primerspringmvc.repository.* import org.springframework.ui.Model import org.springframework.web.bind.annotation.* // Muestra todas las poblaciones @GetMapping fun listarTodasPoblacions(model: Model): String { val poblacions = poblacioRepository.findAll() model.addAttribute(\"poblacions\", poblacions) return \"poblacions\" // Vista Thymeleaf para mostrar todas las poblaciones } // Muestra las poblaciones por comarca @GetMapping(\"/por-comarca\") fun listarPoblacionsPorComarca(@RequestParam comarca: String, model: Model): String { val poblacions = poblacioRepository.findByComarcaNomC(comarca) model.addAttribute(\"poblacions\", poblacions) return \"poblacions\" // Vista Thymeleaf para mostrar las poblaciones por comarca } InstitutController import org.example.primerspringmvc.model.institut import org.example.primerspringmvc.repository.InstitutRepository import org.springframework.stereotype.Controller import org.springframework.ui.Model import org.springframework.web.bind.annotation.* @Controller @RequestMapping(\"/instituts\") class InstitutController(private val institutRepository: InstitutRepository) { //Muestra todos los intitutos @GetMapping fun listarInstituts(model: Model): String { val instituts = institutRepository.findAll() model.addAttribute(\"instituts\", instituts) return \"instituts\" } // Muestra institutos de una poblaci\u00f3n @GetMapping(\"/por-poblacio\") fun obtenerInstitutsPoblacio(@RequestParam poblacio: String, model: Model): String { val institutsPoblacio = institutRepository.findByPoblacioNom(poblacio) model.addAttribute(\"instituts\", institutsPoblacio) return \"instituts\" // Plantilla para mostrar la lista de institutos } // Muestra institutos de una comarca @GetMapping(\"/por-comarca\") fun obtenerInstitutsComarca(@RequestParam comarca: String, model: Model): String { val institutsComarca = institutRepository.findByPoblacioComarcaNomC(comarca) model.addAttribute(\"instituts\", institutsComarca) return \"instituts\" // Plantilla para mostrar la lista de institutos } // Muestra institutos de una provincia @GetMapping(\"/por-provincia\") fun obtenerInstitutsProvincia(@RequestParam provincia: String, model: Model): String { val institutsProvincia = institutRepository.findByPoblacioComarcaProvincia(provincia) model.addAttribute(\"instituts\", institutsProvincia) return \"instituts\" // Plantilla para mostrar la lista de institutos } // Muestra institutos con poblaci\u00f3n superior a un valor @GetMapping(\"/poblacion-superior\") fun obtenerInstitutsPoblacionSuperior(@RequestParam poblacio: Int, model: Model): String { val institutsConPoblacionSuperiorA = institutRepository.findByPoblacioPoblacioGreaterThan(poblacio) model.addAttribute(\"instituts\", institutsConPoblacionSuperiorA) return \"instituts\" // Plantilla para mostrar la lista de institutos } } PoblacioController import org.example.primerspringmvc.repository.PoblacioRepository import org.springframework.stereotype.Controller import org.springframework.ui.Model import org.springframework.web.bind.annotation.* @Controller @RequestMapping(\"/poblacions\") class PoblacioController(private val poblacioRepository: PoblacioRepository) { // Muestra todas las poblaciones @GetMapping fun listarTodasPoblacions(model: Model): String { val poblacions = poblacioRepository.findAll() model.addAttribute(\"poblacions\", poblacions) return \"poblacions\" // Vista Thymeleaf para mostrar todas las poblaciones } // Muestra las poblaciones por comarca @GetMapping(\"/por-comarca\") fun listarPoblacionsPorComarca(@RequestParam comarca: String, model: Model): String { val poblacions = poblacioRepository.findByComarcaNomC(comarca) model.addAttribute(\"poblacions\", poblacions) return \"poblacions\" // Vista Thymeleaf para mostrar las poblaciones por comarca } @GetMapping(\"/por-provincia\") fun listarPoblacionsPorProvincia(@RequestParam provincia: String, model: Model): String { val poblacions = poblacioRepository.findByComarcaProvincia(provincia) model.addAttribute(\"poblacions\", poblacions) return \"poblacions\" // Vista Thymeleaf para mostrar las poblaciones por comarca } } Vistas Thymeleaf Vista comarcas.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Lista de Comarcas</title> </head> <body> <h1>Lista de Comarcas</h1> <table border=\"1\"> <tr> <th>Comarca</th> <th>Provincia</th> </tr> <tr th:each=\"comarca : ${comarcas}\"> <td th:text=\"${comarca.nomC}\">Comarca</td> <td th:text=\"${comarca.provincia}\">Provincia</td> </tr> </table> </body> </html> Vista nueva-comarca.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Nueva Comarca</title> </head> <body> <h1>Nueva Comarca</h1> <form th:action=\"@{/comarcas/nueva}\" th:object=\"${comarca}\" method=\"post\"> <label for=\"nomC\">Comarca:</label> <input type=\"text\" id=\"nomC\" name=\"nomC\" th:value=\"*{nomC}\" required><br> <label for=\"provincia\">Provincia:</label> <input type=\"text\" id=\"provincia\" name=\"provincia\" th:value=\"*{provincia}\" required><br> <button type=\"submit\">Guardar</button> </form> </body> </html> Vista instituts.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Instituts</title> </head> <body> <h1>Llista d'Instituts</h1> <table border=\"1\"> <tr> <th>Codi</th> <th>Nom</th> <th>Adre\u00e7a</th> <th>Poblaci\u00f3</th> <th>Habitants</th> <th>Comarca</th> <th>Provincia</th> </tr> <tr th:each=\"institut : ${instituts}\"> <td th:text=\"${institut.codi}\">Codi</td> <td th:text=\"${institut.nom}\">Nom</td> <td th:text=\"${institut.adreca}\">Adre\u00e7a</td> <td th:text=\"${institut.poblacio?.nom}\">Poblaci\u00f3</td> <td th:text=\"${institut.poblacio?.poblacio}\">Habitants</td> <td th:text=\"${institut.poblacio?.comarca?.nomC}\">Comarca</td> <td th:text=\"${institut.poblacio?.comarca?.provincia}\">Provincia</td> </tr> </table> </body> </html> Vista poblacions.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Poblacions</title> </head> <body> <h1>Llista de Poblacions per Comarca</h1> <table border=\"1\"> <tr> <th>Codi</th> <th>Nom</th> <th>Comarca</th> <th>Provincia</th> </tr> <tr th:each=\"poblacio : ${poblacions}\"> <td th:text=\"${poblacio.codM}\">Codi</td> <td th:text=\"${poblacio.nom}\">Nom</td> <td th:text=\"${poblacio.comarca?.nomC}\">Comarca</td> <td th:text=\"${poblacio.comarca?.provincia}\">Provincia</td> </tr> </table> </body> </html> Con esta configuraci\u00f3n podemos listar los siguientes ejemplos : Todos los institutos: http://localhost:8888/instituts Todas las poblaciones: http://localhost:8888/poblacions Todas las comarcas: http://localhost:8888/comarcas Listar institutos de una poblaci\u00f3n: http://localhost:8888/instituts/por-poblacio?poblacio=Gandia Listar institutos de una comarca: http://localhost:8888/instituts/por-comarca?comarca=Safor Listar institutos de una provincia: http://localhost:8888/instituts/por-provincia?provincia=Alacant Listar comarcas de una provincia: http://localhost:8888/comarcas/por-provincia?provincia=Alacant Listar poblaciones de una comarca http://localhost:8888/poblacions/por-comarca?comarca=Safor Listar poblaciones de una provincia: http://localhost:8888/poblacions/por-provincia?provincia=Alacant Listar institutos con poblaci\u00f3n superior a un valor: http://localhost:8888/instituts/poblacion-superior?poblacio=20000","title":"Ejemplo ampliado de Spring MVC"},{"location":"SpringData/#spring-data-mongodb","text":"El componente Spring MongoDB Es un m\u00f3dulo de Spring Data que facilita la integraci\u00f3n de aplicaciones Spring con MongoDB . Adem\u00e1s proporciona una abstracci\u00f3n sobre las operaciones b\u00e1sicas de MongoDB como CRUD, consultas personalizadas, y soporte para agregaciones. Requisitos Tener MongoDB instalado o utilizar una instancia en la nube o en un contenedor Docker. Spring Boot configurado con Maven (en nuestro caso) o Gradle. Dependencias Maven <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-data-mongodb</artifactId> </dependency> Configuraci\u00f3n de las propiedades application.properties spring.data.mongodb.host=localhost spring.data.mongodb.port=27017 spring.data.mongodb.database=nombre_base_de_datos Si est\u00e1s usando MongoDB con autenticaci\u00f3n, a\u00f1ade: spring.data.mongodb.username=usuario spring.data.mongodb.password=contrase\u00f1a","title":"Spring Data MongoDB"},{"location":"SpringData/#anotaciones-comunes_1","text":"Estas anotaciones permiten mapear documentos, gestionar colecciones y realizar operaciones de manera sencilla. Las principales anotaciones utilizadas en Spring Data MongoDB son: @Document Se utiliza para marcar una clase como un documento MongoDB que ser\u00e1 persistido en una colecci\u00f3n. @Document(collection = \"coleccion\") * collection : Especifica el nombre de la colecci\u00f3n. Si no se define, se usa el nombre de la clase en min\u00fasculas. @Id Marca un campo como identificador \u00fanico del documento. Este campo se mapea al campo _id en MongoDB. @Field Se utiliza para mapear un campo de la clase a un campo espec\u00edfico en el documento MongoDB. @Field(\"descripcion\") val descripcionProducto: String @Transient Indica que un campo no debe ser persistido en la base de datos. @Transient val temporal: String = \"No se guarda en MongoDB\" @DBRef Se utiliza para definir una relaci\u00f3n entre documentos, similar a una clave for\u00e1nea. El atributo se mapea a una referencia en MongoDB. @DBRef val categoria: Categoria @CompoundIndex Define \u00edndices compuestos en la colecci\u00f3n para optimizar consultas. @CompoundIndex(def = \"{'nombre': 1, 'precio': -1}\", unique = true) * def: Define los campos que forman el \u00edndice. * unique: Indica si el \u00edndice debe ser \u00fanico.","title":"Anotaciones comunes"},{"location":"SpringData/#aplicacion-spring-data-mongodb","text":"En este apartado del tema ya tenemos que saber como crear una aplicaic\u00f3n Spring Boot desde IntelliJ, solo necesitas saber las dependencias necesarias y las anotaciones para incorporar Spring Data MongoDB y poco m\u00e1s. El resto ya depende de lo que quieras construir con la base de datos. Para este ejemplo partiremos de un archivo json que contiene 10 men\u00fas con sus correspondientes platos. Has de a\u00f1adir este documento como una colecci\u00f3n a tu BD Mongo. Lo tienes disponible en la carpeta recursos y tambi\u00e9n lo puedes copiar directamente. Lo primero que debes hacer es insertar este archivo en tu MongoDB local, como una colecci\u00f3n (InsertMany) Archivo json con los menus: [ { \"_id\": \"1\", \"nombre\": \"Men\u00fa Mediterr\u00e1neo\", \"descripcion\": \"Un men\u00fa saludable inspirado en la dieta mediterr\u00e1nea.\", \"fecha\": \"2025-01-08\", \"platos\": [ { \"nombre\": \"Ensalada Griega\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Lechuga\", \"Tomate\", \"Pepino\", \"Aceitunas\", \"Queso Feta\"], \"precio\": 5.5 }, { \"nombre\": \"Moussaka\", \"categoria\": \"Principal\", \"ingredientes\": [\"Berenjena\", \"Carne de Cordero\", \"Tomate\", \"Bechamel\", \"Queso\"], \"precio\": 12.0 } ], \"precioTotal\": 17.5 }, { \"_id\": \"2\", \"nombre\": \"Men\u00fa Asi\u00e1tico\", \"descripcion\": \"Sabores frescos y aut\u00e9nticos de Asia.\", \"fecha\": \"2025-01-09\", \"platos\": [ { \"nombre\": \"Rollitos de Primavera\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Zanahoria\", \"Col\", \"Brotes de Soja\", \"Fideos de Arroz\"], \"precio\": 4.0 }, { \"nombre\": \"Pad Thai\", \"categoria\": \"Principal\", \"ingredientes\": [\"Fideos de Arroz\", \"Camarones\", \"Tofu\", \"Man\u00ed\"], \"precio\": 10.0 } ], \"precioTotal\": 14.0 }, { \"_id\": \"3\", \"nombre\": \"Men\u00fa Vegetariano\", \"descripcion\": \"Opciones deliciosas sin carne.\", \"fecha\": \"2025-01-10\", \"platos\": [ { \"nombre\": \"Hummus con Pan de Pita\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Garbanzos\", \"Tahini\", \"Lim\u00f3n\", \"Ajo\"], \"precio\": 4.5 }, { \"nombre\": \"Lasa\u00f1a Vegetariana\", \"categoria\": \"Principal\", \"ingredientes\": [\"Pasta\", \"Espinacas\", \"Ricotta\", \"Tomate\"], \"precio\": 9.0 } ], \"precioTotal\": 13.5 }, { \"_id\": \"4\", \"nombre\": \"Men\u00fa Italiano\", \"descripcion\": \"Especialidades cl\u00e1sicas de Italia.\", \"fecha\": \"2025-01-11\", \"platos\": [ { \"nombre\": \"Bruschetta\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Pan\", \"Tomate\", \"Albahaca\", \"Aceite de Oliva\"], \"precio\": 5.0 }, { \"nombre\": \"Pizza Margarita\", \"categoria\": \"Principal\", \"ingredientes\": [\"Masa de Pizza\", \"Tomate\", \"Mozzarella\", \"Albahaca\"], \"precio\": 10.0 } ], \"precioTotal\": 15.0 }, { \"_id\": \"5\", \"nombre\": \"Men\u00fa Mexicano\", \"descripcion\": \"Platos picantes y llenos de sabor.\", \"fecha\": \"2025-01-12\", \"platos\": [ { \"nombre\": \"Guacamole con Totopos\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Aguacate\", \"Lim\u00f3n\", \"Cilantro\", \"Totopos\"], \"precio\": 4.5 }, { \"nombre\": \"Tacos al Pastor\", \"categoria\": \"Principal\", \"ingredientes\": [\"Tortilla\", \"Carne de Cerdo\", \"Pi\u00f1a\", \"Cebolla\"], \"precio\": 9.0 } ], \"precioTotal\": 13.5 }, { \"_id\": \"6\", \"nombre\": \"Men\u00fa Americano\", \"descripcion\": \"Comida cl\u00e1sica de los Estados Unidos.\", \"fecha\": \"2025-01-13\", \"platos\": [ { \"nombre\": \"Alitas de Pollo\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Pollo\", \"Salsa BBQ\", \"Especias\"], \"precio\": 6.0 }, { \"nombre\": \"Hamburguesa con Queso\", \"categoria\": \"Principal\", \"ingredientes\": [\"Pan\", \"Carne de Res\", \"Queso\", \"Lechuga\"], \"precio\": 10.0 } ], \"precioTotal\": 16.0 }, { \"_id\": \"7\", \"nombre\": \"Men\u00fa de Mariscos\", \"descripcion\": \"Frescos sabores del oc\u00e9ano.\", \"fecha\": \"2025-01-14\", \"platos\": [ { \"nombre\": \"C\u00f3ctel de Camarones\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Camarones\", \"Salsa C\u00f3ctel\", \"Lim\u00f3n\"], \"precio\": 7.0 }, { \"nombre\": \"Paella de Mariscos\", \"categoria\": \"Principal\", \"ingredientes\": [\"Arroz\", \"Camarones\", \"Mejillones\", \"Calamares\"], \"precio\": 12.0 } ], \"precioTotal\": 19.0 }, { \"_id\": \"8\", \"nombre\": \"Men\u00fa Franc\u00e9s\", \"descripcion\": \"Platos refinados y elegantes.\", \"fecha\": \"2025-01-15\", \"platos\": [ { \"nombre\": \"Quiche Lorraine\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Huevo\", \"Nata\", \"Tocino\", \"Queso Gruy\u00e8re\"], \"precio\": 6.5 }, { \"nombre\": \"Ratatouille\", \"categoria\": \"Principal\", \"ingredientes\": [\"Berenjena\", \"Calabac\u00edn\", \"Tomate\", \"Pimiento\"], \"precio\": 9.5 } ], \"precioTotal\": 16.0 }, { \"_id\": \"9\", \"nombre\": \"Men\u00fa Indio\", \"descripcion\": \"Sabores especiados y ex\u00f3ticos.\", \"fecha\": \"2025-01-16\", \"platos\": [ { \"nombre\": \"Samosas\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Papas\", \"Especias\", \"Masa Frita\"], \"precio\": 4.0 }, { \"nombre\": \"Pollo Tikka Masala\", \"categoria\": \"Principal\", \"ingredientes\": [\"Pollo\", \"Salsa de Tomate\", \"Especias\", \"Crema\"], \"precio\": 11.0 } ], \"precioTotal\": 15.0 }, { \"_id\": \"10\", \"nombre\": \"Men\u00fa Japon\u00e9s\", \"descripcion\": \"Delicados sabores de Jap\u00f3n.\", \"fecha\": \"2025-01-17\", \"platos\": [ { \"nombre\": \"Sopa de Miso\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Miso\", \"Tofu\", \"Alga Wakame\"], \"precio\": 3.5 }, { \"nombre\": \"Sushi Variado\", \"categoria\": \"Principal\", \"ingredientes\": [\"Arroz\", \"Pescado\", \"Alga Nori\", \"Vegetales\"], \"precio\": 12.5 } ], \"precioTotal\": 16.0 } ] Modelo MVC Lo siguiente ser\u00e1 crear la estructura del modelo MVC con los archivos necesarios. En la siguiene imagen podeis ver como quedar\u00e1: Modelo Los modelos son las clases que representan las colecciones en MongoDB. Menu.kt import org.springframework.data.annotation.Id import org.springframework.data.mongodb.core.mapping.Document @Document(collection = \"menus\") // Nombre de la colecci\u00f3n en MongoDB data class Menu( @Id val id: String, // Identificador \u00fanico del men\u00fa val nombre: String, // Nombre del men\u00fa val descripcion: String, // Descripci\u00f3n del men\u00fa val fecha: String, // Fecha asociada al men\u00fa val platos: List<Plato> = emptyList(), // Lista de platos val precioTotal: Double = 0.0 // Precio total del men\u00fa ) data class Plato( val nombre: String, val categoria: String, val ingredientes: List<String> = emptyList(), val precio: Double = 0.0 ) Repositorios Proporciona una interfaz MongoRepository que simplifica las operaciones CRUD. MenuRepository.kt import org.springframework.data.mongodb.repository.MongoRepository import org.springframework.stereotype.Repository import org.example.primerspringmongo.model.* @Repository interface MenuRepository : MongoRepository<Menu, String> { fun findByNombre(nombre: String): List<Menu> fun findByPlatosCategoria(categoria: String): List<Menu> } Controlador Gestiona las solicitudes entrantes, procesa datos y determina las respuestas adecuadas. MenuController.kt import org.example.primerspringmongo.model.Menu import org.example.primerspringmongo.repository.MenuRepository import org.springframework.stereotype.Controller import org.springframework.ui.Model import org.springframework.web.bind.annotation.* @Controller @RequestMapping(\"/menus\") class MenuController(private val menuRepository: MenuRepository) { // Listar todos los men\u00fas @GetMapping fun listarMenus(model: Model): String { val menus = menuRepository.findAll() model.addAttribute(\"menus\", menus) return \"menus/listar\" } @GetMapping(\"/buscar\") fun buscarPorNombre(@RequestParam nombre: String, model: Model): String { val menus = menuRepository.findByNombre(nombre) // Consulta en el repositorio model.addAttribute(\"menus\", menus) // Pasar los men\u00fas al modelo model.addAttribute(\"nombre\", nombre) // Pasar el nombre buscado return \"menus/listar\" // Nombre de la plantilla Thymeleaf } // Guardar un nuevo men\u00fa @PostMapping(\"/guardar\") fun guardarMenu(@ModelAttribute menu: Menu): String { menuRepository.save(menu) return \"redirect:/menus\" } // Ver detalles de un men\u00fa @GetMapping(\"/{id}\") fun verDetalles(@PathVariable id: String, model: Model): String { val menu = menuRepository.findById(id) if (menu.isPresent) { model.addAttribute(\"menu\", menu.get()) return \"menus/detalles\" } return \"redirect:/menus\" } // Mostrar formulario para editar un men\u00fa @GetMapping(\"/editar/{id}\") fun mostrarFormularioEditar(@PathVariable id: String, model: Model): String { val menu = menuRepository.findById(id) if (menu.isPresent) { model.addAttribute(\"menu\", menu.get()) return \"menus/editar\" } return \"redirect:/menus\" } // Actualizar un men\u00fa existente @PostMapping(\"/actualizar/{id}\") fun actualizarMenu(@PathVariable id: String, @ModelAttribute menu: Menu): String { if (menuRepository.existsById(id)) { menuRepository.save(menu) } return \"redirect:/menus\" } // Eliminar un men\u00fa @GetMapping(\"/eliminar/{id}\") fun eliminarMenu(@PathVariable id: String): String { menuRepository.deleteById(id) return \"redirect:/menus\" } } PlatoController.kt import org.example.primerspringmongo.repository.MenuRepository import org.springframework.stereotype.Controller import org.springframework.ui.Model import org.springframework.web.bind.annotation.* @Controller @RequestMapping(\"/platos\") class PlatoController(private val menuRepository: MenuRepository) { // Listar todos los platos de un men\u00fa @GetMapping(\"/{menuId}\") fun listarPlatos(@PathVariable menuId: String, model: Model): String { val menu = menuRepository.findById(menuId) if (menu.isPresent) { model.addAttribute(\"menu\", menu.get()) model.addAttribute(\"platos\", menu.get().platos) return \"platos/listar\" } return \"redirect:/menus\" } @GetMapping(\"/categoria\") fun buscarPorCategoria(@RequestParam categoria: String, model: Model): String { val menus = menuRepository.findByPlatosCategoria(categoria) // Consulta en el repositorio model.addAttribute(\"menus\", menus) // Lista de men\u00fas encontrados model.addAttribute(\"categoriaBuscada\", categoria) // Categor\u00eda buscada return \"platos/buscarPorCategoria\" // Plantilla Thymeleaf } @GetMapping(\"/{menuId}/ingredientes/{platoNombre}\") fun verIngredientes( @PathVariable menuId: String, @PathVariable platoNombre: String, model: Model ): String { val menu = menuRepository.findById(menuId) if (menu.isPresent) { val plato = menu.get().platos.find { it.nombre == platoNombre } if (plato != null) { println(\"Plato encontrado: $plato\") println(\"Ingredientes: ${plato.ingredientes}\") model.addAttribute(\"menu\", menu.get()) model.addAttribute(\"plato\", plato) model.addAttribute(\"ingredientes\", plato.ingredientes ?: emptyList<String>()) return \"platos/ingredientes\" } } model.addAttribute(\"error\", \"El plato o el men\u00fa no existen.\") return \"error\" } } Vista Permiten visualizar los resultados con un formato personalizado. En la siguiente imagen ten\u00e9is la estructura de los archivos: Vistas para visualizar los menus: /menus listar.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Lista de Men\u00fas</title> </head> <body> <h1>Lista de Men\u00fas</h1> <a href=\"/menus/crear\">Crear Nuevo Men\u00fa</a> <table border=\"1\"> <thead> <tr> <th>Nombre</th> <th>Descripci\u00f3n</th> <th>Acciones</th> </tr> </thead> <tbody> <tr th:each=\"menu : ${menus}\"> <td th:text=\"${menu.nombre}\"></td> <td th:text=\"${menu.descripcion}\"></td> <td> <a th:href=\"@{'/menus/' + ${menu.id}}\">Detalles</a> <a th:href=\"@{'/menus/editar/' + ${menu.id}}\">Editar</a> <a th:href=\"@{'/menus/eliminar/' + ${menu.id}}\" onclick=\"return confirm('\u00bfSeguro que quieres eliminar este men\u00fa?')\">Eliminar</a> </td> </tr> </tbody> </table> </body> </html> crear.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Crear/Editar Men\u00fa</title> </head> <body> <h1 th:text=\"${#strings.equals(menu.id, '') ? 'Crear Nuevo Men\u00fa' : 'Editar Men\u00fa'}\"></h1> <form th:action=\"@{${#strings.equals(menu.id, '') ? '/menus/guardar' : '/menus/actualizar/' + menu.id}}\" th:object=\"${menu}\" method=\"post\"> <label for=\"nombre\">Nombre:</label> <input type=\"text\" id=\"nombre\" name=\"nombre\" th:value=\"${menu.nombre}\" required><br> <label for=\"descripcion\">Descripci\u00f3n:</label> <textarea id=\"descripcion\" name=\"descripcion\" th:text=\"${menu.descripcion}\" required></textarea><br> <label for=\"fecha\">Fecha:</label> <input type=\"date\" id=\"fecha\" name=\"fecha\" th:value=\"${menu.fecha}\" required><br> <label for=\"precioTotal\">Precio Total:</label> <input type=\"number\" id=\"precioTotal\" name=\"precioTotal\" th:value=\"${menu.precioTotal}\" step=\"0.01\" required><br> <button type=\"submit\">Guardar</button> <a href=\"/menus\">Cancelar</a> </form> </body> </html> detalles.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Detalles del Men\u00fa</title> </head> <body> <h1>Detalles del Men\u00fa</h1> <p><strong>Nombre:</strong> <span th:text=\"${menu.nombre}\"></span></p> <p><strong>Descripci\u00f3n:</strong> <span th:text=\"${menu.descripcion}\"></span></p> <p><strong>Fecha:</strong> <span th:text=\"${menu.fecha}\"></span></p> <p><strong>Precio Total:</strong> <span th:text=\"${menu.precioTotal}\"></span></p> <h2>Platos</h2> <ul> <li th:each=\"plato : ${menu.platos}\"> <strong th:text=\"${plato.nombre}\"></strong> - <span th:text=\"${plato.categoria}\"></span> (<span th:text=\"${plato.precio}\"></span> \u20ac) </li> </ul> <a href=\"/menus\">Volver</a> </body> </html> editar.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Crear/Editar Men\u00fa</title> </head> <body> <h1 th:text=\"${#strings.equals(menu.id, '') ? 'Crear Nuevo Men\u00fa' : 'Editar Men\u00fa'}\"></h1> <form th:action=\"@{${#strings.equals(menu.id, '') ? '/menus/guardar' : '/menus/actualizar/' + menu.id}}\" th:object=\"${menu}\" method=\"post\"> <label for=\"nombre\">Nombre:</label> <input type=\"text\" id=\"nombre\" name=\"nombre\" th:value=\"${menu.nombre}\" required><br> <label for=\"descripcion\">Descripci\u00f3n:</label> <textarea id=\"descripcion\" name=\"descripcion\" th:text=\"${menu.descripcion}\" required></textarea><br> <label for=\"fecha\">Fecha:</label> <input type=\"date\" id=\"fecha\" name=\"fecha\" th:value=\"${menu.fecha}\" required><br> <label for=\"precioTotal\">Precio Total:</label> <input type=\"number\" id=\"precioTotal\" name=\"precioTotal\" th:value=\"${menu.precioTotal}\" step=\"0.01\" required><br> <button type=\"submit\">Guardar</button> <a href=\"/menus\">Cancelar</a> </form> </body> </html> Vistas para visualizar los platos: /platos listar.kt <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Platos del Men\u00fa</title> </head> <body> <h1 th:text=\"'Platos del Men\u00fa: ' + ${menu.nombre}\"></h1> <a th:href=\"@{/menus}\">Volver a Men\u00fas</a> <table border=\"1\"> <thead> <tr> <th>Nombre</th> <th>Categor\u00eda</th> <th>Precio</th> <th>Ingredientes</th> </tr> </thead> <tbody> <tr th:each=\"plato : ${platos}\"> <td th:text=\"${plato.nombre}\"></td> <td th:text=\"${plato.categoria}\"></td> <td th:text=\"${plato.precio} + ' \u20ac'\"></td> <td> <a th:href=\"@{'/platos/' + ${menu.id} + '/ingredientes/' + ${plato.nombre}}\">Ver Ingredientes</a> </td> </tr> </tbody> </table> </body> </html> ingredientes.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Ingredientes</title> </head> <body> <h1 th:text=\"'Ingredientes del plato: ' + ${plato?.nombre}\"></h1> <div th:if=\"${error}\"> <p th:text=\"${error}\" style=\"color: red;\"></p> </div> <ul th:if=\"${ingredientes != null && !ingredientes.isEmpty()}\"> <li th:each=\"ingrediente : ${ingredientes}\" th:text=\"${ingrediente}\"></li> </ul> <p th:if=\"${ingredientes == null || ingredientes.isEmpty()}\" style=\"color: gray;\"> No hay ingredientes disponibles para este plato. </p> <a th:href=\"@{'/platos/' + ${menu.id}}\">Volver a los platos</a> </body> </html> buscarPorCategoria.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Buscar Men\u00fas por Categor\u00eda</title> </head> <body> <h1>Resultados para categor\u00eda: <span th:text=\"${categoriaBuscada}\"></span></h1> <table border=\"1\" th:if=\"${menus}\"> <thead> <tr> <th>ID</th> <th>Nombre</th> <th>Descripci\u00f3n</th> <th>Platos</th> </tr> </thead> <tbody> <tr th:each=\"menu : ${menus}\"> <td th:text=\"${menu.id}\"></td> <td th:text=\"${menu.nombre}\"></td> <td th:text=\"${menu.descripcion}\"></td> <td> <ul> <li th:each=\"plato : ${menu.platos}\" th:if=\"${plato.categoria == categoriaBuscada}\" th:text=\"${plato.nombre}\"></li> </ul> </td> </tr> </tbody> </table> <p th:if=\"${menus == null || menus.isEmpty()}\" style=\"color: gray;\"> No se encontraron men\u00fas con platos de la categor\u00eda <span th:text=\"${categoriaBuscada}\"></span>. </p> <a href=\"/menus\">Volver a la lista de men\u00fas</a> </body> </html> Con esta configuraci\u00f3n podemos listar los siguientes ejemplos: http://localhost:8888/menus : Lista todos los men\u00fas http://localhost:8888/menus/buscar?nombre=Men\u00fa Vegetariano: Busca un men\u00fa concreto. http://localhost:8888/platos/1: Lista los platos del men\u00fa 1. http://localhost:8888/platos/1/ingredientes/Ensalada Griega: Lista los ingredients del plato del men\u00fa 1. Nota Estos son alugunos ejemplos pero pod\u00e9is modificar el controlador y crear nuevas vistas para a\u00f1adir funcionalidad al programa y que muestre m\u00e1s resultados.","title":"Aplicaci\u00f3n Spring Data MongoDB"},{"location":"SpringMVC/","text":"Spring MVC Modelo-Vista-Controlador (MVC) El ejemplo visto en Spring Boot es tan sencillo que no necesita un patr\u00f3n de dise\u00f1o especial. Para aplicaciones m\u00e1s complejas necesitamos de un patr\u00f3n que nos permita crear aplicaciones con un c\u00f3digo bien estructurado y m\u00e1s f\u00e1cil de modificar, as\u00ed como reutilizar sus componentes en diferentes puntos de la aplicaci\u00f3n y que puedan evolucionar de manera independiente. Spring MVC nos proporciona un marco estructurado, flexible y eficiente para construir aplicaciones basadas en el patr\u00f3n Modelo-Vista-Controlador (MVC) que cumplan todas estas funcionalidades. El Modelo-Vista-Controlador (MVC) es un patr\u00f3n de dise\u00f1o que organiza una aplicaci\u00f3n en tres componentes principales : Modelo : Representa la l\u00f3gica del negocio y los datos de la aplicaci\u00f3n. Es responsable de: Gestionar el estado de la aplicaci\u00f3n. Interactuar con la base de datos u otros servicios para obtener y procesar datos. Proveer datos a la vista. Vista : Maneja la presentaci\u00f3n de los datos al usuario. Es responsable de: Renderizar informaci\u00f3n en un formato adecuado, como HTML. Mostrar al usuario los resultados de las acciones ejecutadas. Controlador : Act\u00faa como intermediario entre el modelo y la vista. Es responsable de: Procesar las solicitudes del usuario (peticiones HTTP). Interactuar con el modelo para obtener o modificar datos. Seleccionar y devolver la vista adecuada para responder al usuario. Flujo de trabajo en MVC 1) El usuario interact\u00faa con la interfaz (Vista), como enviar un formulario o hacer clic en un enlace. 2) La petici\u00f3n es enviada al Controlador. 3) El Controlador procesa la petici\u00f3n, interact\u00faa con el Modelo si es necesario, y selecciona la Vista que debe renderizar la respuesta. 4) La Vista presenta la respuesta al usuario. MVC en Spring Spring MVC est\u00e1 implementado como un servlet (el front controller) que implementa la gesti\u00f3n de las peticiones del cliente web, y se encarga de transmitirlas a un controlador adecuado. El controlador procesa la petici\u00f3n y crea un modelo que contiene los datos a devolver al usuario. Una vista se encarga de traducir el modelo a una representaci\u00f3n adecuada para el cliente (por ejemplo una p\u00e1gina HTML) Anotaciones comunes de Spring MVC: A continuaci\u00f3n se describen las anotaciones m\u00e1s utilizadas en cada uno de los componentes del modelo MVC en el entorno de Spring: 1) Controlador @Controller : Define una clase como un controlador de Spring MVC. Es la principal anotaci\u00f3n utilizada para que Spring la gestione como parte del patr\u00f3n MVC. @RestController : Si el controlador est\u00e1 destinado a manejar solicitudes RESTful y no necesita devolver vistas, se utiliza esta anotaci\u00f3n, que es una combinaci\u00f3n de @Controller y @ResponseBody. Devuelve datos directamente como JSON o XML. @RequestMapping : Se usa para mapear solicitudes HTTP a m\u00e9todos de un controlador. Puede configurarse para manejar diferentes tipos de solicitudes HTTP (GET, POST, etc.). @GetMapping, @PostMapping, @PutMapping, @DeleteMapping : Variantes de @RequestMapping para manejar solicitudes de tipos espec\u00edficos (GET, POST, PUT, DELETE). @RequestParam : Usada para obtener par\u00e1metros de la URL (query parameters) de la solicitud HTTP. @ModelAttribute : Usada para pre-poblar un modelo con atributos antes de que se ejecute un m\u00e9todo del controlador. Esto es \u00fatil, por ejemplo, cuando se usa en formularios. 2) Modelo @Entity : Si est\u00e1s utilizando JPA para la persistencia de datos, esta anotaci\u00f3n define una clase como una entidad que ser\u00e1 mapeada a una tabla de la base de datos. @Table : Usada junto con @Entity para especificar la tabla en la base de datos que corresponde a la entidad. @Entity @Table(name = \"comarcas\") data class Comarca( @Id @GeneratedValue(strategy = GenerationType.IDENTITY) val id: Int, val nombre: String, val poblacion: Int ) @Value : Si est\u00e1s utilizando Spring Expression Language (SpEL) en el modelo o en los controladores para asignar valores, puedes usar esta anotaci\u00f3n. @Value(\"\\${comarca.nombre}\") var nombre: String = \"\" 3) Vista La vista no tiene anotaciones propias en el c\u00f3digo fuente, sin embargo, si est\u00e1s utilizando Thymeleaf o JSP , la vista incluye elementos y sintaxis espec\u00edficos que act\u00faan como directrices para renderizar contenido din\u00e1mico. La vista ser\u00e1 un archivo HTML ubicado en src/main/resources/templates . Las anotaciones @RequestMapping o @GetMapping en el controlador, especifican que el controlador debe devolver una vista. En el siguiente ejemplo, en la carpeta src/main/resources/templates/comarca/ , puedes tener un archivo listar.html , que corresponde a la vista que se renderizar\u00e1 en el navegador. @GetMapping(\"/comarcas\") fun listarComarcas(model: Model): String { model.addAttribute(\"comarcas\", comarcaService.obtenerComarcas()) return \"comarca/listar\" // Devuelve el nombre de la plantilla Thymeleaf } Vista con Thymeleaf Si usas Thymeleaf para la vista, las anotaciones en los archivos de plantilla son prefijos para atributos de HTML. Estos prefijos permiten el manejo din\u00e1mico de datos en la vista. Ejemplo <h1>Lista de Comarcas</h1> <table> <tr th:each=\"comarca : ${comarcas}\"> <td th:text=\"${comarca.nombre}\"></td> <td th:text=\"${comarca.poblacion}\"></td> </tr> </table> A continuaci\u00f3n, se detallan los elementos comunes de las vistas con Thymeleaf : th:text : Rellena el contenido de un elemento HTML con el valor din\u00e1mico. <p th:text=\"${mensaje}\">Mensaje por defecto</p> th:each : Itera sobre una colecci\u00f3n. <ul> <li th:each=\"item : ${items}\" th:text=\"${item}\"></li> </ul> Esto genera una lista basada en los elementos de la colecci\u00f3n items. th:if y th:unless : Renderiza un contenido condicionalmente. <p th:if=\"${condicion}\">Esto se muestra si la condici\u00f3n es verdadera</p> <p th:unless=\"${condicion}\">Esto se muestra si la condici\u00f3n es falsa</p> th:href y th:src : Construye enlaces din\u00e1micos para atributos como href o src. <a th:href=\"@{/ruta/{id}(id=${itemId})}\">Ver detalle</a> <img th:src=\"@{/imagenes/logo.png}\" alt=\"Logo\"> th:action : Define la URL para un formulario. <form th:action=\"@{/procesar}\" method=\"post\"> <input type=\"text\" name=\"nombre\"> <button type=\"submit\">Enviar</button> </form> th:value y th:field : Usado para rellenar valores din\u00e1micos en campos de formulario. <input type=\"text\" th:field=\"*{nombre}\" /> Vista sin motores de plantilla Si tu aplicaci\u00f3n no utiliza motores de plantillas y solo devuelve datos en formatos como JSON o XML, entonces las vistas suelen ser gestionadas directamente por el controlador. En este caso: @RestController en el controlador garantiza que el contenido se devuelva en el formato adecuado, sin necesidad de vistas expl\u00edcitas. El contenido es generado din\u00e1micamente a trav\u00e9s de bibliotecas como Jackson (para JSON). Ejemplo de un controlador que devuelve JSON: @RestController class PersonaRestController { @GetMapping(\"/api/personas\") fun listarPersonas(): List<Persona> { return listOf( Persona(1, \"Juan\"), Persona(2, \"Ana\") ) } } Primera Aplicaci\u00f3n Spring MVC Al igual que se describe en el apartado de Spring Boot, podemos crear los proyectos Spring MVC de dos maneras: Mediante una herramienta web online ( https://start.spring.io/ ) denominada Spring Initializr , donde por medio de unos par\u00e1metros de configuraci\u00f3n, genera autom\u00e1ticamente un proyecto Maven o Gradle, seg\u00fan elijamos, en un archivo comprimido Zip, con la estructura de la aplicaci\u00f3n para ser importada directamente desde un IDE. Mediante un IDE, como Eclipse, IntelliJ...etc, teniendo instalados los plugins necesarios. En nuestro caso crearemos un proyecto Maven de Spring Boot en IntelliJ . La estructura general de un proyecto Spring MVC en IntelliJ ser\u00eda esta: Los pasos a seguir ser\u00edan: Configurar el proyecto A\u00f1adir las dependencias necesarias. Estructurar el proyecto en los componentes MVC. Configurar el fichero de propiedades. Enunciado de la aplicaci\u00f3n En este ejemplo vamos a crear una aplicaci\u00f3n sencilla que muestre una lista de nombres de personas, y tambi\u00e9n permita a\u00f1adir un nombre de persona nuevo. Todo mediantes Spring MVC y Thymeleaf . Configurar el proyecto 1) En IntelliJ creamos el proyecto y lo configuramos desde File-->New-->Project : Elige Spring Boot . Configura las siguientes opciones: Language: Kotlin Build System: Maven Especifica un nombre para el proyecto: PrimerSpringMVCsencllo \u00daltima versi\u00f3n de JDK \u00daltima versi\u00f3n de Java 2) Posteriormente seleccionamos las dependencias necesarias: Spring Web (para el desarrollo de aplicaciones web) Thymeleaf (motor de plantillas para la vista) Spring Boot DevTools (opcional, para facilitar el desarrollo) Despu\u00e9s de aceptar, y si todo ha ido correctamente, ya tendremos nuestro proyecto creado y preparado para a\u00f1adir los elementos de programaci\u00f3n. Al iniciar nuestra aplicaci\u00f3n, lo primero que observamos es que se crea una clase PrimerSpringMVCsenclloApplication que sirve como contenedor para la configuraci\u00f3n de la aplicaci\u00f3n. No necesita implementar m\u00e9todos adicionales, ya que Spring Boot se encarga de todo gracias a la anotaci\u00f3n @SpringBootApplication . Estructura del proyecto La estructura del proyecto podr\u00eda ser esta: En la carperta src/main/kotlin/org/example/primerspringmvcsencillo crearemos los paquetes: controller model service En la carperta src/main/resources/template crearemos la carpeta persona donde a\u00f1adiremos las vistas que muestren el resultado de la aplicaci\u00f3n. Implementaci\u00f3n de la aplicaci\u00f3n Ahora ya podemos a\u00f1adir la programaci\u00f3n necesaria para nuestra aplicaci\u00f3n siguiendo la estructura MVC creada. Dentro de cada paquete crearemos los siguientes archivos: Model/Persona.kt : El modelo Persona es muy simple, solo tendr\u00e1 un nombre. package com.ejemplo.model data class Persona( val id: Int, val nombre: String ) Service/PersonaService.kt : El servicio se encargar\u00e1 de la l\u00f3gica de negocio. En este caso, solo vamos a mantener una lista de personas en memoria. package com.ejemplo.service import org.example.primerspringmvcsencllo.model.Persona import org.springframework.stereotype.Service @Service class PersonaService { private val personas = mutableListOf( Persona(1, \"Juan\"), Persona(2, \"Ana\"), Persona(3, \"Luis\") ) fun obtenerPersonas(): List<Persona> = personas fun agregarPersona(persona: Persona) { personas.add(persona) } } Controller/PersonaController.kt El controlador maneja las solicitudes de las vistas y realiza la interacci\u00f3n con el servicio. package com.ejemplo.controller import org.example.primerspringmvcsencllo.model.Persona import org.example.primerspringmvcsencllo.service.PersonaService import org.springframework.stereotype.Controller import org.springframework.ui.Model import org.springframework.web.bind.annotation.GetMapping import org.springframework.web.bind.annotation.PostMapping import org.springframework.web.bind.annotation.RequestParam @Controller class PersonaController(private val personaService: PersonaService) { @GetMapping(\"/personas\") fun listarPersonas(model: Model): String { model.addAttribute(\"personas\", personaService.obtenerPersonas()) return \"persona/listar\" } @GetMapping(\"/personas/agregar\") fun mostrarFormularioAgregar(): String { return \"persona/agregar\" } @PostMapping(\"/personas/agregar\") fun agregarPersona(@RequestParam nombre: String): String { val persona = Persona(0, nombre) // ID auto-generado personaService.agregarPersona(persona) return \"redirect:/personas\" } } Plantillas Thymeleaf Para la vista utilizaremos dos plantillas Thymeleaf, una para listar los nombres de la personas y otra para agregar una persona nueva. En la carpeta src/resources/templates/persona , crearemos los siguienes archivos html: a) Plantilla listar.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Lista de Personas</title> </head> <body> <h1>Lista de Personas</h1> <ul> <li th:each=\"persona : ${personas}\" th:text=\"${persona.nombre}\"></li> </ul> <a href=\"/personas/agregar\">Agregar Persona</a> </body> </html> b) Plantilla agregar.html Esta plantilla proporciona un formulario para agregar una nueva persona. <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Agregar Persona</title> </head> <body> <h1>Agregar Persona</h1> <form action=\"/personas/agregar\" method=\"post\"> <label for=\"nombre\">Nombre:</label> <input type=\"text\" id=\"nombre\" name=\"nombre\" required/> <button type=\"submit\">Agregar</button> </form> </body> </html> Configurar el Archivo application.properties En el directorio src/main/resources, configura el archivo application.properties con las propiedades b\u00e1sicas: spring.thymeleaf.prefix=classpath:/templates/ spring.thymeleaf.suffix=.html server.port=8080 Recuerda que puedes cambiar el puerto si lo tienes ocupado. Puedes probar con el puerto 8888. Ejecutar la aplicaci\u00f3n La aplicaci\u00f3n estar\u00e1 disponible en http://localhost:8080. Aqu\u00ed podr\u00e1s: Ver la lista de personas al acceder a /personas . Agregar una nueva persona a trav\u00e9s del formulario en /personas/agregar . Nota Gracias a Spring DevTools , cualquier cambio que realices en el c\u00f3digo (por ejemplo, en las plantillas o en los controladores) se reflejar\u00e1 autom\u00e1ticamente en la aplicaci\u00f3n sin tener que reiniciarla manualmente. Ejemplo con acceso a Bases de Datos Postgres. En este ejemplo vamos a crear una aplicaci\u00f3n sencilla que acceda a una base de datos Postgres. Para ello utilizaremos la base de datos geo_ad , que ya conocemos de temas anteriores, y que se encuentra en el servidor externo 89.36.214.106 . La aplicaci\u00f3n simplemente mostrar\u00e1 la informaci\u00f3n de la tabla comarcas . Para esta aplicaci\u00f3n crearemos un nuevo proyecto, con la misma configuraci\u00f3n que el anterior, pero a\u00f1adiremos las dependencias necesarias de acceso a la Base de Datos. Configurar el proyecto 1) Creamos el proyecto y lo configuramos desde File-->New-->Project : Elige Spring Boot . Configura las siguientes opciones: Language: Kotlin Build System: Maven Especifica un nombre para el proyecto: PrimerSpringMVC \u00daltima versi\u00f3n de JDK \u00daltima versi\u00f3n de Java 2) Posteriormente seleccionamos las dependencias necesarias: Note Como la aplicaci\u00f3n accede a una Base de datos, necesitaremos las dependencias adicionales Spring Data JPA y PostgreSQL Driver . Spring Web (para el desarrollo de aplicaciones web) Thymeleaf (motor de plantillas para la vista) Spring Boot DevTools (opcional, para facilitar el desarrollo) Spring Data JPA (facilita la integraci\u00f3n de aplicaciones Spring con bases de datos relacionales utilizando el marco JPA (Java Persistence API)) PostgresSQL Driver (proporciona el controlador JDBC para conectarse a bases de datos PostgreSQL.) Despu\u00e9s de aceptar, y si todo ha ido correctamente, ya tendremos nuestro proyecto creado y preparado para a\u00f1adir los elementos de programaci\u00f3n. Al iniciar nuestra aplicaci\u00f3n, lo primero que observamos es que se crea una clase PrimerSpringMVCApplication que sirve como contenedor para la configuraci\u00f3n de la aplicaci\u00f3n. No necesita implementar m\u00e9todos adicionales, ya que Spring Boot se encarga de todo gracias a la anotaci\u00f3n @SpringBootApplication . Crear la estructura del Proyecto La estructura b\u00e1sica del proyecto debe reflejar el patr\u00f3n MVC. Organiza las carpetas de la siguiente forma: Controladores : src/main/kotlin/org/tuapp/controller Vistas : src/main/resources/templates Recursos est\u00e1ticos : src/main/resources/static Datos : src/main/kotlin/org/tuapp/model Repositorio : src/main/kotlin/org/tuapp/repository Para ello crea los paquetes: controller , model y repository dentro de la carpeta src/main/kotlin/org/tuapp . Implementaci\u00f3n de la aplicaci\u00f3n Ahora ya podemos a\u00f1adir la programaci\u00f3n necesaria para nuestra aplicaci\u00f3n siguiendo la estructura MVC creada. Dentro de cada paquete crearemos los siguientes archivos: Entidad JPA Define las entidades que corresponden a las tablas existentes en la base de datos. No necesitas configuraciones especiales m\u00e1s all\u00e1 de mapear las columnas. En nuestro caso definimos la entidad comarca y sus campos. En el paquete model crea un archivo llamado comarca.kt import jakarta.persistence.* @Entity /*Define una clase como una entidad JPA, lo que significa que estar\u00e1 mapeada a una tabla en la base de datos.*/ @Table(name = \"comarca\") data class comarca( @Id /*dentifica el campo como la clave primaria de la entidad.*/ val nom_c: String = \"\", val provincia: String = \"\" ) Repositorio Crea un repositorio que permita ejecutar consultas sobre la tabla correspondiente. Dentro del paquete repository , crea un archivo llamado ComarcaRepository.kt import org.example.primerspringmvc.model.comarca import org.springframework.data.jpa.repository.JpaRepository import org.springframework.stereotype.Repository @Repository interface ComarcaRepository : JpaRepository<comarca, String> { fun findByProvincia(provincia: String): List<comarca> } Controlador El controlador manejar\u00e1 las solicitudes GET para obtener informaci\u00f3n de la base de datos. Dentro del paquete controller , crea un archivo llamado ComarcaController.kt import org.example.primerspringmvc.model.comarca import org.example.primerspringmvc.repository.ComarcaRepository import org.springframework.web.bind.annotation.* @RestController @RequestMapping(\"/comarcas\") class ComarcaController(private val comarcaRepository: ComarcaRepository) { // Endpoint para obtener todas las comarcas @GetMapping fun obtenerComarcas(): List<comarca> = comarcaRepository.findAll() } @RestController: Combina @Controller y @ResponseBody . Devuelve directamente datos en formato JSON en lugar de buscar vistas como Thymeleaf. ObtenerComarcas() : Devuelve una lista de objetos comarca. Spring autom\u00e1ticamente convierte esta lista a JSON usando Jackson (que viene incluido con Spring Boot). Vistas Las vistas pueden ser representadas por tecnolog\u00edas como JSP, Thymeleaf, o JSON (en caso de APIs). En este ejemplo vamos a visualizar los datos en un navegador con formato JSON y m\u00e1s adelante lo haremos mediante Thymeleaf para ver ambos casos. Configurar la conexi\u00f3n al Servidor Postgres: En el archivo src/main/resources/application.properties configura la conexi\u00f3n a tu base de datos existente: spring.datasource.url=jdbc:postgresql://<HOST>:<PUERTO>/<DB_NAME> spring.datasource.username=<USUARIO> spring.datasource.password=<CONTRASE\u00d1A> spring.jpa.hibernate.ddl-auto=update Cambiaremos los datos de conexi\u00f3n al servidor externo: Recuerda que puedes cambiar el puerto si lo tienes ocupado. Puedes probar con el puerto 8888. Ejecutar la aplicaci\u00f3n La aplicaci\u00f3n estar\u00e1 disponible en http://localhost:8080, o el puerto que hayas especificado, para listar las comarcas. Ser\u00eda deseable que el resultado se mostrara de manera m\u00e1s amigable para el usuario, por lo que en el siguiente ejemplo haremos los cambios necesarios para utilizar Thymeleaf y que el resultado se muetre en cajas de texto. Thymeleaf para mostrar los resultados: 1) Configuraci\u00f3n de dependencias . Aseg\u00farate de tener la dependencia de Thymeleaf en tu archivo pom.xml. Esta dependencia la hemos seleccionado al configurar la aplicaci\u00f3n y seguramente ya la tengamos incluida. <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-thymeleaf</artifactId> </dependency> 2) Configurar Thymeleaf en application.properties A\u00f1ade las siguientes propiedades: spring.thymeleaf.prefix=classpath:/templates/ spring.thymeleaf.suffix=.html spring.thymeleaf.cache=false 3) Modificar el Controlador con datos del repositorio . El controlador debe recuperar los datos desde el repositorio y pasarlos a la vista usando un modelo. Cambia la implementaci\u00f3n del controlador: import org.springframework.stereotype.Controller import org.example.primerspringmvc.repository.ComarcaRepository import org.springframework.ui.Model import org.springframework.web.bind.annotation.* @Controller @RequestMapping(\"/comarcas\") class ComarcaController(private val ComarcaRepository: ComarcaRepository) { @GetMapping fun listarComarcas(model:Model): String { val comarcas = ComarcaRepository.findAll() model.addAttribute(\"comarcas\", comarcas) return \"comarcas\" // Nombre de la plantilla HTML } } 4) Vistas Para agregar un entorno de usuario amigable con cajas de texto y que los datos de la base de datos se muestren en una aplicaci\u00f3n web, crea un archivo comarcas.html en el directorio src/main/resources/templates . <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Lista de Comarcas</title> </head> <body> <h1>Lista de Comarcas</h1> <table border=\"1\"> <tr> <th>ID</th> <th>Provincia</th> </tr> <tr th:each=\"comarca : ${comarcas}\"> <td th:text=\"${comarca.nom_c}\">ID</td> <td th:text=\"${comarca.provincia}\">Provincia</td> </tr> </table> </body> </html> th:each : Itera sobre la lista de comarcas. th:text : Inserta din\u00e1micamente el valor de un campo en el HTML. Ejecuatar la aplicaci\u00f3n Accede a http://localhost:8888/comarcas para listar las comarcas. En el navegador, se mostrar\u00e1 una tabla HTML con las comrcas almacenadas en la base de datos. Los datos din\u00e1micos se renderizan usando Thymeleaf . Este enfoque permite crear interfaces web amigables y bien estructuradas. Ejemplo de consulta a la Base de datos Con la anotaci\u00f3n @Query en el repositorio, podemos realizar consultas personalizadas a la base de datos. A continuaci\u00f3n veremos los cambios que deber\u00edamos hacer en los ficheros para poder hacer una consulta con par\u00e1metros y visualizar los datos tanto en json com con thymeleaf: Cambios en los ficheros .kt: ComarcaRepository import org.springframework.data.jpa.repository.Query import org.springframework.data.repository.query.Param import org.example.primerspringmvc.model.comarca import org.springframework.data.jpa.repository.JpaRepository import org.springframework.stereotype.Repository @Repository interface ComarcaRepository : JpaRepository<comarca, Long> { @Query(\"SELECT c FROM comarca c WHERE c.provincia = :provincia\") fun findComarcasporProvincia(@Param(\"provincia\") provincia: String): List<comarca> } ComarcaController import org.example.primerspringmvc.model.comarca import org.springframework.stereotype.Controller import org.example.primerspringmvc.repository.ComarcaRepository import org.springframework.ui.Model import org.springframework.web.bind.annotation.* @RestController //en lugar de @Controller @RequestMapping(\"/comarcas\") class ComarcaController(private val ComarcaRepository: ComarcaRepository) { @GetMapping(\"/buscar\") fun buscarComarcasPorProvincia(@RequestParam provincia: String): List<comarca> { return ComarcaRepository.findComarcasporProvincia(provincia) } } Anotaciones importantes @Query : Permite definir consultas SQL personalizadas directamente en el repositorio. La consulta SELECT c FROM Comarca c WHERE c.provincia = :provincia selecciona todas las comarcas donde la columna provincia coincide con el par\u00e1metro provincia. @Param : Vincula el par\u00e1metro de la consulta con el valor que se pasa desde el m\u00e9todo. En este caso, @Param(\"provincia\") conecta el par\u00e1metro provincia de la consulta SQL con el argumento del m\u00e9todo. @GetMapping y @RequestParam : Define un endpoint HTTP GET en el controlador. El par\u00e1metro provincia se obtiene de la URL. Por ejemplo, si queremos listar las comarcas de la provincia de Alacant, obtenemos: Visualizar la salida con Thymeleaf Si la visualizaci\u00f3n la queremos hacer con Thymeleaf los cambios a realizar se har\u00edan solo en ComarcasController , ya que el formulaio comarcas.html se puede seguir utilizando si queremos mostrar los mismos campos: import org.springframework.stereotype.Controller import org.example.primerspringmvc.repository.ComarcaRepository import org.springframework.ui.Model import org.springframework.web.bind.annotation.* @Controller //en lugar de @RestController @RequestMapping(\"/comarcas\") class ComarcaController(private val ComarcaRepository: ComarcaRepository) { @GetMapping fun listarComarcas(model:Model): String { val comarcas = ComarcaRepository.findAll() model.addAttribute(\"comarcas\", comarcas) return \"comarcas\" // Nombre de la plantilla HTML } @GetMapping(\"/buscar\") fun buscarComarcasPorProvincia(@RequestParam provincia: String, model: Model): String { val comarcas= ComarcaRepository.findComarcasporProvincia(provincia) model.addAttribute(\"comarcas\", comarcas) return \"comarcas\" // Nombre de la plantilla HTML } } Y el resultado se ver\u00eda as\u00ed: Base de datos en contenedor Docker Para no tener que instalarnos un servidor Postgres en nuestro equipo, podemos tener nuestra base de datos en un contenedor Docker. En este caso, los cambios principales se centran en la configuraci\u00f3n de conexi\u00f3n en la aplicaci\u00f3n y en el despliegue del contenedor de PostgreSQL. Antes de acceder al contenedor tenemos que crearlo. En nuestro caso crearemos un contenedor Docker de Postgres y posteriormente restauraremos la base de datos geo_ad en dicho contenedor, para poder disponer de la misma configuracion y los mismos datos que en el servidor externo. Partimos del hecho que tenemos instalado Docker en nuesto equipo, en caso contario te dejo un peque\u00f1o tutorial de como instalarlo en el apartado Docker de esta unidad. Los pasos a seguir para crear dicho contendor son: 1) Ejecutar PostgreSQL en Docker Crea y ejecuta el contenedor de PostgreSQL: docker run --name postgres-container -e POSTGRES_USER=admin -e POSTGRES_PASSWORD=admin -e POSTGRES_DB=demo -p 5432:5432 -d postgres POSTGRES_USER: Usuario de la base de datos. POSTGRES_PASSWORD: Contrase\u00f1a del usuario. POSTGRES_DB: Nombre de la base de datos. -p 5432:5432: Mapea el puerto 5432 del contenedor al puerto 5432 de tu m\u00e1quina. Verifica que el contenedor est\u00e9 corriendo: docker ps (Opcional) Con\u00e9ctate al contenedor para verificar la base de datos, desde DBeaver , o desde el terminal: docker exec -it postgres-container psql -U admin -d demo 1) Restaurar la base de datos en el contenedor con DBeaver : Vamos a restaurar la base de datos geo_ad en la base de datos demo , que hemos creado con docker. Para ello os he dejado un archivo dump , en el apartado recursos de Aules , que contiene el backup de geo_ad. Lo siguiente ser\u00e1 restaurar este backup en demo , siguiendo esto pasos: Crear una nueva conexi\u00f3n en DBeaver al contenedor local: Host: localhost Puerto: 5432 Usuario y contrase\u00f1a: admin Base de datos: demo Restaurar el archivo de respaldo: Haz clic derecho en la base de datos en el contenedor \u2192 Herramientas > Restaurar (Restore). Archivo de respaldo : Selecciona el archivo de respaldo exportado, disponible en el aula virtual en la carpeta de recursos del tema. Pulsa Start y espera a que termine la restauraci\u00f3n. Una vez terminado selecciona cancelar para que no vuelva a realizar la restauraci\u00f3n. 3) Cambios en la Configuraci\u00f3n de la Aplicaci\u00f3n En el archivo application.properties , configura la conexi\u00f3n a PostgreSQL en el contenedor Docker. Aseg\u00farate de usar la IP del contenedor o localhost si est\u00e1s ejecutando la aplicaci\u00f3n desde la misma m\u00e1quina. Opci\u00f3n 1: Usar localhost (si el contenedor est\u00e1 corriendo en tu m\u00e1quina) spring.datasource.url=jdbc:postgresql://localhost:5432/demo spring.datasource.username=admin spring.datasource.password=admin spring.jpa.hibernate.ddl-auto=none spring.jpa.show-sql=true spring.jpa.properties.hibernate.format_sql=true Opci\u00f3n 2: Utilizar la IP del contenedor (si la aplicaci\u00f3n est\u00e1 en otro contenedor) Para encontrar la IP del contenedor PostgreSQL: docker inspect postgres-container | grep IPAddress Utiliza la IP encontrada para configurar la conexi\u00f3n: spring.datasource.url=jdbc:postgresql://<IP_DEL_CONTENEDOR>:5432/demo spring.datasource.username=admin spring.datasource.password=admin spring.jpa.hibernate.ddl-auto=none spring.jpa.show-sql=true spring.jpa.properties.hibernate.format_sql=true Todos los cambios que necesitas para ejecutar la aplicaci\u00f3n y que acceda a la base de datos que se encuentra en el contenedor son los anteriormente descritos. El resto de ficheros y estructura no se ver\u00e1 afectada. Una vez tenemos la base de datos restaurada con los datos de geo_ad ya podemos ejecutar la aplicaci\u00f3n y comprobar que los resultados son los mismos que si accedemos a la base de datos del servidor. Operaciones CRUD sobre base de datos en contenedor Docker Siguiendo con el ejemplo visto en Spring MVC, de acceder a una base de datos relacional Postgres en un contenedor Docker, en este apartado iremos m\u00e1s all\u00e1 y veremos como realizar operaciones CRUD, ya que ahora la base de datos est\u00e1 en local y podemos hacer todas las modificaciones que necesitemos. Como ejemplo, haremos modificaciones sobre la tabla comarcas . El \u00fanico fichero a modificar ser\u00e1 el controlador (ComarcaController.kt) y la creaci\u00f3n de nuevas vistas para visualizar los resultados: 1) Create Controlador @Controller @RequestMapping(\"/comarcas\") class ComarcaController(private val comarcaRepository: ComarcaRepository) { @GetMapping(\"/nueva\") fun mostrarFormularioNuevaComarca(model: Model): String { model.addAttribute(\"comarca\", comarca()) return \"nueva-comarca\" } @PostMapping(\"/nueva\") fun guardarComarca(@ModelAttribute comarca: comarca): String { comarcaRepository.save(comarca) return \"redirect:/comarcas\" } } Vista (nueva-comarca.html) <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Nueva Comarca</title> </head> <body> <h1>Nueva Comarca</h1> <form th:action=\"@{/comarcas/nueva}\" th:object=\"${comarca}\" method=\"post\"> <label for=\"nom_c\">Nombre:</label> <input type=\"text\" id=\"nom_c\" name=\"nom_c\" th:value=\"*{nom_c}\" required><br> <label for=\"provincia\">Provincia:</label> <input type=\"text\" id=\"provincia\" name=\"provincia\" th:value=\"*{provincia}\" required><br> <button type=\"submit\">Guardar</button> </form> </body> </html> 2) Read Controlador : Ya implementado en el ejercicio anterior. @GetMapping fun listarComarcas(model: Model): String { val comarcas = comarcaRepository.findAll() model.addAttribute(\"comarcas\", comarcas) return \"comarcas\" } Vista (comarcas.html) : Ya creada en el ejercicio anterior. 3) Update Controlador @GetMapping(\"/editar/{id}\") fun mostrarFormularioEditarComarca(@PathVariable id: String, model: Model): String { val comarca = comarcaRepository.findById(id).orElseThrow { IllegalArgumentException(\"Comarca no encontrada: $id\") } model.addAttribute(\"comarca\", comarca) return \"editar-comarca\" } @PostMapping(\"/editar/{id}\") fun actualizarComarca(@PathVariable id: String, @ModelAttribute comarca: comarca): String { if (!comarcaRepository.existsById(id)) { throw IllegalArgumentException(\"Comarca no encontrada: $id\") } comarcaRepository.save(comarca) return \"redirect:/comarcas\" } Vista (editar-comarca.html) <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Editar Comarca</title> </head> <body> <h1>Editar Comarca</h1> <form th:action=\"@{/comarcas/editar/{id}(id=${comarca.nom_c})}\" th:object=\"${comarca}\" method=\"post\"> <label for=\"nom_c\">Nombre:</label> <input type=\"text\" id=\"nom_c\" name=\"nom_c\" th:value=\"*{nom_c}\" readonly><br> <label for=\"provincia\">Provincia:</label> <input type=\"text\" id=\"provincia\" name=\"provincia\" th:value=\"*{provincia}\" required><br> <button type=\"submit\">Actualizar</button> </form> </body> </html> 4) Delete Controlador @GetMapping(\"/eliminar/{id}\") fun eliminarComarca(@PathVariable id: String): String { if (!comarcaRepository.existsById(id)) { throw IllegalArgumentException(\"Comarca no encontrada: $id\") } comarcaRepository.deleteById(id) return \"redirect:/comarcas\" } Vista (Modificar comarcas.html para agregar la opci\u00f3n de eliminar) <tr th:each=\"comarca : ${comarcas}\"> <td th:text=\"${comarca.nom_c}\">ID</td> <td th:text=\"${comarca.provincia}\">Provincia</td> <td> <a th:href=\"@{/comarcas/editar/{id}(id=${comarca.nom_c})}\">Editar</a> <a th:href=\"@{/comarcas/eliminar/{id}(id=${comarca.nom_c})}\" onclick=\"return confirm('\u00bfEst\u00e1s seguro?')\">Eliminar</a> </td> </tr>","title":"4 - Spring MVC"},{"location":"SpringMVC/#spring-mvc","text":"","title":"Spring MVC"},{"location":"SpringMVC/#modelo-vista-controlador-mvc","text":"El ejemplo visto en Spring Boot es tan sencillo que no necesita un patr\u00f3n de dise\u00f1o especial. Para aplicaciones m\u00e1s complejas necesitamos de un patr\u00f3n que nos permita crear aplicaciones con un c\u00f3digo bien estructurado y m\u00e1s f\u00e1cil de modificar, as\u00ed como reutilizar sus componentes en diferentes puntos de la aplicaci\u00f3n y que puedan evolucionar de manera independiente. Spring MVC nos proporciona un marco estructurado, flexible y eficiente para construir aplicaciones basadas en el patr\u00f3n Modelo-Vista-Controlador (MVC) que cumplan todas estas funcionalidades. El Modelo-Vista-Controlador (MVC) es un patr\u00f3n de dise\u00f1o que organiza una aplicaci\u00f3n en tres componentes principales : Modelo : Representa la l\u00f3gica del negocio y los datos de la aplicaci\u00f3n. Es responsable de: Gestionar el estado de la aplicaci\u00f3n. Interactuar con la base de datos u otros servicios para obtener y procesar datos. Proveer datos a la vista. Vista : Maneja la presentaci\u00f3n de los datos al usuario. Es responsable de: Renderizar informaci\u00f3n en un formato adecuado, como HTML. Mostrar al usuario los resultados de las acciones ejecutadas. Controlador : Act\u00faa como intermediario entre el modelo y la vista. Es responsable de: Procesar las solicitudes del usuario (peticiones HTTP). Interactuar con el modelo para obtener o modificar datos. Seleccionar y devolver la vista adecuada para responder al usuario. Flujo de trabajo en MVC 1) El usuario interact\u00faa con la interfaz (Vista), como enviar un formulario o hacer clic en un enlace. 2) La petici\u00f3n es enviada al Controlador. 3) El Controlador procesa la petici\u00f3n, interact\u00faa con el Modelo si es necesario, y selecciona la Vista que debe renderizar la respuesta. 4) La Vista presenta la respuesta al usuario.","title":"Modelo-Vista-Controlador (MVC)"},{"location":"SpringMVC/#mvc-en-spring","text":"Spring MVC est\u00e1 implementado como un servlet (el front controller) que implementa la gesti\u00f3n de las peticiones del cliente web, y se encarga de transmitirlas a un controlador adecuado. El controlador procesa la petici\u00f3n y crea un modelo que contiene los datos a devolver al usuario. Una vista se encarga de traducir el modelo a una representaci\u00f3n adecuada para el cliente (por ejemplo una p\u00e1gina HTML)","title":"MVC en Spring"},{"location":"SpringMVC/#anotaciones-comunes-de-spring-mvc","text":"A continuaci\u00f3n se describen las anotaciones m\u00e1s utilizadas en cada uno de los componentes del modelo MVC en el entorno de Spring: 1) Controlador @Controller : Define una clase como un controlador de Spring MVC. Es la principal anotaci\u00f3n utilizada para que Spring la gestione como parte del patr\u00f3n MVC. @RestController : Si el controlador est\u00e1 destinado a manejar solicitudes RESTful y no necesita devolver vistas, se utiliza esta anotaci\u00f3n, que es una combinaci\u00f3n de @Controller y @ResponseBody. Devuelve datos directamente como JSON o XML. @RequestMapping : Se usa para mapear solicitudes HTTP a m\u00e9todos de un controlador. Puede configurarse para manejar diferentes tipos de solicitudes HTTP (GET, POST, etc.). @GetMapping, @PostMapping, @PutMapping, @DeleteMapping : Variantes de @RequestMapping para manejar solicitudes de tipos espec\u00edficos (GET, POST, PUT, DELETE). @RequestParam : Usada para obtener par\u00e1metros de la URL (query parameters) de la solicitud HTTP. @ModelAttribute : Usada para pre-poblar un modelo con atributos antes de que se ejecute un m\u00e9todo del controlador. Esto es \u00fatil, por ejemplo, cuando se usa en formularios. 2) Modelo @Entity : Si est\u00e1s utilizando JPA para la persistencia de datos, esta anotaci\u00f3n define una clase como una entidad que ser\u00e1 mapeada a una tabla de la base de datos. @Table : Usada junto con @Entity para especificar la tabla en la base de datos que corresponde a la entidad. @Entity @Table(name = \"comarcas\") data class Comarca( @Id @GeneratedValue(strategy = GenerationType.IDENTITY) val id: Int, val nombre: String, val poblacion: Int ) @Value : Si est\u00e1s utilizando Spring Expression Language (SpEL) en el modelo o en los controladores para asignar valores, puedes usar esta anotaci\u00f3n. @Value(\"\\${comarca.nombre}\") var nombre: String = \"\" 3) Vista La vista no tiene anotaciones propias en el c\u00f3digo fuente, sin embargo, si est\u00e1s utilizando Thymeleaf o JSP , la vista incluye elementos y sintaxis espec\u00edficos que act\u00faan como directrices para renderizar contenido din\u00e1mico. La vista ser\u00e1 un archivo HTML ubicado en src/main/resources/templates . Las anotaciones @RequestMapping o @GetMapping en el controlador, especifican que el controlador debe devolver una vista. En el siguiente ejemplo, en la carpeta src/main/resources/templates/comarca/ , puedes tener un archivo listar.html , que corresponde a la vista que se renderizar\u00e1 en el navegador. @GetMapping(\"/comarcas\") fun listarComarcas(model: Model): String { model.addAttribute(\"comarcas\", comarcaService.obtenerComarcas()) return \"comarca/listar\" // Devuelve el nombre de la plantilla Thymeleaf } Vista con Thymeleaf Si usas Thymeleaf para la vista, las anotaciones en los archivos de plantilla son prefijos para atributos de HTML. Estos prefijos permiten el manejo din\u00e1mico de datos en la vista. Ejemplo <h1>Lista de Comarcas</h1> <table> <tr th:each=\"comarca : ${comarcas}\"> <td th:text=\"${comarca.nombre}\"></td> <td th:text=\"${comarca.poblacion}\"></td> </tr> </table> A continuaci\u00f3n, se detallan los elementos comunes de las vistas con Thymeleaf : th:text : Rellena el contenido de un elemento HTML con el valor din\u00e1mico. <p th:text=\"${mensaje}\">Mensaje por defecto</p> th:each : Itera sobre una colecci\u00f3n. <ul> <li th:each=\"item : ${items}\" th:text=\"${item}\"></li> </ul> Esto genera una lista basada en los elementos de la colecci\u00f3n items. th:if y th:unless : Renderiza un contenido condicionalmente. <p th:if=\"${condicion}\">Esto se muestra si la condici\u00f3n es verdadera</p> <p th:unless=\"${condicion}\">Esto se muestra si la condici\u00f3n es falsa</p> th:href y th:src : Construye enlaces din\u00e1micos para atributos como href o src. <a th:href=\"@{/ruta/{id}(id=${itemId})}\">Ver detalle</a> <img th:src=\"@{/imagenes/logo.png}\" alt=\"Logo\"> th:action : Define la URL para un formulario. <form th:action=\"@{/procesar}\" method=\"post\"> <input type=\"text\" name=\"nombre\"> <button type=\"submit\">Enviar</button> </form> th:value y th:field : Usado para rellenar valores din\u00e1micos en campos de formulario. <input type=\"text\" th:field=\"*{nombre}\" /> Vista sin motores de plantilla Si tu aplicaci\u00f3n no utiliza motores de plantillas y solo devuelve datos en formatos como JSON o XML, entonces las vistas suelen ser gestionadas directamente por el controlador. En este caso: @RestController en el controlador garantiza que el contenido se devuelva en el formato adecuado, sin necesidad de vistas expl\u00edcitas. El contenido es generado din\u00e1micamente a trav\u00e9s de bibliotecas como Jackson (para JSON). Ejemplo de un controlador que devuelve JSON: @RestController class PersonaRestController { @GetMapping(\"/api/personas\") fun listarPersonas(): List<Persona> { return listOf( Persona(1, \"Juan\"), Persona(2, \"Ana\") ) } }","title":"Anotaciones comunes de Spring MVC:"},{"location":"SpringMVC/#primera-aplicacion-spring-mvc","text":"Al igual que se describe en el apartado de Spring Boot, podemos crear los proyectos Spring MVC de dos maneras: Mediante una herramienta web online ( https://start.spring.io/ ) denominada Spring Initializr , donde por medio de unos par\u00e1metros de configuraci\u00f3n, genera autom\u00e1ticamente un proyecto Maven o Gradle, seg\u00fan elijamos, en un archivo comprimido Zip, con la estructura de la aplicaci\u00f3n para ser importada directamente desde un IDE. Mediante un IDE, como Eclipse, IntelliJ...etc, teniendo instalados los plugins necesarios. En nuestro caso crearemos un proyecto Maven de Spring Boot en IntelliJ . La estructura general de un proyecto Spring MVC en IntelliJ ser\u00eda esta: Los pasos a seguir ser\u00edan: Configurar el proyecto A\u00f1adir las dependencias necesarias. Estructurar el proyecto en los componentes MVC. Configurar el fichero de propiedades. Enunciado de la aplicaci\u00f3n En este ejemplo vamos a crear una aplicaci\u00f3n sencilla que muestre una lista de nombres de personas, y tambi\u00e9n permita a\u00f1adir un nombre de persona nuevo. Todo mediantes Spring MVC y Thymeleaf . Configurar el proyecto 1) En IntelliJ creamos el proyecto y lo configuramos desde File-->New-->Project : Elige Spring Boot . Configura las siguientes opciones: Language: Kotlin Build System: Maven Especifica un nombre para el proyecto: PrimerSpringMVCsencllo \u00daltima versi\u00f3n de JDK \u00daltima versi\u00f3n de Java 2) Posteriormente seleccionamos las dependencias necesarias: Spring Web (para el desarrollo de aplicaciones web) Thymeleaf (motor de plantillas para la vista) Spring Boot DevTools (opcional, para facilitar el desarrollo) Despu\u00e9s de aceptar, y si todo ha ido correctamente, ya tendremos nuestro proyecto creado y preparado para a\u00f1adir los elementos de programaci\u00f3n. Al iniciar nuestra aplicaci\u00f3n, lo primero que observamos es que se crea una clase PrimerSpringMVCsenclloApplication que sirve como contenedor para la configuraci\u00f3n de la aplicaci\u00f3n. No necesita implementar m\u00e9todos adicionales, ya que Spring Boot se encarga de todo gracias a la anotaci\u00f3n @SpringBootApplication . Estructura del proyecto La estructura del proyecto podr\u00eda ser esta: En la carperta src/main/kotlin/org/example/primerspringmvcsencillo crearemos los paquetes: controller model service En la carperta src/main/resources/template crearemos la carpeta persona donde a\u00f1adiremos las vistas que muestren el resultado de la aplicaci\u00f3n. Implementaci\u00f3n de la aplicaci\u00f3n Ahora ya podemos a\u00f1adir la programaci\u00f3n necesaria para nuestra aplicaci\u00f3n siguiendo la estructura MVC creada. Dentro de cada paquete crearemos los siguientes archivos: Model/Persona.kt : El modelo Persona es muy simple, solo tendr\u00e1 un nombre. package com.ejemplo.model data class Persona( val id: Int, val nombre: String ) Service/PersonaService.kt : El servicio se encargar\u00e1 de la l\u00f3gica de negocio. En este caso, solo vamos a mantener una lista de personas en memoria. package com.ejemplo.service import org.example.primerspringmvcsencllo.model.Persona import org.springframework.stereotype.Service @Service class PersonaService { private val personas = mutableListOf( Persona(1, \"Juan\"), Persona(2, \"Ana\"), Persona(3, \"Luis\") ) fun obtenerPersonas(): List<Persona> = personas fun agregarPersona(persona: Persona) { personas.add(persona) } } Controller/PersonaController.kt El controlador maneja las solicitudes de las vistas y realiza la interacci\u00f3n con el servicio. package com.ejemplo.controller import org.example.primerspringmvcsencllo.model.Persona import org.example.primerspringmvcsencllo.service.PersonaService import org.springframework.stereotype.Controller import org.springframework.ui.Model import org.springframework.web.bind.annotation.GetMapping import org.springframework.web.bind.annotation.PostMapping import org.springframework.web.bind.annotation.RequestParam @Controller class PersonaController(private val personaService: PersonaService) { @GetMapping(\"/personas\") fun listarPersonas(model: Model): String { model.addAttribute(\"personas\", personaService.obtenerPersonas()) return \"persona/listar\" } @GetMapping(\"/personas/agregar\") fun mostrarFormularioAgregar(): String { return \"persona/agregar\" } @PostMapping(\"/personas/agregar\") fun agregarPersona(@RequestParam nombre: String): String { val persona = Persona(0, nombre) // ID auto-generado personaService.agregarPersona(persona) return \"redirect:/personas\" } } Plantillas Thymeleaf Para la vista utilizaremos dos plantillas Thymeleaf, una para listar los nombres de la personas y otra para agregar una persona nueva. En la carpeta src/resources/templates/persona , crearemos los siguienes archivos html: a) Plantilla listar.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Lista de Personas</title> </head> <body> <h1>Lista de Personas</h1> <ul> <li th:each=\"persona : ${personas}\" th:text=\"${persona.nombre}\"></li> </ul> <a href=\"/personas/agregar\">Agregar Persona</a> </body> </html> b) Plantilla agregar.html Esta plantilla proporciona un formulario para agregar una nueva persona. <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Agregar Persona</title> </head> <body> <h1>Agregar Persona</h1> <form action=\"/personas/agregar\" method=\"post\"> <label for=\"nombre\">Nombre:</label> <input type=\"text\" id=\"nombre\" name=\"nombre\" required/> <button type=\"submit\">Agregar</button> </form> </body> </html> Configurar el Archivo application.properties En el directorio src/main/resources, configura el archivo application.properties con las propiedades b\u00e1sicas: spring.thymeleaf.prefix=classpath:/templates/ spring.thymeleaf.suffix=.html server.port=8080 Recuerda que puedes cambiar el puerto si lo tienes ocupado. Puedes probar con el puerto 8888. Ejecutar la aplicaci\u00f3n La aplicaci\u00f3n estar\u00e1 disponible en http://localhost:8080. Aqu\u00ed podr\u00e1s: Ver la lista de personas al acceder a /personas . Agregar una nueva persona a trav\u00e9s del formulario en /personas/agregar . Nota Gracias a Spring DevTools , cualquier cambio que realices en el c\u00f3digo (por ejemplo, en las plantillas o en los controladores) se reflejar\u00e1 autom\u00e1ticamente en la aplicaci\u00f3n sin tener que reiniciarla manualmente.","title":"Primera Aplicaci\u00f3n Spring MVC"},{"location":"SpringMVC/#ejemplo-con-acceso-a-bases-de-datos-postgres","text":"En este ejemplo vamos a crear una aplicaci\u00f3n sencilla que acceda a una base de datos Postgres. Para ello utilizaremos la base de datos geo_ad , que ya conocemos de temas anteriores, y que se encuentra en el servidor externo 89.36.214.106 . La aplicaci\u00f3n simplemente mostrar\u00e1 la informaci\u00f3n de la tabla comarcas . Para esta aplicaci\u00f3n crearemos un nuevo proyecto, con la misma configuraci\u00f3n que el anterior, pero a\u00f1adiremos las dependencias necesarias de acceso a la Base de Datos. Configurar el proyecto 1) Creamos el proyecto y lo configuramos desde File-->New-->Project : Elige Spring Boot . Configura las siguientes opciones: Language: Kotlin Build System: Maven Especifica un nombre para el proyecto: PrimerSpringMVC \u00daltima versi\u00f3n de JDK \u00daltima versi\u00f3n de Java 2) Posteriormente seleccionamos las dependencias necesarias: Note Como la aplicaci\u00f3n accede a una Base de datos, necesitaremos las dependencias adicionales Spring Data JPA y PostgreSQL Driver . Spring Web (para el desarrollo de aplicaciones web) Thymeleaf (motor de plantillas para la vista) Spring Boot DevTools (opcional, para facilitar el desarrollo) Spring Data JPA (facilita la integraci\u00f3n de aplicaciones Spring con bases de datos relacionales utilizando el marco JPA (Java Persistence API)) PostgresSQL Driver (proporciona el controlador JDBC para conectarse a bases de datos PostgreSQL.) Despu\u00e9s de aceptar, y si todo ha ido correctamente, ya tendremos nuestro proyecto creado y preparado para a\u00f1adir los elementos de programaci\u00f3n. Al iniciar nuestra aplicaci\u00f3n, lo primero que observamos es que se crea una clase PrimerSpringMVCApplication que sirve como contenedor para la configuraci\u00f3n de la aplicaci\u00f3n. No necesita implementar m\u00e9todos adicionales, ya que Spring Boot se encarga de todo gracias a la anotaci\u00f3n @SpringBootApplication . Crear la estructura del Proyecto La estructura b\u00e1sica del proyecto debe reflejar el patr\u00f3n MVC. Organiza las carpetas de la siguiente forma: Controladores : src/main/kotlin/org/tuapp/controller Vistas : src/main/resources/templates Recursos est\u00e1ticos : src/main/resources/static Datos : src/main/kotlin/org/tuapp/model Repositorio : src/main/kotlin/org/tuapp/repository Para ello crea los paquetes: controller , model y repository dentro de la carpeta src/main/kotlin/org/tuapp . Implementaci\u00f3n de la aplicaci\u00f3n Ahora ya podemos a\u00f1adir la programaci\u00f3n necesaria para nuestra aplicaci\u00f3n siguiendo la estructura MVC creada. Dentro de cada paquete crearemos los siguientes archivos: Entidad JPA Define las entidades que corresponden a las tablas existentes en la base de datos. No necesitas configuraciones especiales m\u00e1s all\u00e1 de mapear las columnas. En nuestro caso definimos la entidad comarca y sus campos. En el paquete model crea un archivo llamado comarca.kt import jakarta.persistence.* @Entity /*Define una clase como una entidad JPA, lo que significa que estar\u00e1 mapeada a una tabla en la base de datos.*/ @Table(name = \"comarca\") data class comarca( @Id /*dentifica el campo como la clave primaria de la entidad.*/ val nom_c: String = \"\", val provincia: String = \"\" ) Repositorio Crea un repositorio que permita ejecutar consultas sobre la tabla correspondiente. Dentro del paquete repository , crea un archivo llamado ComarcaRepository.kt import org.example.primerspringmvc.model.comarca import org.springframework.data.jpa.repository.JpaRepository import org.springframework.stereotype.Repository @Repository interface ComarcaRepository : JpaRepository<comarca, String> { fun findByProvincia(provincia: String): List<comarca> } Controlador El controlador manejar\u00e1 las solicitudes GET para obtener informaci\u00f3n de la base de datos. Dentro del paquete controller , crea un archivo llamado ComarcaController.kt import org.example.primerspringmvc.model.comarca import org.example.primerspringmvc.repository.ComarcaRepository import org.springframework.web.bind.annotation.* @RestController @RequestMapping(\"/comarcas\") class ComarcaController(private val comarcaRepository: ComarcaRepository) { // Endpoint para obtener todas las comarcas @GetMapping fun obtenerComarcas(): List<comarca> = comarcaRepository.findAll() } @RestController: Combina @Controller y @ResponseBody . Devuelve directamente datos en formato JSON en lugar de buscar vistas como Thymeleaf. ObtenerComarcas() : Devuelve una lista de objetos comarca. Spring autom\u00e1ticamente convierte esta lista a JSON usando Jackson (que viene incluido con Spring Boot). Vistas Las vistas pueden ser representadas por tecnolog\u00edas como JSP, Thymeleaf, o JSON (en caso de APIs). En este ejemplo vamos a visualizar los datos en un navegador con formato JSON y m\u00e1s adelante lo haremos mediante Thymeleaf para ver ambos casos. Configurar la conexi\u00f3n al Servidor Postgres: En el archivo src/main/resources/application.properties configura la conexi\u00f3n a tu base de datos existente: spring.datasource.url=jdbc:postgresql://<HOST>:<PUERTO>/<DB_NAME> spring.datasource.username=<USUARIO> spring.datasource.password=<CONTRASE\u00d1A> spring.jpa.hibernate.ddl-auto=update Cambiaremos los datos de conexi\u00f3n al servidor externo: Recuerda que puedes cambiar el puerto si lo tienes ocupado. Puedes probar con el puerto 8888. Ejecutar la aplicaci\u00f3n La aplicaci\u00f3n estar\u00e1 disponible en http://localhost:8080, o el puerto que hayas especificado, para listar las comarcas. Ser\u00eda deseable que el resultado se mostrara de manera m\u00e1s amigable para el usuario, por lo que en el siguiente ejemplo haremos los cambios necesarios para utilizar Thymeleaf y que el resultado se muetre en cajas de texto. Thymeleaf para mostrar los resultados: 1) Configuraci\u00f3n de dependencias . Aseg\u00farate de tener la dependencia de Thymeleaf en tu archivo pom.xml. Esta dependencia la hemos seleccionado al configurar la aplicaci\u00f3n y seguramente ya la tengamos incluida. <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-thymeleaf</artifactId> </dependency> 2) Configurar Thymeleaf en application.properties A\u00f1ade las siguientes propiedades: spring.thymeleaf.prefix=classpath:/templates/ spring.thymeleaf.suffix=.html spring.thymeleaf.cache=false 3) Modificar el Controlador con datos del repositorio . El controlador debe recuperar los datos desde el repositorio y pasarlos a la vista usando un modelo. Cambia la implementaci\u00f3n del controlador: import org.springframework.stereotype.Controller import org.example.primerspringmvc.repository.ComarcaRepository import org.springframework.ui.Model import org.springframework.web.bind.annotation.* @Controller @RequestMapping(\"/comarcas\") class ComarcaController(private val ComarcaRepository: ComarcaRepository) { @GetMapping fun listarComarcas(model:Model): String { val comarcas = ComarcaRepository.findAll() model.addAttribute(\"comarcas\", comarcas) return \"comarcas\" // Nombre de la plantilla HTML } } 4) Vistas Para agregar un entorno de usuario amigable con cajas de texto y que los datos de la base de datos se muestren en una aplicaci\u00f3n web, crea un archivo comarcas.html en el directorio src/main/resources/templates . <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Lista de Comarcas</title> </head> <body> <h1>Lista de Comarcas</h1> <table border=\"1\"> <tr> <th>ID</th> <th>Provincia</th> </tr> <tr th:each=\"comarca : ${comarcas}\"> <td th:text=\"${comarca.nom_c}\">ID</td> <td th:text=\"${comarca.provincia}\">Provincia</td> </tr> </table> </body> </html> th:each : Itera sobre la lista de comarcas. th:text : Inserta din\u00e1micamente el valor de un campo en el HTML. Ejecuatar la aplicaci\u00f3n Accede a http://localhost:8888/comarcas para listar las comarcas. En el navegador, se mostrar\u00e1 una tabla HTML con las comrcas almacenadas en la base de datos. Los datos din\u00e1micos se renderizan usando Thymeleaf . Este enfoque permite crear interfaces web amigables y bien estructuradas. Ejemplo de consulta a la Base de datos Con la anotaci\u00f3n @Query en el repositorio, podemos realizar consultas personalizadas a la base de datos. A continuaci\u00f3n veremos los cambios que deber\u00edamos hacer en los ficheros para poder hacer una consulta con par\u00e1metros y visualizar los datos tanto en json com con thymeleaf: Cambios en los ficheros .kt: ComarcaRepository import org.springframework.data.jpa.repository.Query import org.springframework.data.repository.query.Param import org.example.primerspringmvc.model.comarca import org.springframework.data.jpa.repository.JpaRepository import org.springframework.stereotype.Repository @Repository interface ComarcaRepository : JpaRepository<comarca, Long> { @Query(\"SELECT c FROM comarca c WHERE c.provincia = :provincia\") fun findComarcasporProvincia(@Param(\"provincia\") provincia: String): List<comarca> } ComarcaController import org.example.primerspringmvc.model.comarca import org.springframework.stereotype.Controller import org.example.primerspringmvc.repository.ComarcaRepository import org.springframework.ui.Model import org.springframework.web.bind.annotation.* @RestController //en lugar de @Controller @RequestMapping(\"/comarcas\") class ComarcaController(private val ComarcaRepository: ComarcaRepository) { @GetMapping(\"/buscar\") fun buscarComarcasPorProvincia(@RequestParam provincia: String): List<comarca> { return ComarcaRepository.findComarcasporProvincia(provincia) } } Anotaciones importantes @Query : Permite definir consultas SQL personalizadas directamente en el repositorio. La consulta SELECT c FROM Comarca c WHERE c.provincia = :provincia selecciona todas las comarcas donde la columna provincia coincide con el par\u00e1metro provincia. @Param : Vincula el par\u00e1metro de la consulta con el valor que se pasa desde el m\u00e9todo. En este caso, @Param(\"provincia\") conecta el par\u00e1metro provincia de la consulta SQL con el argumento del m\u00e9todo. @GetMapping y @RequestParam : Define un endpoint HTTP GET en el controlador. El par\u00e1metro provincia se obtiene de la URL. Por ejemplo, si queremos listar las comarcas de la provincia de Alacant, obtenemos: Visualizar la salida con Thymeleaf Si la visualizaci\u00f3n la queremos hacer con Thymeleaf los cambios a realizar se har\u00edan solo en ComarcasController , ya que el formulaio comarcas.html se puede seguir utilizando si queremos mostrar los mismos campos: import org.springframework.stereotype.Controller import org.example.primerspringmvc.repository.ComarcaRepository import org.springframework.ui.Model import org.springframework.web.bind.annotation.* @Controller //en lugar de @RestController @RequestMapping(\"/comarcas\") class ComarcaController(private val ComarcaRepository: ComarcaRepository) { @GetMapping fun listarComarcas(model:Model): String { val comarcas = ComarcaRepository.findAll() model.addAttribute(\"comarcas\", comarcas) return \"comarcas\" // Nombre de la plantilla HTML } @GetMapping(\"/buscar\") fun buscarComarcasPorProvincia(@RequestParam provincia: String, model: Model): String { val comarcas= ComarcaRepository.findComarcasporProvincia(provincia) model.addAttribute(\"comarcas\", comarcas) return \"comarcas\" // Nombre de la plantilla HTML } } Y el resultado se ver\u00eda as\u00ed:","title":"Ejemplo con acceso a Bases de Datos Postgres."},{"location":"SpringMVC/#base-de-datos-en-contenedor-docker","text":"Para no tener que instalarnos un servidor Postgres en nuestro equipo, podemos tener nuestra base de datos en un contenedor Docker. En este caso, los cambios principales se centran en la configuraci\u00f3n de conexi\u00f3n en la aplicaci\u00f3n y en el despliegue del contenedor de PostgreSQL. Antes de acceder al contenedor tenemos que crearlo. En nuestro caso crearemos un contenedor Docker de Postgres y posteriormente restauraremos la base de datos geo_ad en dicho contenedor, para poder disponer de la misma configuracion y los mismos datos que en el servidor externo. Partimos del hecho que tenemos instalado Docker en nuesto equipo, en caso contario te dejo un peque\u00f1o tutorial de como instalarlo en el apartado Docker de esta unidad. Los pasos a seguir para crear dicho contendor son: 1) Ejecutar PostgreSQL en Docker Crea y ejecuta el contenedor de PostgreSQL: docker run --name postgres-container -e POSTGRES_USER=admin -e POSTGRES_PASSWORD=admin -e POSTGRES_DB=demo -p 5432:5432 -d postgres POSTGRES_USER: Usuario de la base de datos. POSTGRES_PASSWORD: Contrase\u00f1a del usuario. POSTGRES_DB: Nombre de la base de datos. -p 5432:5432: Mapea el puerto 5432 del contenedor al puerto 5432 de tu m\u00e1quina. Verifica que el contenedor est\u00e9 corriendo: docker ps (Opcional) Con\u00e9ctate al contenedor para verificar la base de datos, desde DBeaver , o desde el terminal: docker exec -it postgres-container psql -U admin -d demo 1) Restaurar la base de datos en el contenedor con DBeaver : Vamos a restaurar la base de datos geo_ad en la base de datos demo , que hemos creado con docker. Para ello os he dejado un archivo dump , en el apartado recursos de Aules , que contiene el backup de geo_ad. Lo siguiente ser\u00e1 restaurar este backup en demo , siguiendo esto pasos: Crear una nueva conexi\u00f3n en DBeaver al contenedor local: Host: localhost Puerto: 5432 Usuario y contrase\u00f1a: admin Base de datos: demo Restaurar el archivo de respaldo: Haz clic derecho en la base de datos en el contenedor \u2192 Herramientas > Restaurar (Restore). Archivo de respaldo : Selecciona el archivo de respaldo exportado, disponible en el aula virtual en la carpeta de recursos del tema. Pulsa Start y espera a que termine la restauraci\u00f3n. Una vez terminado selecciona cancelar para que no vuelva a realizar la restauraci\u00f3n. 3) Cambios en la Configuraci\u00f3n de la Aplicaci\u00f3n En el archivo application.properties , configura la conexi\u00f3n a PostgreSQL en el contenedor Docker. Aseg\u00farate de usar la IP del contenedor o localhost si est\u00e1s ejecutando la aplicaci\u00f3n desde la misma m\u00e1quina. Opci\u00f3n 1: Usar localhost (si el contenedor est\u00e1 corriendo en tu m\u00e1quina) spring.datasource.url=jdbc:postgresql://localhost:5432/demo spring.datasource.username=admin spring.datasource.password=admin spring.jpa.hibernate.ddl-auto=none spring.jpa.show-sql=true spring.jpa.properties.hibernate.format_sql=true Opci\u00f3n 2: Utilizar la IP del contenedor (si la aplicaci\u00f3n est\u00e1 en otro contenedor) Para encontrar la IP del contenedor PostgreSQL: docker inspect postgres-container | grep IPAddress Utiliza la IP encontrada para configurar la conexi\u00f3n: spring.datasource.url=jdbc:postgresql://<IP_DEL_CONTENEDOR>:5432/demo spring.datasource.username=admin spring.datasource.password=admin spring.jpa.hibernate.ddl-auto=none spring.jpa.show-sql=true spring.jpa.properties.hibernate.format_sql=true Todos los cambios que necesitas para ejecutar la aplicaci\u00f3n y que acceda a la base de datos que se encuentra en el contenedor son los anteriormente descritos. El resto de ficheros y estructura no se ver\u00e1 afectada. Una vez tenemos la base de datos restaurada con los datos de geo_ad ya podemos ejecutar la aplicaci\u00f3n y comprobar que los resultados son los mismos que si accedemos a la base de datos del servidor.","title":"Base de datos en contenedor Docker"},{"location":"SpringMVC/#operaciones-crud-sobre-base-de-datos-en-contenedor-docker","text":"Siguiendo con el ejemplo visto en Spring MVC, de acceder a una base de datos relacional Postgres en un contenedor Docker, en este apartado iremos m\u00e1s all\u00e1 y veremos como realizar operaciones CRUD, ya que ahora la base de datos est\u00e1 en local y podemos hacer todas las modificaciones que necesitemos. Como ejemplo, haremos modificaciones sobre la tabla comarcas . El \u00fanico fichero a modificar ser\u00e1 el controlador (ComarcaController.kt) y la creaci\u00f3n de nuevas vistas para visualizar los resultados: 1) Create Controlador @Controller @RequestMapping(\"/comarcas\") class ComarcaController(private val comarcaRepository: ComarcaRepository) { @GetMapping(\"/nueva\") fun mostrarFormularioNuevaComarca(model: Model): String { model.addAttribute(\"comarca\", comarca()) return \"nueva-comarca\" } @PostMapping(\"/nueva\") fun guardarComarca(@ModelAttribute comarca: comarca): String { comarcaRepository.save(comarca) return \"redirect:/comarcas\" } } Vista (nueva-comarca.html) <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Nueva Comarca</title> </head> <body> <h1>Nueva Comarca</h1> <form th:action=\"@{/comarcas/nueva}\" th:object=\"${comarca}\" method=\"post\"> <label for=\"nom_c\">Nombre:</label> <input type=\"text\" id=\"nom_c\" name=\"nom_c\" th:value=\"*{nom_c}\" required><br> <label for=\"provincia\">Provincia:</label> <input type=\"text\" id=\"provincia\" name=\"provincia\" th:value=\"*{provincia}\" required><br> <button type=\"submit\">Guardar</button> </form> </body> </html> 2) Read Controlador : Ya implementado en el ejercicio anterior. @GetMapping fun listarComarcas(model: Model): String { val comarcas = comarcaRepository.findAll() model.addAttribute(\"comarcas\", comarcas) return \"comarcas\" } Vista (comarcas.html) : Ya creada en el ejercicio anterior. 3) Update Controlador @GetMapping(\"/editar/{id}\") fun mostrarFormularioEditarComarca(@PathVariable id: String, model: Model): String { val comarca = comarcaRepository.findById(id).orElseThrow { IllegalArgumentException(\"Comarca no encontrada: $id\") } model.addAttribute(\"comarca\", comarca) return \"editar-comarca\" } @PostMapping(\"/editar/{id}\") fun actualizarComarca(@PathVariable id: String, @ModelAttribute comarca: comarca): String { if (!comarcaRepository.existsById(id)) { throw IllegalArgumentException(\"Comarca no encontrada: $id\") } comarcaRepository.save(comarca) return \"redirect:/comarcas\" } Vista (editar-comarca.html) <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Editar Comarca</title> </head> <body> <h1>Editar Comarca</h1> <form th:action=\"@{/comarcas/editar/{id}(id=${comarca.nom_c})}\" th:object=\"${comarca}\" method=\"post\"> <label for=\"nom_c\">Nombre:</label> <input type=\"text\" id=\"nom_c\" name=\"nom_c\" th:value=\"*{nom_c}\" readonly><br> <label for=\"provincia\">Provincia:</label> <input type=\"text\" id=\"provincia\" name=\"provincia\" th:value=\"*{provincia}\" required><br> <button type=\"submit\">Actualizar</button> </form> </body> </html> 4) Delete Controlador @GetMapping(\"/eliminar/{id}\") fun eliminarComarca(@PathVariable id: String): String { if (!comarcaRepository.existsById(id)) { throw IllegalArgumentException(\"Comarca no encontrada: $id\") } comarcaRepository.deleteById(id) return \"redirect:/comarcas\" } Vista (Modificar comarcas.html para agregar la opci\u00f3n de eliminar) <tr th:each=\"comarca : ${comarcas}\"> <td th:text=\"${comarca.nom_c}\">ID</td> <td th:text=\"${comarca.provincia}\">Provincia</td> <td> <a th:href=\"@{/comarcas/editar/{id}(id=${comarca.nom_c})}\">Editar</a> <a th:href=\"@{/comarcas/eliminar/{id}(id=${comarca.nom_c})}\" onclick=\"return confirm('\u00bfEst\u00e1s seguro?')\">Eliminar</a> </td> </tr>","title":"Operaciones CRUD sobre base de datos en contenedor Docker"},{"location":"SpringMongo/","text":"Spring MongoDb Spring MongoDb Es un m\u00f3dulo de Spring Data que facilita la integraci\u00f3n de aplicaciones Spring con MongoDB. Adem\u00e1s proporciona una abstracci\u00f3n sobre las operaciones b\u00e1sicas de MongoDB como CRUD, consultas personalizadas, y soporte para agregaciones. Requisitos Tener MongoDB instalado o utilizar una instancia en la nube o en un contenedor Docker. Spring Boot configurado con Maven (en nuestro caso) o Gradle. Dependencias Maven <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-data-mongodb</artifactId> </dependency> application.properties spring.data.mongodb.host=localhost spring.data.mongodb.port=27017 spring.data.mongodb.database=nombre_base_de_datos Si est\u00e1s usando MongoDB con autenticaci\u00f3n, a\u00f1ade: spring.data.mongodb.username=usuario spring.data.mongodb.password=contrase\u00f1a Ejemplo: Men\u00fas En este ejemplo partiremos de un archivo json con 10 men\u00fas y sus correspondientes platos. Has de a\u00f1adir este documento como una colecci\u00f3n a tu BD Mongo. Archivo json con los menus: [ { \"_id\": \"1\", \"nombre\": \"Men\u00fa Mediterr\u00e1neo\", \"descripcion\": \"Un men\u00fa saludable inspirado en la dieta mediterr\u00e1nea.\", \"fecha\": \"2025-01-08\", \"platos\": [ { \"nombre\": \"Ensalada Griega\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Lechuga\", \"Tomate\", \"Pepino\", \"Aceitunas\", \"Queso Feta\"], \"precio\": 5.5 }, { \"nombre\": \"Moussaka\", \"categoria\": \"Principal\", \"ingredientes\": [\"Berenjena\", \"Carne de Cordero\", \"Tomate\", \"Bechamel\", \"Queso\"], \"precio\": 12.0 } ], \"precioTotal\": 17.5 }, { \"_id\": \"2\", \"nombre\": \"Men\u00fa Asi\u00e1tico\", \"descripcion\": \"Sabores frescos y aut\u00e9nticos de Asia.\", \"fecha\": \"2025-01-09\", \"platos\": [ { \"nombre\": \"Rollitos de Primavera\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Zanahoria\", \"Col\", \"Brotes de Soja\", \"Fideos de Arroz\"], \"precio\": 4.0 }, { \"nombre\": \"Pad Thai\", \"categoria\": \"Principal\", \"ingredientes\": [\"Fideos de Arroz\", \"Camarones\", \"Tofu\", \"Man\u00ed\"], \"precio\": 10.0 } ], \"precioTotal\": 14.0 }, { \"_id\": \"3\", \"nombre\": \"Men\u00fa Vegetariano\", \"descripcion\": \"Opciones deliciosas sin carne.\", \"fecha\": \"2025-01-10\", \"platos\": [ { \"nombre\": \"Hummus con Pan de Pita\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Garbanzos\", \"Tahini\", \"Lim\u00f3n\", \"Ajo\"], \"precio\": 4.5 }, { \"nombre\": \"Lasa\u00f1a Vegetariana\", \"categoria\": \"Principal\", \"ingredientes\": [\"Pasta\", \"Espinacas\", \"Ricotta\", \"Tomate\"], \"precio\": 9.0 } ], \"precioTotal\": 13.5 }, { \"_id\": \"4\", \"nombre\": \"Men\u00fa Italiano\", \"descripcion\": \"Especialidades cl\u00e1sicas de Italia.\", \"fecha\": \"2025-01-11\", \"platos\": [ { \"nombre\": \"Bruschetta\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Pan\", \"Tomate\", \"Albahaca\", \"Aceite de Oliva\"], \"precio\": 5.0 }, { \"nombre\": \"Pizza Margarita\", \"categoria\": \"Principal\", \"ingredientes\": [\"Masa de Pizza\", \"Tomate\", \"Mozzarella\", \"Albahaca\"], \"precio\": 10.0 } ], \"precioTotal\": 15.0 }, { \"_id\": \"5\", \"nombre\": \"Men\u00fa Mexicano\", \"descripcion\": \"Platos picantes y llenos de sabor.\", \"fecha\": \"2025-01-12\", \"platos\": [ { \"nombre\": \"Guacamole con Totopos\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Aguacate\", \"Lim\u00f3n\", \"Cilantro\", \"Totopos\"], \"precio\": 4.5 }, { \"nombre\": \"Tacos al Pastor\", \"categoria\": \"Principal\", \"ingredientes\": [\"Tortilla\", \"Carne de Cerdo\", \"Pi\u00f1a\", \"Cebolla\"], \"precio\": 9.0 } ], \"precioTotal\": 13.5 }, { \"_id\": \"6\", \"nombre\": \"Men\u00fa Americano\", \"descripcion\": \"Comida cl\u00e1sica de los Estados Unidos.\", \"fecha\": \"2025-01-13\", \"platos\": [ { \"nombre\": \"Alitas de Pollo\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Pollo\", \"Salsa BBQ\", \"Especias\"], \"precio\": 6.0 }, { \"nombre\": \"Hamburguesa con Queso\", \"categoria\": \"Principal\", \"ingredientes\": [\"Pan\", \"Carne de Res\", \"Queso\", \"Lechuga\"], \"precio\": 10.0 } ], \"precioTotal\": 16.0 }, { \"_id\": \"7\", \"nombre\": \"Men\u00fa de Mariscos\", \"descripcion\": \"Frescos sabores del oc\u00e9ano.\", \"fecha\": \"2025-01-14\", \"platos\": [ { \"nombre\": \"C\u00f3ctel de Camarones\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Camarones\", \"Salsa C\u00f3ctel\", \"Lim\u00f3n\"], \"precio\": 7.0 }, { \"nombre\": \"Paella de Mariscos\", \"categoria\": \"Principal\", \"ingredientes\": [\"Arroz\", \"Camarones\", \"Mejillones\", \"Calamares\"], \"precio\": 12.0 } ], \"precioTotal\": 19.0 }, { \"_id\": \"8\", \"nombre\": \"Men\u00fa Franc\u00e9s\", \"descripcion\": \"Platos refinados y elegantes.\", \"fecha\": \"2025-01-15\", \"platos\": [ { \"nombre\": \"Quiche Lorraine\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Huevo\", \"Nata\", \"Tocino\", \"Queso Gruy\u00e8re\"], \"precio\": 6.5 }, { \"nombre\": \"Ratatouille\", \"categoria\": \"Principal\", \"ingredientes\": [\"Berenjena\", \"Calabac\u00edn\", \"Tomate\", \"Pimiento\"], \"precio\": 9.5 } ], \"precioTotal\": 16.0 }, { \"_id\": \"9\", \"nombre\": \"Men\u00fa Indio\", \"descripcion\": \"Sabores especiados y ex\u00f3ticos.\", \"fecha\": \"2025-01-16\", \"platos\": [ { \"nombre\": \"Samosas\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Papas\", \"Especias\", \"Masa Frita\"], \"precio\": 4.0 }, { \"nombre\": \"Pollo Tikka Masala\", \"categoria\": \"Principal\", \"ingredientes\": [\"Pollo\", \"Salsa de Tomate\", \"Especias\", \"Crema\"], \"precio\": 11.0 } ], \"precioTotal\": 15.0 }, { \"_id\": \"10\", \"nombre\": \"Men\u00fa Japon\u00e9s\", \"descripcion\": \"Delicados sabores de Jap\u00f3n.\", \"fecha\": \"2025-01-17\", \"platos\": [ { \"nombre\": \"Sopa de Miso\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Miso\", \"Tofu\", \"Alga Wakame\"], \"precio\": 3.5 }, { \"nombre\": \"Sushi Variado\", \"categoria\": \"Principal\", \"ingredientes\": [\"Arroz\", \"Pescado\", \"Alga Nori\", \"Vegetales\"], \"precio\": 12.5 } ], \"precioTotal\": 16.0 } ] Modelo MVC Modelo Los modelos son las clases que representan las colecciones en MongoDB. Deben incluir la anotaci\u00f3n @Document . Menu.kt import org.springframework.data.annotation.Id import org.springframework.data.mongodb.core.mapping.Document @Document(collection = \"menus\") // Nombre de la colecci\u00f3n en MongoDB data class Menu( @Id val id: String, // Identificador \u00fanico del men\u00fa val nombre: String, // Nombre del men\u00fa val descripcion: String, // Descripci\u00f3n del men\u00fa val fecha: String, // Fecha asociada al men\u00fa val platos: List<Plato> = emptyList(), // Lista de platos val precioTotal: Double = 0.0 // Precio total del men\u00fa ) data class Plato( val nombre: String, val categoria: String, val ingredientes: List<String> = emptyList(), val precio: Double = 0.0 ) Repositorios proporciona una interfaz MongoRepository que simplifica las operaciones CRUD. MenuRepository.kt import org.springframework.data.mongodb.repository.MongoRepository import org.springframework.stereotype.Repository import org.example.primerspringmongo.model.* @Repository interface MenuRepository : MongoRepository<Menu, String> { fun findByNombre(nombre: String): List<Menu> fun findByPlatosCategoria(categoria: String): List<Menu> } Controlador MenuController.kt import org.example.primerspringmongo.model.Menu import org.example.primerspringmongo.repository.MenuRepository import org.springframework.stereotype.Controller import org.springframework.ui.Model import org.springframework.web.bind.annotation.* @Controller @RequestMapping(\"/menus\") class MenuController(private val menuRepository: MenuRepository) { // Listar todos los men\u00fas @GetMapping fun listarMenus(model: Model): String { val menus = menuRepository.findAll() model.addAttribute(\"menus\", menus) return \"menus/listar\" } @GetMapping(\"/buscar\") fun buscarPorNombre(@RequestParam nombre: String, model: Model): String { val menus = menuRepository.findByNombre(nombre) // Consulta en el repositorio model.addAttribute(\"menus\", menus) // Pasar los men\u00fas al modelo model.addAttribute(\"nombre\", nombre) // Pasar el nombre buscado return \"menus/listar\" // Nombre de la plantilla Thymeleaf } // Guardar un nuevo men\u00fa @PostMapping(\"/guardar\") fun guardarMenu(@ModelAttribute menu: Menu): String { menuRepository.save(menu) return \"redirect:/menus\" } // Ver detalles de un men\u00fa @GetMapping(\"/{id}\") fun verDetalles(@PathVariable id: String, model: Model): String { val menu = menuRepository.findById(id) if (menu.isPresent) { model.addAttribute(\"menu\", menu.get()) return \"menus/detalles\" } return \"redirect:/menus\" } // Mostrar formulario para editar un men\u00fa @GetMapping(\"/editar/{id}\") fun mostrarFormularioEditar(@PathVariable id: String, model: Model): String { val menu = menuRepository.findById(id) if (menu.isPresent) { model.addAttribute(\"menu\", menu.get()) return \"menus/editar\" } return \"redirect:/menus\" } // Actualizar un men\u00fa existente @PostMapping(\"/actualizar/{id}\") fun actualizarMenu(@PathVariable id: String, @ModelAttribute menu: Menu): String { if (menuRepository.existsById(id)) { menuRepository.save(menu) } return \"redirect:/menus\" } // Eliminar un men\u00fa @GetMapping(\"/eliminar/{id}\") fun eliminarMenu(@PathVariable id: String): String { menuRepository.deleteById(id) return \"redirect:/menus\" } } PlatoController.kt import org.example.primerspringmongo.repository.MenuRepository import org.springframework.stereotype.Controller import org.springframework.ui.Model import org.springframework.web.bind.annotation.* @Controller @RequestMapping(\"/platos\") class PlatoController(private val menuRepository: MenuRepository) { // Listar todos los platos de un men\u00fa @GetMapping(\"/{menuId}\") fun listarPlatos(@PathVariable menuId: String, model: Model): String { val menu = menuRepository.findById(menuId) if (menu.isPresent) { model.addAttribute(\"menu\", menu.get()) model.addAttribute(\"platos\", menu.get().platos) return \"platos/listar\" } return \"redirect:/menus\" } @GetMapping(\"/categoria\") fun buscarPorCategoria(@RequestParam categoria: String, model: Model): String { val menus = menuRepository.findByPlatosCategoria(categoria) // Consulta en el repositorio model.addAttribute(\"menus\", menus) // Lista de men\u00fas encontrados model.addAttribute(\"categoriaBuscada\", categoria) // Categor\u00eda buscada return \"platos/buscarPorCategoria\" // Plantilla Thymeleaf } @GetMapping(\"/{menuId}/ingredientes/{platoNombre}\") fun verIngredientes( @PathVariable menuId: String, @PathVariable platoNombre: String, model: Model ): String { val menu = menuRepository.findById(menuId) if (menu.isPresent) { val plato = menu.get().platos.find { it.nombre == platoNombre } if (plato != null) { println(\"Plato encontrado: $plato\") println(\"Ingredientes: ${plato.ingredientes}\") model.addAttribute(\"menu\", menu.get()) model.addAttribute(\"plato\", plato) model.addAttribute(\"ingredientes\", plato.ingredientes ?: emptyList<String>()) return \"platos/ingredientes\" } } model.addAttribute(\"error\", \"El plato o el men\u00fa no existen.\") return \"error\" } } Vista templates/menus/ listar.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Lista de Men\u00fas</title> </head> <body> <h1>Lista de Men\u00fas</h1> <a href=\"/menus/crear\">Crear Nuevo Men\u00fa</a> <table border=\"1\"> <thead> <tr> <th>Nombre</th> <th>Descripci\u00f3n</th> <th>Acciones</th> </tr> </thead> <tbody> <tr th:each=\"menu : ${menus}\"> <td th:text=\"${menu.nombre}\"></td> <td th:text=\"${menu.descripcion}\"></td> <td> <a th:href=\"@{'/menus/' + ${menu.id}}\">Detalles</a> <a th:href=\"@{'/menus/editar/' + ${menu.id}}\">Editar</a> <a th:href=\"@{'/menus/eliminar/' + ${menu.id}}\" onclick=\"return confirm('\u00bfSeguro que quieres eliminar este men\u00fa?')\">Eliminar</a> </td> </tr> </tbody> </table> </body> </html> crear.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Crear/Editar Men\u00fa</title> </head> <body> <h1 th:text=\"${#strings.equals(menu.id, '') ? 'Crear Nuevo Men\u00fa' : 'Editar Men\u00fa'}\"></h1> <form th:action=\"@{${#strings.equals(menu.id, '') ? '/menus/guardar' : '/menus/actualizar/' + menu.id}}\" th:object=\"${menu}\" method=\"post\"> <label for=\"nombre\">Nombre:</label> <input type=\"text\" id=\"nombre\" name=\"nombre\" th:value=\"${menu.nombre}\" required><br> <label for=\"descripcion\">Descripci\u00f3n:</label> <textarea id=\"descripcion\" name=\"descripcion\" th:text=\"${menu.descripcion}\" required></textarea><br> <label for=\"fecha\">Fecha:</label> <input type=\"date\" id=\"fecha\" name=\"fecha\" th:value=\"${menu.fecha}\" required><br> <label for=\"precioTotal\">Precio Total:</label> <input type=\"number\" id=\"precioTotal\" name=\"precioTotal\" th:value=\"${menu.precioTotal}\" step=\"0.01\" required><br> <button type=\"submit\">Guardar</button> <a href=\"/menus\">Cancelar</a> </form> </body> </html> detalles.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Detalles del Men\u00fa</title> </head> <body> <h1>Detalles del Men\u00fa</h1> <p><strong>Nombre:</strong> <span th:text=\"${menu.nombre}\"></span></p> <p><strong>Descripci\u00f3n:</strong> <span th:text=\"${menu.descripcion}\"></span></p> <p><strong>Fecha:</strong> <span th:text=\"${menu.fecha}\"></span></p> <p><strong>Precio Total:</strong> <span th:text=\"${menu.precioTotal}\"></span></p> <h2>Platos</h2> <ul> <li th:each=\"plato : ${menu.platos}\"> <strong th:text=\"${plato.nombre}\"></strong> - <span th:text=\"${plato.categoria}\"></span> (<span th:text=\"${plato.precio}\"></span> \u20ac) </li> </ul> <a href=\"/menus\">Volver</a> </body> </html> editar.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Crear/Editar Men\u00fa</title> </head> <body> <h1 th:text=\"${#strings.equals(menu.id, '') ? 'Crear Nuevo Men\u00fa' : 'Editar Men\u00fa'}\"></h1> <form th:action=\"@{${#strings.equals(menu.id, '') ? '/menus/guardar' : '/menus/actualizar/' + menu.id}}\" th:object=\"${menu}\" method=\"post\"> <label for=\"nombre\">Nombre:</label> <input type=\"text\" id=\"nombre\" name=\"nombre\" th:value=\"${menu.nombre}\" required><br> <label for=\"descripcion\">Descripci\u00f3n:</label> <textarea id=\"descripcion\" name=\"descripcion\" th:text=\"${menu.descripcion}\" required></textarea><br> <label for=\"fecha\">Fecha:</label> <input type=\"date\" id=\"fecha\" name=\"fecha\" th:value=\"${menu.fecha}\" required><br> <label for=\"precioTotal\">Precio Total:</label> <input type=\"number\" id=\"precioTotal\" name=\"precioTotal\" th:value=\"${menu.precioTotal}\" step=\"0.01\" required><br> <button type=\"submit\">Guardar</button> <a href=\"/menus\">Cancelar</a> </form> </body> </html> templates/platos/ listar.kt <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Platos del Men\u00fa</title> </head> <body> <h1 th:text=\"'Platos del Men\u00fa: ' + ${menu.nombre}\"></h1> <a th:href=\"@{/menus}\">Volver a Men\u00fas</a> <table border=\"1\"> <thead> <tr> <th>Nombre</th> <th>Categor\u00eda</th> <th>Precio</th> <th>Ingredientes</th> </tr> </thead> <tbody> <tr th:each=\"plato : ${platos}\"> <td th:text=\"${plato.nombre}\"></td> <td th:text=\"${plato.categoria}\"></td> <td th:text=\"${plato.precio} + ' \u20ac'\"></td> <td> <a th:href=\"@{'/platos/' + ${menu.id} + '/ingredientes/' + ${plato.nombre}}\">Ver Ingredientes</a> </td> </tr> </tbody> </table> </body> </html> ingredientes.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Ingredientes</title> </head> <body> <h1 th:text=\"'Ingredientes del plato: ' + ${plato?.nombre}\"></h1> <div th:if=\"${error}\"> <p th:text=\"${error}\" style=\"color: red;\"></p> </div> <ul th:if=\"${ingredientes != null && !ingredientes.isEmpty()}\"> <li th:each=\"ingrediente : ${ingredientes}\" th:text=\"${ingrediente}\"></li> </ul> <p th:if=\"${ingredientes == null || ingredientes.isEmpty()}\" style=\"color: gray;\"> No hay ingredientes disponibles para este plato. </p> <a th:href=\"@{'/platos/' + ${menu.id}}\">Volver a los platos</a> </body> </html> buscarPorCategoria.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Buscar Men\u00fas por Categor\u00eda</title> </head> <body> <h1>Resultados para categor\u00eda: <span th:text=\"${categoriaBuscada}\"></span></h1> <table border=\"1\" th:if=\"${menus}\"> <thead> <tr> <th>ID</th> <th>Nombre</th> <th>Descripci\u00f3n</th> <th>Platos</th> </tr> </thead> <tbody> <tr th:each=\"menu : ${menus}\"> <td th:text=\"${menu.id}\"></td> <td th:text=\"${menu.nombre}\"></td> <td th:text=\"${menu.descripcion}\"></td> <td> <ul> <li th:each=\"plato : ${menu.platos}\" th:if=\"${plato.categoria == categoriaBuscada}\" th:text=\"${plato.nombre}\"></li> </ul> </td> </tr> </tbody> </table> <p th:if=\"${menus == null || menus.isEmpty()}\" style=\"color: gray;\"> No se encontraron men\u00fas con platos de la categor\u00eda <span th:text=\"${categoriaBuscada}\"></span>. </p> <a href=\"/menus\">Volver a la lista de men\u00fas</a> </body> </html>","title":"Spring MongoDb"},{"location":"SpringMongo/#spring-mongodb","text":"Spring MongoDb Es un m\u00f3dulo de Spring Data que facilita la integraci\u00f3n de aplicaciones Spring con MongoDB. Adem\u00e1s proporciona una abstracci\u00f3n sobre las operaciones b\u00e1sicas de MongoDB como CRUD, consultas personalizadas, y soporte para agregaciones. Requisitos Tener MongoDB instalado o utilizar una instancia en la nube o en un contenedor Docker. Spring Boot configurado con Maven (en nuestro caso) o Gradle. Dependencias Maven <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-data-mongodb</artifactId> </dependency> application.properties spring.data.mongodb.host=localhost spring.data.mongodb.port=27017 spring.data.mongodb.database=nombre_base_de_datos Si est\u00e1s usando MongoDB con autenticaci\u00f3n, a\u00f1ade: spring.data.mongodb.username=usuario spring.data.mongodb.password=contrase\u00f1a","title":"Spring MongoDb"},{"location":"SpringMongo/#ejemplo-menus","text":"En este ejemplo partiremos de un archivo json con 10 men\u00fas y sus correspondientes platos. Has de a\u00f1adir este documento como una colecci\u00f3n a tu BD Mongo. Archivo json con los menus: [ { \"_id\": \"1\", \"nombre\": \"Men\u00fa Mediterr\u00e1neo\", \"descripcion\": \"Un men\u00fa saludable inspirado en la dieta mediterr\u00e1nea.\", \"fecha\": \"2025-01-08\", \"platos\": [ { \"nombre\": \"Ensalada Griega\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Lechuga\", \"Tomate\", \"Pepino\", \"Aceitunas\", \"Queso Feta\"], \"precio\": 5.5 }, { \"nombre\": \"Moussaka\", \"categoria\": \"Principal\", \"ingredientes\": [\"Berenjena\", \"Carne de Cordero\", \"Tomate\", \"Bechamel\", \"Queso\"], \"precio\": 12.0 } ], \"precioTotal\": 17.5 }, { \"_id\": \"2\", \"nombre\": \"Men\u00fa Asi\u00e1tico\", \"descripcion\": \"Sabores frescos y aut\u00e9nticos de Asia.\", \"fecha\": \"2025-01-09\", \"platos\": [ { \"nombre\": \"Rollitos de Primavera\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Zanahoria\", \"Col\", \"Brotes de Soja\", \"Fideos de Arroz\"], \"precio\": 4.0 }, { \"nombre\": \"Pad Thai\", \"categoria\": \"Principal\", \"ingredientes\": [\"Fideos de Arroz\", \"Camarones\", \"Tofu\", \"Man\u00ed\"], \"precio\": 10.0 } ], \"precioTotal\": 14.0 }, { \"_id\": \"3\", \"nombre\": \"Men\u00fa Vegetariano\", \"descripcion\": \"Opciones deliciosas sin carne.\", \"fecha\": \"2025-01-10\", \"platos\": [ { \"nombre\": \"Hummus con Pan de Pita\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Garbanzos\", \"Tahini\", \"Lim\u00f3n\", \"Ajo\"], \"precio\": 4.5 }, { \"nombre\": \"Lasa\u00f1a Vegetariana\", \"categoria\": \"Principal\", \"ingredientes\": [\"Pasta\", \"Espinacas\", \"Ricotta\", \"Tomate\"], \"precio\": 9.0 } ], \"precioTotal\": 13.5 }, { \"_id\": \"4\", \"nombre\": \"Men\u00fa Italiano\", \"descripcion\": \"Especialidades cl\u00e1sicas de Italia.\", \"fecha\": \"2025-01-11\", \"platos\": [ { \"nombre\": \"Bruschetta\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Pan\", \"Tomate\", \"Albahaca\", \"Aceite de Oliva\"], \"precio\": 5.0 }, { \"nombre\": \"Pizza Margarita\", \"categoria\": \"Principal\", \"ingredientes\": [\"Masa de Pizza\", \"Tomate\", \"Mozzarella\", \"Albahaca\"], \"precio\": 10.0 } ], \"precioTotal\": 15.0 }, { \"_id\": \"5\", \"nombre\": \"Men\u00fa Mexicano\", \"descripcion\": \"Platos picantes y llenos de sabor.\", \"fecha\": \"2025-01-12\", \"platos\": [ { \"nombre\": \"Guacamole con Totopos\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Aguacate\", \"Lim\u00f3n\", \"Cilantro\", \"Totopos\"], \"precio\": 4.5 }, { \"nombre\": \"Tacos al Pastor\", \"categoria\": \"Principal\", \"ingredientes\": [\"Tortilla\", \"Carne de Cerdo\", \"Pi\u00f1a\", \"Cebolla\"], \"precio\": 9.0 } ], \"precioTotal\": 13.5 }, { \"_id\": \"6\", \"nombre\": \"Men\u00fa Americano\", \"descripcion\": \"Comida cl\u00e1sica de los Estados Unidos.\", \"fecha\": \"2025-01-13\", \"platos\": [ { \"nombre\": \"Alitas de Pollo\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Pollo\", \"Salsa BBQ\", \"Especias\"], \"precio\": 6.0 }, { \"nombre\": \"Hamburguesa con Queso\", \"categoria\": \"Principal\", \"ingredientes\": [\"Pan\", \"Carne de Res\", \"Queso\", \"Lechuga\"], \"precio\": 10.0 } ], \"precioTotal\": 16.0 }, { \"_id\": \"7\", \"nombre\": \"Men\u00fa de Mariscos\", \"descripcion\": \"Frescos sabores del oc\u00e9ano.\", \"fecha\": \"2025-01-14\", \"platos\": [ { \"nombre\": \"C\u00f3ctel de Camarones\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Camarones\", \"Salsa C\u00f3ctel\", \"Lim\u00f3n\"], \"precio\": 7.0 }, { \"nombre\": \"Paella de Mariscos\", \"categoria\": \"Principal\", \"ingredientes\": [\"Arroz\", \"Camarones\", \"Mejillones\", \"Calamares\"], \"precio\": 12.0 } ], \"precioTotal\": 19.0 }, { \"_id\": \"8\", \"nombre\": \"Men\u00fa Franc\u00e9s\", \"descripcion\": \"Platos refinados y elegantes.\", \"fecha\": \"2025-01-15\", \"platos\": [ { \"nombre\": \"Quiche Lorraine\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Huevo\", \"Nata\", \"Tocino\", \"Queso Gruy\u00e8re\"], \"precio\": 6.5 }, { \"nombre\": \"Ratatouille\", \"categoria\": \"Principal\", \"ingredientes\": [\"Berenjena\", \"Calabac\u00edn\", \"Tomate\", \"Pimiento\"], \"precio\": 9.5 } ], \"precioTotal\": 16.0 }, { \"_id\": \"9\", \"nombre\": \"Men\u00fa Indio\", \"descripcion\": \"Sabores especiados y ex\u00f3ticos.\", \"fecha\": \"2025-01-16\", \"platos\": [ { \"nombre\": \"Samosas\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Papas\", \"Especias\", \"Masa Frita\"], \"precio\": 4.0 }, { \"nombre\": \"Pollo Tikka Masala\", \"categoria\": \"Principal\", \"ingredientes\": [\"Pollo\", \"Salsa de Tomate\", \"Especias\", \"Crema\"], \"precio\": 11.0 } ], \"precioTotal\": 15.0 }, { \"_id\": \"10\", \"nombre\": \"Men\u00fa Japon\u00e9s\", \"descripcion\": \"Delicados sabores de Jap\u00f3n.\", \"fecha\": \"2025-01-17\", \"platos\": [ { \"nombre\": \"Sopa de Miso\", \"categoria\": \"Entrante\", \"ingredientes\": [\"Miso\", \"Tofu\", \"Alga Wakame\"], \"precio\": 3.5 }, { \"nombre\": \"Sushi Variado\", \"categoria\": \"Principal\", \"ingredientes\": [\"Arroz\", \"Pescado\", \"Alga Nori\", \"Vegetales\"], \"precio\": 12.5 } ], \"precioTotal\": 16.0 } ] Modelo MVC Modelo Los modelos son las clases que representan las colecciones en MongoDB. Deben incluir la anotaci\u00f3n @Document . Menu.kt import org.springframework.data.annotation.Id import org.springframework.data.mongodb.core.mapping.Document @Document(collection = \"menus\") // Nombre de la colecci\u00f3n en MongoDB data class Menu( @Id val id: String, // Identificador \u00fanico del men\u00fa val nombre: String, // Nombre del men\u00fa val descripcion: String, // Descripci\u00f3n del men\u00fa val fecha: String, // Fecha asociada al men\u00fa val platos: List<Plato> = emptyList(), // Lista de platos val precioTotal: Double = 0.0 // Precio total del men\u00fa ) data class Plato( val nombre: String, val categoria: String, val ingredientes: List<String> = emptyList(), val precio: Double = 0.0 ) Repositorios proporciona una interfaz MongoRepository que simplifica las operaciones CRUD. MenuRepository.kt import org.springframework.data.mongodb.repository.MongoRepository import org.springframework.stereotype.Repository import org.example.primerspringmongo.model.* @Repository interface MenuRepository : MongoRepository<Menu, String> { fun findByNombre(nombre: String): List<Menu> fun findByPlatosCategoria(categoria: String): List<Menu> } Controlador MenuController.kt import org.example.primerspringmongo.model.Menu import org.example.primerspringmongo.repository.MenuRepository import org.springframework.stereotype.Controller import org.springframework.ui.Model import org.springframework.web.bind.annotation.* @Controller @RequestMapping(\"/menus\") class MenuController(private val menuRepository: MenuRepository) { // Listar todos los men\u00fas @GetMapping fun listarMenus(model: Model): String { val menus = menuRepository.findAll() model.addAttribute(\"menus\", menus) return \"menus/listar\" } @GetMapping(\"/buscar\") fun buscarPorNombre(@RequestParam nombre: String, model: Model): String { val menus = menuRepository.findByNombre(nombre) // Consulta en el repositorio model.addAttribute(\"menus\", menus) // Pasar los men\u00fas al modelo model.addAttribute(\"nombre\", nombre) // Pasar el nombre buscado return \"menus/listar\" // Nombre de la plantilla Thymeleaf } // Guardar un nuevo men\u00fa @PostMapping(\"/guardar\") fun guardarMenu(@ModelAttribute menu: Menu): String { menuRepository.save(menu) return \"redirect:/menus\" } // Ver detalles de un men\u00fa @GetMapping(\"/{id}\") fun verDetalles(@PathVariable id: String, model: Model): String { val menu = menuRepository.findById(id) if (menu.isPresent) { model.addAttribute(\"menu\", menu.get()) return \"menus/detalles\" } return \"redirect:/menus\" } // Mostrar formulario para editar un men\u00fa @GetMapping(\"/editar/{id}\") fun mostrarFormularioEditar(@PathVariable id: String, model: Model): String { val menu = menuRepository.findById(id) if (menu.isPresent) { model.addAttribute(\"menu\", menu.get()) return \"menus/editar\" } return \"redirect:/menus\" } // Actualizar un men\u00fa existente @PostMapping(\"/actualizar/{id}\") fun actualizarMenu(@PathVariable id: String, @ModelAttribute menu: Menu): String { if (menuRepository.existsById(id)) { menuRepository.save(menu) } return \"redirect:/menus\" } // Eliminar un men\u00fa @GetMapping(\"/eliminar/{id}\") fun eliminarMenu(@PathVariable id: String): String { menuRepository.deleteById(id) return \"redirect:/menus\" } } PlatoController.kt import org.example.primerspringmongo.repository.MenuRepository import org.springframework.stereotype.Controller import org.springframework.ui.Model import org.springframework.web.bind.annotation.* @Controller @RequestMapping(\"/platos\") class PlatoController(private val menuRepository: MenuRepository) { // Listar todos los platos de un men\u00fa @GetMapping(\"/{menuId}\") fun listarPlatos(@PathVariable menuId: String, model: Model): String { val menu = menuRepository.findById(menuId) if (menu.isPresent) { model.addAttribute(\"menu\", menu.get()) model.addAttribute(\"platos\", menu.get().platos) return \"platos/listar\" } return \"redirect:/menus\" } @GetMapping(\"/categoria\") fun buscarPorCategoria(@RequestParam categoria: String, model: Model): String { val menus = menuRepository.findByPlatosCategoria(categoria) // Consulta en el repositorio model.addAttribute(\"menus\", menus) // Lista de men\u00fas encontrados model.addAttribute(\"categoriaBuscada\", categoria) // Categor\u00eda buscada return \"platos/buscarPorCategoria\" // Plantilla Thymeleaf } @GetMapping(\"/{menuId}/ingredientes/{platoNombre}\") fun verIngredientes( @PathVariable menuId: String, @PathVariable platoNombre: String, model: Model ): String { val menu = menuRepository.findById(menuId) if (menu.isPresent) { val plato = menu.get().platos.find { it.nombre == platoNombre } if (plato != null) { println(\"Plato encontrado: $plato\") println(\"Ingredientes: ${plato.ingredientes}\") model.addAttribute(\"menu\", menu.get()) model.addAttribute(\"plato\", plato) model.addAttribute(\"ingredientes\", plato.ingredientes ?: emptyList<String>()) return \"platos/ingredientes\" } } model.addAttribute(\"error\", \"El plato o el men\u00fa no existen.\") return \"error\" } } Vista templates/menus/ listar.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Lista de Men\u00fas</title> </head> <body> <h1>Lista de Men\u00fas</h1> <a href=\"/menus/crear\">Crear Nuevo Men\u00fa</a> <table border=\"1\"> <thead> <tr> <th>Nombre</th> <th>Descripci\u00f3n</th> <th>Acciones</th> </tr> </thead> <tbody> <tr th:each=\"menu : ${menus}\"> <td th:text=\"${menu.nombre}\"></td> <td th:text=\"${menu.descripcion}\"></td> <td> <a th:href=\"@{'/menus/' + ${menu.id}}\">Detalles</a> <a th:href=\"@{'/menus/editar/' + ${menu.id}}\">Editar</a> <a th:href=\"@{'/menus/eliminar/' + ${menu.id}}\" onclick=\"return confirm('\u00bfSeguro que quieres eliminar este men\u00fa?')\">Eliminar</a> </td> </tr> </tbody> </table> </body> </html> crear.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Crear/Editar Men\u00fa</title> </head> <body> <h1 th:text=\"${#strings.equals(menu.id, '') ? 'Crear Nuevo Men\u00fa' : 'Editar Men\u00fa'}\"></h1> <form th:action=\"@{${#strings.equals(menu.id, '') ? '/menus/guardar' : '/menus/actualizar/' + menu.id}}\" th:object=\"${menu}\" method=\"post\"> <label for=\"nombre\">Nombre:</label> <input type=\"text\" id=\"nombre\" name=\"nombre\" th:value=\"${menu.nombre}\" required><br> <label for=\"descripcion\">Descripci\u00f3n:</label> <textarea id=\"descripcion\" name=\"descripcion\" th:text=\"${menu.descripcion}\" required></textarea><br> <label for=\"fecha\">Fecha:</label> <input type=\"date\" id=\"fecha\" name=\"fecha\" th:value=\"${menu.fecha}\" required><br> <label for=\"precioTotal\">Precio Total:</label> <input type=\"number\" id=\"precioTotal\" name=\"precioTotal\" th:value=\"${menu.precioTotal}\" step=\"0.01\" required><br> <button type=\"submit\">Guardar</button> <a href=\"/menus\">Cancelar</a> </form> </body> </html> detalles.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Detalles del Men\u00fa</title> </head> <body> <h1>Detalles del Men\u00fa</h1> <p><strong>Nombre:</strong> <span th:text=\"${menu.nombre}\"></span></p> <p><strong>Descripci\u00f3n:</strong> <span th:text=\"${menu.descripcion}\"></span></p> <p><strong>Fecha:</strong> <span th:text=\"${menu.fecha}\"></span></p> <p><strong>Precio Total:</strong> <span th:text=\"${menu.precioTotal}\"></span></p> <h2>Platos</h2> <ul> <li th:each=\"plato : ${menu.platos}\"> <strong th:text=\"${plato.nombre}\"></strong> - <span th:text=\"${plato.categoria}\"></span> (<span th:text=\"${plato.precio}\"></span> \u20ac) </li> </ul> <a href=\"/menus\">Volver</a> </body> </html> editar.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Crear/Editar Men\u00fa</title> </head> <body> <h1 th:text=\"${#strings.equals(menu.id, '') ? 'Crear Nuevo Men\u00fa' : 'Editar Men\u00fa'}\"></h1> <form th:action=\"@{${#strings.equals(menu.id, '') ? '/menus/guardar' : '/menus/actualizar/' + menu.id}}\" th:object=\"${menu}\" method=\"post\"> <label for=\"nombre\">Nombre:</label> <input type=\"text\" id=\"nombre\" name=\"nombre\" th:value=\"${menu.nombre}\" required><br> <label for=\"descripcion\">Descripci\u00f3n:</label> <textarea id=\"descripcion\" name=\"descripcion\" th:text=\"${menu.descripcion}\" required></textarea><br> <label for=\"fecha\">Fecha:</label> <input type=\"date\" id=\"fecha\" name=\"fecha\" th:value=\"${menu.fecha}\" required><br> <label for=\"precioTotal\">Precio Total:</label> <input type=\"number\" id=\"precioTotal\" name=\"precioTotal\" th:value=\"${menu.precioTotal}\" step=\"0.01\" required><br> <button type=\"submit\">Guardar</button> <a href=\"/menus\">Cancelar</a> </form> </body> </html> templates/platos/ listar.kt <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Platos del Men\u00fa</title> </head> <body> <h1 th:text=\"'Platos del Men\u00fa: ' + ${menu.nombre}\"></h1> <a th:href=\"@{/menus}\">Volver a Men\u00fas</a> <table border=\"1\"> <thead> <tr> <th>Nombre</th> <th>Categor\u00eda</th> <th>Precio</th> <th>Ingredientes</th> </tr> </thead> <tbody> <tr th:each=\"plato : ${platos}\"> <td th:text=\"${plato.nombre}\"></td> <td th:text=\"${plato.categoria}\"></td> <td th:text=\"${plato.precio} + ' \u20ac'\"></td> <td> <a th:href=\"@{'/platos/' + ${menu.id} + '/ingredientes/' + ${plato.nombre}}\">Ver Ingredientes</a> </td> </tr> </tbody> </table> </body> </html> ingredientes.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Ingredientes</title> </head> <body> <h1 th:text=\"'Ingredientes del plato: ' + ${plato?.nombre}\"></h1> <div th:if=\"${error}\"> <p th:text=\"${error}\" style=\"color: red;\"></p> </div> <ul th:if=\"${ingredientes != null && !ingredientes.isEmpty()}\"> <li th:each=\"ingrediente : ${ingredientes}\" th:text=\"${ingrediente}\"></li> </ul> <p th:if=\"${ingredientes == null || ingredientes.isEmpty()}\" style=\"color: gray;\"> No hay ingredientes disponibles para este plato. </p> <a th:href=\"@{'/platos/' + ${menu.id}}\">Volver a los platos</a> </body> </html> buscarPorCategoria.html <!DOCTYPE html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> <title>Buscar Men\u00fas por Categor\u00eda</title> </head> <body> <h1>Resultados para categor\u00eda: <span th:text=\"${categoriaBuscada}\"></span></h1> <table border=\"1\" th:if=\"${menus}\"> <thead> <tr> <th>ID</th> <th>Nombre</th> <th>Descripci\u00f3n</th> <th>Platos</th> </tr> </thead> <tbody> <tr th:each=\"menu : ${menus}\"> <td th:text=\"${menu.id}\"></td> <td th:text=\"${menu.nombre}\"></td> <td th:text=\"${menu.descripcion}\"></td> <td> <ul> <li th:each=\"plato : ${menu.platos}\" th:if=\"${plato.categoria == categoriaBuscada}\" th:text=\"${plato.nombre}\"></li> </ul> </td> </tr> </tbody> </table> <p th:if=\"${menus == null || menus.isEmpty()}\" style=\"color: gray;\"> No se encontraron men\u00fas con platos de la categor\u00eda <span th:text=\"${categoriaBuscada}\"></span>. </p> <a href=\"/menus\">Volver a la lista de men\u00fas</a> </body> </html>","title":"Ejemplo: Men\u00fas"}]}